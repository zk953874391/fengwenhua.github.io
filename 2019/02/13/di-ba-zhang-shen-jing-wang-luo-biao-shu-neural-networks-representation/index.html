<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="第八章-神经网络-表述(Neural-Networks-Representation), 江南小虫虫的博客">
    <meta name="description" content="第八章 神经网络：表述(Neural Networks: Representation)
8.1 非线性假设（Non-linear Hypotheses）在这节课和接下来的课程中 我将给大家介绍 一种叫“神经网络”(Neural Netwo">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>第八章-神经网络-表述(Neural-Networks-Representation) | 江南小虫虫的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">江南小虫虫的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/biaobai/表白.html" class="waves-effect waves-light">
      
      <i class="fas fa-heart" style="zoom: 0.6;"></i>
      
      <span>给亲爱的老婆仔</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">江南小虫虫的博客</div>
        <div class="logo-desc">
            
            尽力就行~~~
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/biaobai/表白.html" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-heart"></i>
			
			给亲爱的老婆仔
		</a>
          
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">第八章-神经网络-表述(Neural-Networks-Representation)</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/神经网络表述/">
                                <span class="chip bg-color">神经网络表述</span>
                            </a>
                        
                            <a href="/tags/Neural-Networks-Representation/">
                                <span class="chip bg-color">Neural-Networks-Representation</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/机器学习/" class="post-category">
                                机器学习
                            </a>
                        
                            <a href="/categories/机器学习/机器学习入门/" class="post-category">
                                机器学习入门
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-02-12
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2019-11-30
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    19.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    67 分
                </div>
                
				
                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="第八章-神经网络：表述-Neural-Networks-Representation"><a href="#第八章-神经网络：表述-Neural-Networks-Representation" class="headerlink" title="第八章 神经网络：表述(Neural Networks: Representation)"></a>第八章 神经网络：表述(Neural Networks: Representation)</h1><hr>
<h2 id="8-1-非线性假设（Non-linear-Hypotheses）"><a href="#8-1-非线性假设（Non-linear-Hypotheses）" class="headerlink" title="8.1 非线性假设（Non-linear Hypotheses）"></a>8.1 非线性假设（Non-linear Hypotheses）</h2><p>在这节课和接下来的课程中 我将给大家介绍 一种叫<code>“神经网络”(Neural Network)</code> 的机器学习算法</p>
<p>我们将首先讨论 神经网络的<strong>表层结构</strong> 在后续课程中 再来具体讨论的学习算法 神经网络实际上是一个 相对古老的算法 并且后来沉寂了一段时间 不过到了现在 它又成为许多机器学习问题 的首选技术</p>
<p>不过我们为什么还需要这个学习算法？ 我们已经有线性回归和逻辑回归算法了 为什么还要研究神经网络？</p>
<p>为了阐述研究<strong>神经网络算法的目的</strong> 我们首先来看几个机器学习问题作为例子 这几个问题的解决 都依赖于研究复杂的<code>非线性分类器</code></p>
<p>考虑这个监督学习分类的问题 我们已经有了对应的训练集 如果利用<code>逻辑回归算法</code> 来解决这个问题 首先需要构造 一个包含很多<strong>非线性项</strong>的逻辑回归函数 这里g仍是<code>s型函数 (即f(x)=1/(1+e^-x) )</code> 我们能让函数 包含很多像这样的多项式项 事实上 当多项式项数足够多时 那么可能 你能够得到一个 分开正样本和负样本的分界线</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234006.png" alt></p>
<p>当只有两项时 比如 x1 x2 这种方法确实能得到不错的结果 因为你可以 把x1和x2的所有组合 都包含到多项式中 但是对于许多 复杂的机器学习问题 涉及的项往往多于两项</p>
<p>我们之前已经讨论过 <strong>房价预测的问题</strong> 假设现在要处理的是 关于<strong>住房的分类问题</strong> 而不是一个回归问题 假设你对一栋房子的多方面特点 都有所了解 你想预测 房子在未来半年内 能被卖出去的概率 这是一个<strong>分类问题</strong></p>
<p>我们可以想出 很多特征 对于不同的房子有可能 就有上百个特征</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234257.png" alt></p>
<p>对于这类问题 如果要包含 所有的二次项 即使只包含 二项式或多项式的计算 最终的多项式也可能有很多项</p>
<p>比如x1^2 x1x2 x1x3 x1x 直到x1x100 还有x2^2 x2x3 等等很多项 因此 即使只考虑二阶项 也就是说 <strong>两个项的乘积</strong> x1乘以x1 等等类似于此的项 那么 在n=100的情况下 最终也有5000个二次项</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234500.png" alt></p>
<p>而且渐渐地 随着特征个数n的增加 二次项的个数大约以<code>n^2</code>的量级增长 其中 n是原始项的个数 即我们之前说过的x1到x100这些项 事实上二次项的个数大约是(n^2)/2</p>
<p>因此要包含所有的 二次项是很困难的 所以这可能 不是一个好的做法 而且由于项数过多 最后的结果很有可能是<strong>过拟合</strong>的 此外 在处理这么多项时 也存在运算量过大的问题</p>
<p>当然 你也可以试试 只包含上边<strong>这些二次项的子集</strong> 例如 我们只考虑 x1^2 x2^2 x3^2直到 x100^2 这些项 这样就可以将二次项的数量大幅度减少 减少到只有100个二次项 但是由于 忽略了太多相关项 在处理类似左上角的数据时 不可能得到理想的结果 实际上 如果只考虑x1的平方 到x100的平方 这一百个二次项 那么你可能会 拟合出一些特别的假设 比如可能拟合出 一个<strong>椭圆状的曲线</strong> 但是肯定不能拟合出 像左上角这个数据集的分界线</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234746.png" alt></p>
<p>所以5000个二次项看起来已经很多了 而现在假设 包括三次项 或者三阶项 例如x1 x2 x3 x1^2 x2 x10 x11 x17等等 类似的三次项有很多很多 事实上 三次项的个数是以n^3的量级增加 当n=100时 可以计算出来 最后能得到 大概17000个三次项 所以 当初始特征个数n增大时 这些高阶多项式项数 将以几何级数递增 特征空间也随之急剧膨胀 当特征个数n很大时 如果找出附加项 来建立一些分类器 这并不是一个好做法</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234949.png" alt></p>
<p>对于<strong>许多实际的机器学习问题 特征个数n是很大的</strong> 举个例子 关于计算机视觉中的一个问题 假设你想要 使用机器学习算法 来训练一个分类器 使它检测一个图像 来<strong>判断图像是否为一辆汽车</strong></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110235108.png" alt></p>
<p>很多人可能会好奇 这对计算机视觉来说有什么难的 当我们自己看这幅图像时 里面有什么是一目了然的事情 你肯定会很奇怪 为什么学习算法竟可能会不知道 图像是什么</p>
<p>为了解答这个疑问 我们取出这幅图片中的一小部分 将其放大 比如图中 这个红色方框内的部分 结果表明 当人眼看到一辆汽车时 计算机实际上看到的却是这个 一个数<code>据矩阵</code> 或像这种格网 它们表示了<code>像素强度值</code> 告诉我们 <strong>图像中每个像素的亮度值</strong> 因此 对于计算机视觉来说问题就变成了 <strong>根据这个像素点亮度矩阵 来告诉我们 这些数值代表一个汽车门把手</strong></p>
<p>具体而言 当用机器学习算法构造 一个<code>汽车识别器时</code> 我们要想出 一个带标签的样本集 其中一些样本 是各类汽车 另一部分样本 是其他任何东西 将这个样本集输入给学习算法 以训练出一个<code>分类器</code> 训练完毕后 我们输入一幅新的图片 让分类器判定 “这是什么东西？”</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110235348.png" alt></p>
<p>理想情况下 分类器能识别出这是一辆汽车</p>
<p>为了理解引入 <strong>非线性分类器的必要性</strong> 我们从学习算法的<code>训练样本</code>中 挑出一些汽车图片 和一些非汽车图片</p>
<p>让我们从其中 每幅图片中挑出一组像素点 这是像素点1的位置 这是像素点2的位置 在坐标系中标出这幅汽车的位置 <strong>在某一点上 车的位置取决于 像素点1和像素点2的亮度</strong></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110235648.png" alt></p>
<p>让我们用同样的方法标出其他图片中汽车的位置 然后我们再举一个 关于汽车的不同的例子 观察这<strong>两个相同的像素位置</strong> 这幅图片中 像素1有一个像素强度 像素2也有一个不同的像素强度 所以在这幅图中它们两个处于不同的位置</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110235814.png" alt></p>
<p>我们继续画上两个非汽车样本 这个不是汽车 这个也不是汽车 然后我们继续 在坐标系中画上更多的新样本</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111000301.png" alt></p>
<p>用’’+”表示汽车图片 用“-”表示非汽车图片 我们将发现 汽车样本和非汽车样本 分布在坐标系中的不同区域 因此 我们现在需要一个 非线性分类器 来尽量分开这两类样本</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111000343.png" alt></p>
<p>这个分类问题中<strong>特征空间的维数</strong>是多少？ 假设我们用50*50像素的图片 我们的图片已经很小了 长宽只各有50个像素 但这依然是2500个像素点 因此 我们的特征向量的元素数量 N=2500 特征向量X 包含了所有像素点的亮度值 这是像素点1的亮度 这是像素点2的亮度 如此类推 直到最后一个 像素点的亮度</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111000517.png" alt></p>
<p>对于典型的计算机图片表示方法 如果存储的是每个像素点的<code>灰度值 (色彩的强烈程度)</code> 那么<strong>每个元素的值 应该在0到255之间</strong> 因此 这个问题中n=2500 但是 这只是使用灰度图片的情况 如果我们用的是<code>RGB彩色图像</code> 每个像素点包含<code>红、绿、蓝</code>三个子像素 那么n=7500</p>
<p>因此 如果我们非要 通过包含所有的二次项 来解决这个非线性问题 那么 这就是式子中的所有条件 <code>xi x xj</code>(笛卡尔积) 连同开始的2500像素 总共大约有300万个（(2500^2)/2） 这数字大得有点离谱了 对于每个样本来说 要发现并表示 所有这300万个项 这计算成本太高了</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111000710.png" alt></p>
<p>因此 只是简单的增加 二次项或者三次项 之类的逻辑回归算法 并不是一个解决<code>复杂非线性问题</code>的好办法 因为当n很大时 将会产生非常多的<code>特征项</code> 在接下来的视频课程中 我将为大家讲解神经网络 它在解决复杂的非线性分类问题上 被证明是 是一种好得多的算法 即使你输入特征空间 或输入的特征维数n很大也能轻松搞定</p>
<h3 id="小小的总结–非线性假设"><a href="#小小的总结–非线性假设" class="headerlink" title="小小的总结–非线性假设"></a>小小的总结–非线性假设</h3><p>我们之前学的，无论是线性回归还是逻辑回归都有这样一个缺点，即：当特征太多时，计算的负荷会非常大。</p>
<p>下面是一个例子：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110314.png" alt></p>
<p>当我们使用$x_1$, $x_2$ 的多次项式进行预测时，我们可以应用的很好。<br>之前我们已经看到过，使用非线性的多项式项，能够帮助我们建立更好的分类模型。假设我们有非常多的特征，例如大于100个变量，我们希望用这100个特征来构建一个非线性的多项式模型，结果将是数量非常惊人的特征组合，即便我们只采用两两特征的组合$(x_1x_2+x_1x_3+x_1x_4+...+x_2x_3+x_2x_4+...+x_{99}x_{100})$，我们也会有接近5000个组合而成的特征。这对于一般的逻辑回归来说需要计算的特征太多了。</p>
<p>假设我们希望训练一个模型来识别视觉对象（例如识别一张图片上是否是一辆汽车），我们怎样才能这么做呢？一种方法是我们利用很多汽车的图片和很多非汽车的图片，然后利用这些图片上一个个像素的值（饱和度或亮度）来作为特征。</p>
<p>假如我们只选用灰度图片，每个像素则只有一个值（而非 <strong>RGB</strong>值），我们可以选取图片上的两个不同位置上的两个像素，然后训练一个逻辑回归算法利用这两个像素的值来判断图片上是否是汽车：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110325.png" alt></p>
<p>假使我们采用的都是50x50像素的小图片，并且我们将所有的像素视为特征，则会有 2500个特征，如果我们要进一步将两两特征组合构成一个多项式模型，则会有约${{2500}^{2}}/2$个（接近3百万个）特征。普通的逻辑回归模型，不能有效地处理这么多的特征，这时候我们需要神经网络。</p>
<h2 id="8-2-神经元和大脑-Neurons-and-the-Brain"><a href="#8-2-神经元和大脑-Neurons-and-the-Brain" class="headerlink" title="8.2 神经元和大脑(Neurons and the Brain)"></a>8.2 神经元和大脑(Neurons and the Brain)</h2><p><code>神经网络</code>是一种很古老的算法 它最初产生的目的是 制造能模拟大脑的机器 在这门课中 我将向你们介绍神经网络 因为它能很好地解决 不同的机器学习问题 而不只因为它们在逻辑上行得通</p>
<p>在本节课中 告诉你们一些神经网络的背景知识 由此我们能知道可以用它们来做什么 不管是将其应用到现代的机器学习问题上 还是应用到那些你可能会感兴趣的问题中 也许这一伟大的人工智能梦想在未来能制造出真正的智能机器</p>
<p>另外 我们还将讲解神经网络是怎么涉及这些问题的</p>
<p><strong>神经网络产生的原因</strong> 是人们想尝试设计出 模仿大脑的算法 从某种意义上说如果我们 想要建立学习系统 那为什么不去模仿 我们所认识的最神奇的学习机器——-人类的大脑呢 神经网络逐渐兴起于 二十世纪八九十年代 应用得非常广泛 但由于各种原因 在90年代的后期应用减少了 但是最近 神经网络 又东山再起了</p>
<p>其中一个原因是 <strong>神经网络是计算量有些偏大的算法</strong> 然而 大概由于近些年 <strong>计算机的运行速度变快才足以真正运行起大规模的神经网络</strong> 正是由于这个原因 和其他一些我们后面会讨论到的 技术因素 如今的神经网络 对于许多应用来说是最先进的技术</p>
<p>当你想模拟大脑时 是指想制造出与人类大脑 作用效果相同的机器 对吧？ 大脑可以学会去 以看而不是听的方式处理图像 学会处理我们的触觉 我们能学习数学  学着做微积分 而且大脑能处理 各种不同的令人惊奇的事情 似乎如果你想要 模仿它 你得写很多不同的 软件来模拟所有 大脑告诉我们的这些 五花八门的奇妙的事情 不过能不能假设 大脑做所有这些 不同事情的方法 不需要用上千个不同的程序去实现 相反的 大脑处理的方法 只需要 一个单一的学习算法就可以了？ 尽管这只是一个假设 不过让我和你分享 一些这方面的证据</p>
<p>大脑的这一部分 这一小片红色区域 是你的听觉皮层 你现在正在理解我的话 这靠的是耳朵 耳朵接收到声音信号 并把声音信号传递给你的 听觉皮层 正因如此 你才能明白我的话</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111001739.png" alt></p>
<p>神经系统科学家做了 下面这个有趣的实验 把 <strong>耳朵到听觉皮层的神经切断</strong> 在这种情况下 将其重新接到一个动物的大脑上 这样从眼睛到 视神经的信号最终将传到听觉皮层</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111001936.png" alt></p>
<p>如果这样做了 那么结果表明 听觉皮层将会 学会“看” 这里“看”代表了 我们所知道的每层含义 所以 如果你对动物这样做 那么动物就可以完成视觉辨别任务 它们可以看图像 并根据图像做出适当的决定 它们正是通过 脑组织中的这个部分完成的</p>
<p>来看另一个例子</p>
<p>这块红色的脑组织是你的<code>躯体感觉皮层</code> 这是你用来<strong>处理触觉</strong>的 如果你做一个和刚才类似的重接实验 那么躯体感觉皮层也能学会”看“ 这个实验和其它一些 类似的实验 被称为<code>神经重接实验</code></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111002127.png" alt></p>
<p>从这个意义上说 如果 人体有同一块 脑组织可以处理光、 声或触觉信号 那么也许存在一种学习算法 可以同时处理 视觉、听觉和触觉 而不是需要 运行上千个不同的程序 或者上千个不同的算法来做这些 大脑所完成的 成千上万的美好事情 也许我们需要做的就是找出 一些近似的或 实际的大脑学习算法 然后实现它 大脑通过自学掌握如何 处理这些不同类型的数据</p>
<p>在很大的程度上 可以猜想如果我们 把几乎任何一种传感器 接入到大脑的 几乎任何一个部位的话 大脑就会学会处理它</p>
<p>下面再举几个例子 左上角的这张图是 用舌头学会“看”的一个例子 它的原理是 这实际上是 一个名为BrainPort的系统 它现在正在FDA (美国食品和药物管理局) 的临床试验阶段 它能帮助失明人士看见事物 它的原理是 你在前额上带一个灰度摄像头 面朝前 它就能 获取你面前事物的 低分辨率的灰度图像 你连一根线 到舌头上安装的 电极阵列上 那么每个像素都被映射到 你舌头的 某个位置上 可能电压值高的点对应一个 暗像素 电压值低的点 对应于亮像素 即使依靠 它现在的功能 使用这种系统就能让你我 在几十分钟里就学会 用我们的舌头“看”东西</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111002341.png" alt></p>
<p>这是第二个例子 关于人体回声定位或者说人体声纳 你有两种方法可以实现 你可以弹响指 或者咂舌头 这个我做不好 不过现在有失明人士 确实在学校里 接受这样的培训 并学会解读 从环境反弹回来的声波模式—这就是<code>声纳</code> 如果你搜索 YouTube之后 就会发现 有些视频讲述了一个令人称奇的孩子 他因为癌症眼球惨遭移除 虽然失去了眼球 但是通过打响指 他可以四处走动而不撞到任何东西 他能滑滑板 他可以将篮球投入篮框中 注意这是一个没有眼球的孩子</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111002434.png" alt></p>
<p>第三个例子是 触觉皮带 如果你把它 戴在腰上 蜂鸣器会响 而且总是朝向北时发出嗡嗡声 它可以使人拥有 方向感 用类似于 鸟类感知方向的方式 还有一些离奇的例子 如果你在青蛙身上 插入第三只眼 青蛙也能学会使用那只眼睛</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111002728.png" alt></p>
<p>因此 这将会非常令人惊奇 如果你能 把几乎任何传感器 接入到大脑中 大脑的学习算法就能 找出学习数据的方法 并处理这些数据</p>
<p>从某种意义上来说 如果我们能找出 大脑的学习算法 然后在计算机上执行 大脑学习算法或与之相似的算法 也许 这将是我们 向人工智能迈进 做出的最好的尝试 人工智能的梦想就是 有一天能制造出真正的智能机器</p>
<p>当然我不是 教神经网络的 介绍它只因为它可能为我们 打开一扇进入遥远的 人工智能梦的窗户 对于我个人来说 它也是我研究生涯中致力于的一个项目 但我在这节课中 讲授神经网络的原因 主要是对于 现代机器学习应用 它是最有效的技术方法 因此在接下来的 一些课程中 我们将开始深入到 神经网络的技术细节 那么你就可以 将它们应用到现代 机器学习的应用中 并利用它们很好地解决问题 但对我来说 使我兴奋的原因之一 就是它或许能 给我们一些启示 让我们知道 当我们在思考 未来有什么样的算法 能以与人类相似的方式学习时 我们能做些什么</p>
<h3 id="小小的总结–神经元和大脑"><a href="#小小的总结–神经元和大脑" class="headerlink" title="小小的总结–神经元和大脑"></a>小小的总结–神经元和大脑</h3><p>神经网络是一种很古老的算法，它最初产生的目的是制造能模拟大脑的机器。</p>
<p>在这门课中，我将向你们介绍神经网络。因为它能很好地解决不同的机器学习问题。而不只因为它们在逻辑上行得通，在这段视频中，我想告诉你们一些神经网络的背景知识，由此我们能知道可以用它们来做什么。不管是将其应用到现代的机器学习问题上，还是应用到那些你可能会感兴趣的问题中。也许，这一伟大的人工智能梦想在未来能制造出真正的智能机器。另外，我们还将讲解神经网络是怎么涉及这些问题的神经网络产生的原因是人们想尝试设计出模仿大脑的算法，从某种意义上说如果我们想要建立学习系统，那为什么不去模仿我们所认识的最神奇的学习机器——人类的大脑呢？</p>
<p>神经网络逐渐兴起于二十世纪八九十年代，应用得非常广泛。但由于各种原因，在90年代的后期应用减少了。但是最近，神经网络又东山再起了。其中一个原因是：神经网络是计算量有些偏大的算法。然而大概由于近些年计算机的运行速度变快，才足以真正运行起大规模的神经网络。正是由于这个原因和其他一些我们后面会讨论到的技术因素，如今的神经网络对于许多应用来说是最先进的技术。当你想模拟大脑时，是指想制造出与人类大脑作用效果相同的机器。大脑可以学会去以看而不是听的方式处理图像，学会处理我们的触觉。</p>
<p>我们能学习数学，学着做微积分，而且大脑能处理各种不同的令人惊奇的事情。似乎如果你想要模仿它，你得写很多不同的软件来模拟所有这些五花八门的奇妙的事情。不过能不能假设大脑做所有这些，不同事情的方法，不需要用上千个不同的程序去实现。相反的，大脑处理的方法，只需要一个单一的学习算法就可以了？尽管这只是一个假设，不过让我和你分享，一些这方面的证据。</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110410.png" alt></p>
<p>大脑的这一部分这一小片红色区域是你的听觉皮层，你现在正在理解我的话，这靠的是耳朵。耳朵接收到声音信号，并把声音信号传递给你的听觉皮层，正因如此，你才能明白我的话。</p>
<p>神经系统科学家做了下面这个有趣的实验，把耳朵到听觉皮层的神经切断。在这种情况下，将其重新接到一个动物的大脑上，这样从眼睛到视神经的信号最终将传到听觉皮层。如果这样做了。那么结果表明听觉皮层将会学会“看”。这里的“看”代表了我们所知道的每层含义。所以，如果你对动物这样做，那么动物就可以完成视觉辨别任务，它们可以看图像，并根据图像做出适当的决定。它们正是通过脑组织中的这个部分完成的。下面再举另一个例子，这块红色的脑组织是你的躯体感觉皮层，这是你用来处理触觉的，如果你做一个和刚才类似的重接实验，那么躯体感觉皮层也能学会“看”。这个实验和其它一些类似的实验，被称为神经重接实验，从这个意义上说，如果人体有同一块脑组织可以处理光、声或触觉信号，那么也许存在一种学习算法，可以同时处理视觉、听觉和触觉，而不是需要运行上千个不同的程序，或者上千个不同的算法来做这些大脑所完成的成千上万的美好事情。也许我们需要做的就是找出一些近似的或实际的大脑学习算法，然后实现它大脑通过自学掌握如何处理这些不同类型的数据。在很大的程度上，可以猜想如果我们把几乎任何一种传感器接入到大脑的几乎任何一个部位的话，大脑就会学会处理它。</p>
<p>下面再举几个例子：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110425.png" alt></p>
<p>这张图是用舌头学会“看”的一个例子。它的原理是：这实际上是一个名为<strong>BrainPort</strong>的系统，它现在正在<strong>FDA</strong><br>(美国食品和药物管理局)的临床试验阶段，它能帮助失明人士看见事物。它的原理是，你在前额上带一个灰度摄像头，面朝前，它就能获取你面前事物的低分辨率的灰度图像。你连一根线到舌头上安装的电极阵列上，那么每个像素都被映射到你舌头的某个位置上，可能电压值高的点对应一个暗像素电压值低的点。对应于亮像素，即使依靠它现在的功能，使用这种系统就能让你我在几十分钟里就学会用我们的舌头“看”东西。</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110436.png" alt></p>
<p>这是第二个例子，关于人体回声定位或者说人体声纳。你有两种方法可以实现：你可以弹响指，或者咂舌头。不过现在有失明人士，确实在学校里接受这样的培训，并学会解读从环境反弹回来的声波模式—这就是声纳。如果你搜索<strong>YouTube</strong>之后，就会发现有些视频讲述了一个令人称奇的孩子，他因为癌症眼球惨遭移除，虽然失去了眼球，但是通过打响指，他可以四处走动而不撞到任何东西，他能滑滑板，他可以将篮球投入篮框中。注意这是一个没有眼球的孩子。</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110451.png" alt></p>
<p>第三个例子是触觉皮带，如果你把它戴在腰上，蜂鸣器会响，而且总是朝向北时发出嗡嗡声。它可以使人拥有方向感，用类似于鸟类感知方向的方式。</p>
<p>还有一些离奇的例子：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110458.png" alt></p>
<p>如果你在青蛙身上插入第三只眼，青蛙也能学会使用那只眼睛。因此，这将会非常令人惊奇。如果你能把几乎任何传感器接入到大脑中，大脑的学习算法就能找出学习数据的方法，并处理这些数据。从某种意义上来说，如果我们能找出大脑的学习算法，然后在计算机上执行大脑学习算法或与之相似的算法，也许这将是我们向人工智能迈进做出的最好的尝试。人工智能的梦想就是：有一天能制造出真正的智能机器。</p>
<p>神经网络可能为我们打开一扇进入遥远的人工智能梦的窗户，但我在这节课中讲授神经网络的原因，主要是对于现代机器学习应用。它是最有效的技术方法。因此在接下来的一些课程中，我们将开始深入到神经网络的技术细节。</p>
<h2 id="8-3-模型表示1-Model-Representation-1"><a href="#8-3-模型表示1-Model-Representation-1" class="headerlink" title="8.3 模型表示1(Model Representation 1)"></a>8.3 模型表示1(Model Representation 1)</h2><p>在这个视频中 我想 开始向你介绍 我们该如何表示神经网络 换句话说 当我们在 <strong>运用神经网络时 我们该如何表示我们的假设或模型</strong> 神经网络是在模仿 大脑中的<code>神经元</code>或者<code>神经网络</code>时发明的 因此 要解释如何表示 模型假设 我们先来看<strong>单个神经元在大脑中是什么样的</strong></p>
<p>我们的大脑中充满了 这样的神经元 <code>神经元</code>是大脑中的细胞 其中有两点 值得我们注意 一是神经元有 像这样的<code>细胞主体</code></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111003137.png" alt></p>
<p>二是神经元有 一定数量的 输入神经 这些<strong>输入神经</strong>叫做<code>树突</code> 可以把它们想象成输入电线 它们<strong>接收来自其他神经元的信息</strong></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111003418.png" alt></p>
<p>神经元的<strong>输出神经</strong>叫做<code>轴突</code> 这些输出神经 是用来 <strong>给其他神经元传递信号 或者传送信息的</strong></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111003515.png" alt></p>
<p>简而言之 <strong><code>神经元</code>是一个计算单元 它从输入神经接受一定数目的信息 并做一些计算 然后将结果通过它的 轴突传送到其他节点 或者大脑中的其他神经元</strong></p>
<p>下面是一组神经元的示意图 神经元利用微弱的电流 进行沟通 这些弱电流也称作<code>动作电位</code> 其实就是一些微弱的电流</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111004603.png" alt></p>
<p>所以如果 <strong>神经元想要传递一个消息</strong> 它就会就通过它的<code>轴突</code> 发送一段微弱电流 给其他神经元 这就是<code>轴突</code> 这里是一条 连接到<code>输入神经</code> 或者连接<code>另一个神经元树突的神经</code> 接下来这个神经元接收这条消息 做一些计算 它有可能会反过来将 在轴突上的 自己的消息传给其他神经元</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111004853.png" alt></p>
<p>这就是所有 人类思考的模型： <strong>我们的神经元把自己的收到的消息进行计算,并向其他神经元 传递消息</strong></p>
<p>顺便说一下 这也是 我们的感觉和肌肉运转的原理 如果你想活动一块肌肉 就会触发一个神经元 给你的肌肉 发送<code>脉冲</code> 并引起 你的肌肉收缩 如果一些感官 比如说眼睛 想要给大脑传递 一个消息 那么它就像这样发送 电脉冲给大脑的</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111005109.png" alt></p>
<p>在一个神经网络里 或者说在我们在电脑上 实现的人工神经网络里 我们将使用 一个非常简单的模型 来模拟神经元的工作 我们<strong>将神经元模拟成一个逻辑单元</strong> 当我画一个这样的 黄色圆圈时 你应该 把它想象成 作用类似于 神经元的东西 然后我们通过 它的树突或者说它的输入神经 传递给它一些信息 然后神经元做一些计算 并通过它的输出神经 即它的轴突 输出计算结果</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111005426.png" alt></p>
<p>当我画一个像这样的图表时 就表示对h(x)的计算 <strong>h(x)等于1除以1加e的负θ转置乘以x</strong> 通常 x和θ 是我们的参数向量 这是一个简单的模型 甚至说是一个过于简单的 模拟神经元的模型 它被输入 x1 x2和 x3 然后输出一些 类似这样的结果</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111005728.png" alt></p>
<p>当我绘制一个神经网络时 通常我只绘制 输入节点 x1 x2 x3 但有时也可以这样做： 我增加一个额外的节点 x0 这个 x0 节点 有时也被称作<code>偏置单位</code> 或<code>偏置神经元</code> 但因为 x0 总是等于1 所以有时候 我会画出它 有时我不会画出 这取决于它是否对例子有利</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111005901.png" alt></p>
<p>现在来讨论 最后一个关于 神经网络的术语 有时我们会说 这是一个神经元 <strong>一个有s型函数或者<code>逻辑函数</code>作为激励函数的 <code>人工神经元</code></strong> 在神经网络术语中 <code>激励函数</code><strong>只是对类似非线性函数g(z)的另一个术语称呼</strong> g(z)等于 <strong>1除以1加e的-z次方</strong></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010225.png" alt></p>
<p>到目前为止 我一直称<code>θ</code>为<code>模型的参数</code> 以后大概会继续将这个术语与 “参数”相对应 而不是与在关于神经网络的文献里 有时你可能会看到人们 谈论一个模型的<code>权重</code> <strong>权重其实和模型的参数 是一样的东西</strong> 在视频中 我会继续使用“参数”这个术语 但有时你可能听到别人用“权重”这个术语</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010347.png" alt></p>
<p>以上的黄色小圈，代表<strong>一个单一的神经元</strong></p>
<p><code>神经网络</code>其实就是下图这些不同的神经元组合在一起的<strong>集合</strong></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010504.png" alt></p>
<p>具体来说 这里是我们的 输入单元 x1 x2和 x3 再说一次 有时也可以画上 额外的节点 x0 我把 x0 画在这了 里有 3个神经元 我在里面写了a(2)1 a(2)2 和a(2)3 然后再次说明 我们可以在这里 添加一个a0 和一个额外的<code>偏度单元</code> <strong>它的值永远是1</strong> 最后 我们在 最后一层有第三个节点 正是这第三个节点 输出 <strong>假设函数h(x)计算的结果</strong></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010613.png" alt></p>
<p>再多说一点关于 神经网络的术语 网络中的第一层 也被称为<code>输入层</code> 因为我们在这一层 输入我们的特征项 x1 x2 x3 最后一层 也称为<code>输出层</code> 因为这一层的 神经元—我指的这个 输出 假设的最终计算结果 中间的两层 也被称作<code>隐藏层</code> 隐藏层不是一个 很合适的术语 但是 直觉上我们知道 在监督学习中 你能看到输入 也能看到正确的输出 而隐藏层的值 你在训练集里是看不到的 它的值不是 x 也不是y 所以我们叫它<code>隐藏层</code></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010832.png" alt></p>
<p>稍后我们会看到神经网络 可以有不止一个的 隐藏层 但在 这个例子中 我们有一个 输入层—第1层 一个隐藏层— 第2层 和一个输出层—第3层 但实际上任何 <strong>非输入层或非输出层的层</strong>就被称为<code>隐藏层</code></p>
<p>接下来 我希望你们明白神经网络 究竟在做什么 让我们逐步分析 这个图表所呈现的 计算步骤</p>
<p>为了解释这个神经网络 具体的计算步骤 这里还有些记号要解释 我要使用<code>a上标(j)下标i</code>表示 <strong>第j层的第i个神经元或单元</strong> 具体来说 这里 a上标(2) 下标1 表示第2层的 第一个激励 即隐藏层的第一个激励 所谓<code>激励(activation)</code> 是指 <strong>由一个具体神经元读入计算并输出的值</strong></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011256.png" alt></p>
<p>此外 我们的神经网络 被这些矩阵参数化 <code>θ上标(j)</code> 它将成为 一个<code>波矩阵</code> 控制着 比如说 从第一层到第二层 或者 第二层到第三层的作用</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011414.png" alt></p>
<p>所以 这就是这张图所表示的计算</p>
<p>这里的第一个隐藏单元 是这样计算它的值的： a(2)1等于 s函数（或者说s激励函数，也叫做逻辑激励函数） 作用在这种 输入的线性组合上的结果</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011643.png" alt></p>
<p>第二个隐藏单元 等于s函数作用在这个 线性组合上的值 同样 对于第三个 隐藏的单元 它是通过这个公式计算的</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011746.png" alt></p>
<p>在这里 我们有三个 输入单元和三个隐藏单元</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011904.png" alt></p>
<p>这样一来 参数矩阵控制了 我们来自 三个输入单元 三个隐藏单元的映射 因此θ1的维数 将变成3 θ1将变成一个 3乘4维的 矩阵 <strong>因为x0是偏度单元，它的值永远是1,所以变成3X4,不要a(2)0是因为它在计算下一层的时候用到,这一层不需要计算它</strong></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111012412.png" alt></p>
<p>更一般的 如果一个网络在第j 层有sj个单元 在j+1层有 sj+1个单元 那么矩阵θ(j) 即控制第j层到 第j+1层映射 的矩阵的 维度为s(j+1) * (sj+1) 这里要搞清楚 这个是s下标j+1 而这个是 s下标j 然后 整体加上1 整体加1 明白了吗 所以θ(j)的维度是 s(j+1)行 sj+1列 这里sj+1 当中的1 不是下标的一部分</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111233445.png" alt></p>
<p>以上我们讨论了 三个隐藏单位是怎么计算它们的值</p>
<p>最后 在输出层 我们还有一个 单元 它计算 <code>h(x)</code> 这个也可以 写成a(3)1 就等于后面这块</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111234313.png" alt></p>
<p>注意到我这里 写了个上标2 因为θ上标2 是<code>参数矩阵</code>，或着说是<code>权重矩阵</code>。该矩阵<strong>控制从第二层（即隐藏层的3个单位） 到第三层的一个单元 （即输出单元） 的<code>映射</code></strong></p>
<p>总之 以上我们 展示了像这样一张图是 怎样定义 一个人工神经网络的 这个神经网络定义了函数h： 从输入 x 到输出y的映射 我将这些假设的参数 记为大写的θ 这样一来 不同的θ 对应了不同的假设 所以我们有不同的函数 比如说从 x到y的映射 以上就是我们怎么 从数学上定义 神经网络的假设</p>
<p>在接下来的视频中 我想要做的就是 让你对这些假设的作用 有更深入的理解 并且讲解几个例子 然后谈谈如何有效的计算它们 【教育无边界字幕组】翻译人员不详</p>
<h3 id="小小的总结–模型表示"><a href="#小小的总结–模型表示" class="headerlink" title="小小的总结–模型表示"></a>小小的总结–模型表示</h3><p>为了构建神经网络模型，我们需要首先思考大脑中的神经网络是怎样的？每一个神经元都可以被认为是一个处理单元/神经核（<strong>processing unit</strong>/<strong>Nucleus</strong>），它含有许多输入/树突（<strong>input</strong>/<strong>Dendrite</strong>），并且有一个输出/轴突（<strong>output</strong>/<strong>Axon</strong>）。神经网络是大量神经元相互链接并通过电脉冲来交流的一个网络。</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110558.png" alt></p>
<p>下面是一组神经元的示意图，神经元利用微弱的电流进行沟通。这些弱电流也称作动作电位，其实就是一些微弱的电流。所以如果神经元想要传递一个消息，它就会就通过它的轴突，发送一段微弱电流给其他神经元，这就是轴突。</p>
<p>这里是一条连接到输入神经，或者连接另一个神经元树突的神经，接下来这个神经元接收这条消息，做一些计算，它有可能会反过来将在轴突上的自己的消息传给其他神经元。这就是所有人类思考的模型：我们的神经元把自己的收到的消息进行计算，并向其他神经元传递消息。这也是我们的感觉和肌肉运转的原理。如果你想活动一块肌肉，就会触发一个神经元给你的肌肉发送脉冲，并引起你的肌肉收缩。如果一些感官：比如说眼睛想要给大脑传递一个消息，那么它就像这样发送电脉冲给大脑的。</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110610.png" alt></p>
<p>神经网络模型建立在很多神经元之上，每一个神经元又是一个个学习模型。这些神经元（也叫激活单元，<strong>activation unit</strong>）采纳一些特征作为输出，并且根据本身的模型提供一个输出。下图是一个以逻辑回归模型作为自身学习模型的神经元示例，在神经网络中，参数又可被成为权重（<strong>weight</strong>）。</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110629.png" alt></p>
<p>我们设计出了类似于神经元的神经网络，效果如下：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110640.png" alt></p>
<p>其中$x_1$, $x_2$, $x_3$是输入单元（<strong>input units</strong>），我们将原始数据输入给它们。</p>
$a_1$, $a_2$, $a_3$是中间单元，它们负责将数据进行处理，然后呈递到下一层。
<p>最后是输出单元，它负责计算${h_\theta}\left( x \right)$。</p>
<p>神经网络模型是许多逻辑单元按照不同层级组织起来的网络，每一层的输出变量都是下一层的输入变量。下图为一个3层的神经网络，第一层成为输入层（<strong>Input Layer</strong>），最后一层称为输出层（<strong>Output Layer</strong>），中间一层成为隐藏层（<strong>Hidden Layers</strong>）。我们为每一层都增加一个偏差单位（<strong>bias unit</strong>）：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110650.png" alt></p>
<p>下面引入一些标记法来帮助描述模型：</p>
$a_{i}^{\left( j \right)}$ 代表第$j$ 层的第 $i$ 个激活单元。${{\theta }^{\left( j \right)}}$代表从第 $j$ 层映射到第$ j+1$ 层时的权重的矩阵，例如${{\theta }^{\left( 1 \right)}}$代表从第一层映射到第二层的权重的矩阵。其尺寸为：以第 $j+1$层的激活单元数量为行数，以第 $j$ 层的激活单元数加一为列数的矩阵。例如：上图所示的神经网络中${{\theta }^{\left( 1 \right)}}$的尺寸为 3*4。

<p>对于上图所示的模型，激活单元和输出分别表达为：</p>
$a_{1}^{(2)}=g(\Theta _{10}^{(1)}{{x}_{0}}+\Theta _{11}^{(1)}{{x}_{1}}+\Theta _{12}^{(1)}{{x}_{2}}+\Theta _{13}^{(1)}{{x}_{3}})$
$a_{2}^{(2)}=g(\Theta _{20}^{(1)}{{x}_{0}}+\Theta _{21}^{(1)}{{x}_{1}}+\Theta _{22}^{(1)}{{x}_{2}}+\Theta _{23}^{(1)}{{x}_{3}})$
$a_{3}^{(2)}=g(\Theta _{30}^{(1)}{{x}_{0}}+\Theta _{31}^{(1)}{{x}_{1}}+\Theta _{32}^{(1)}{{x}_{2}}+\Theta _{33}^{(1)}{{x}_{3}})$
${{h}_{\Theta }}(x)=g(\Theta _{10}^{(2)}a_{0}^{(2)}+\Theta _{11}^{(2)}a_{1}^{(2)}+\Theta _{12}^{(2)}a_{2}^{(2)}+\Theta _{13}^{(2)}a_{3}^{(2)})$

<p>上面进行的讨论中只是将特征矩阵中的一行（一个训练实例）喂给了神经网络，我们需要将整个训练集都喂给我们的神经网络算法来学习模型。</p>
<p>我们可以知道：每一个$a$都是由上一层所有的$x$和每一个$x$所对应的决定的。</p>
<p>（我们把这样从左到右的算法称为前向传播算法( <strong>FORWARD PROPAGATION</strong> )）</p>
<p>把$x$, $\theta$, $a$ 分别用矩阵表示：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110712.png" alt></p>
<p>我们可以得到$\theta \cdot X=a$ 。</p>
<h2 id="8-4-模型表示2-Model-Representation-II"><a href="#8-4-模型表示2-Model-Representation-II" class="headerlink" title="8.4 模型表示2( Model Representation II )"></a>8.4 模型表示2( Model Representation II )</h2><p>在前面的视频里 我们 解释了怎样用数学来 定义或者计算 神经网络算法的假设</p>
<p>在这段视频中 我想 告诉你如何 高效地进行计算 并展示一个<code>向量化</code>的实现方法</p>
<p>更重要的是 我想 让你们明白为什么 这样表示神经网络 是一个好的方法 并且明白 它们怎样帮助我们学习复杂的<code>非线性假设</code></p>
<p>以这个神经网络为例 以前我们说 计算出假设输出 的步骤 是左边的这些 方程 通过这些方程 我们计算出 三个隐藏单元的<code>激励值</code> 然后利用 这些值来计算 假<code>设h(x)</code>的最终输出</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111234714.png" alt></p>
<p>接下来 我要 定义一些额外的项 因此 这里 我画线的项 把它定义为<code>z上标(2) 下标1</code> 这样一来 就有了 <code>a(2)1</code> 这个项 等于 <code>g(z(2)1)</code> 另外顺便提一下 这些上标2 的意思是 在z(2)和a(2)中 括号中的 2表示这些值 与第二层相关 即与神经网络中的 隐藏层有关</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111235101.png" alt></p>
<p>接下来 这里的项 我将同样定义为 z(2)2 最后这个 我画线的项 我把它定义为z(2)3 这样 我们有a(2)3 等于 g(z(2)3) 所以这些z值都是 一个线性组合 是输入值x0 x1 x2 x3的 加权线性组合 它将会进入一个特定的神经元</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111235232.png" alt></p>
<p>现在 看一下 这一堆数字 你可能会注意到这块 对应了 矩阵向量运算 类似于矩阵向量乘法 x1乘以向量x 观察到一点 我们就能将 <strong>神经网络的计算向量化</strong>了</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111235401.png" alt></p>
<p>具体而言 我们定义 特征向量x 为x0 x1 x2 x3组成的向量 其中x0 仍然等于1 并定义 z(2)为 这些z值组成的向量 即z(2)1 z(2)2 z(2)3 注意 在这里 z(2) 是一个三维向量</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111235654.png" alt></p>
<p>下面 我们可以这样 向量化a(2)1 a(2)2 a(2)3的计算 我们只用两个步骤 z(2)等于θ(1) 乘以x 这样就有了向量z(2) 然后 a(2)等于 g(z(2)) 需要明白 这里的z(2)是 三维向量 并且 a(2)也是一个三维 向量 因此这 里的激励g 将s函数 逐元素作用于 z(2)中的每个元素</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112000135.png" alt></p>
<p>顺便说一下 为了让我们 的符号和接下来的 工作相一致 在输入层 虽然我们有 输入x 但我们 还可以把这些想成 是第一层的激励 所以 我可以定义a(1) 等于x 因此 a(1)就是一个向量了 我就可以把这里的x 替换成a(1) z(2)就等于θ(1)乘以a(1) 这都是通过在输入层定义a(1)做到的</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112000309.png" alt></p>
<p>现在 就我目前所写的 我得到了 a1 a2 a3的值 并且 我应该把 上标加上去 但我还需要一个值 我同样需要这个a(2)0 它对应于 隐藏层的 得到这个输出的<code>偏置单元</code> 当然 这里也有一个 偏置单元 我只是没有 画出来</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112000748.png" alt></p>
<p>注意这额外的偏置单元 接下来我们 要额外加上一个<strong>a0 上标(2) 它等于1</strong> 这样一来 现在 a(2)就是一个 四维的特征向量 因为我们刚添加了 这个额外的 a0 它等于 1并且它是隐藏层的 一个偏置单元</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112000930.png" alt></p>
<p>最后 为了计算假设的 实际输出值 我们 只需要计算 z(3) z(3)等于 这里我画线的项 这个方框里的项就是z(3)</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112001106.png" alt></p>
<p>z(3)等于θ(2) 乘以a(2) 最后 假设输出为h(x) 它等于a(3) a(3)是输出层 唯一的单元 它是一个实数 你可以写成a(3) 或a(3)1 这就是g(z(3)) 这个计算h(x)的过程 也称为<code>前向传播(forward propagation)</code></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112001235.png" alt></p>
<p>这样命名是因为 我们从 输入层的激励开始 然后进行前向传播给 隐藏层并计算 隐藏层的激励 然后 我们继续前向传播 并计算输出层的激励</p>
<p>这个从输入层到 隐藏层再到输出层依次计算激励的 过程叫<code>前向传播</code></p>
<p>我们刚刚得到了 这一过程的向量化 实现方法 如果你 使用右边这些公式实现它 就会得到 一个有效的 计算h(x) 的方法</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112001704.png" alt></p>
<p>这种前向传播的角度 也可以帮助我们了解 神经网络的原理 和它为什么能够 帮助我们学习<code>非线性假设</code></p>
<p>看一下这个神经网络 我会暂时盖住 图片的左边部分 如果你观察图中剩下的部分 这看起来很像 逻辑回归 在逻辑回归中 我们用 这个节点 即 这个逻辑回归单元 来预测 h(x)的值 具体来说 假设输出的 h(x)将 等于s型激励函数 g(θ0 xa0 +θ1xa1 +θ2xa2 +θ3xa3) 其中 a1 a2 a3 由这三个单元给出</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112002014.png" alt></p>
<p>为了和我之前的定义 保持一致 需要 在这里 还有这些地方都填上上标(2) 同样还要加上这些下标1 因为我只有 一个输出单元 但如果你只观察蓝色的部分 这看起来 非常像标准的 <code>逻辑回归模型</code> 不同之处在于 我现在用的是大写的θ 而不是小写的θ 这样做完 我们只得到了<code>逻辑回归</code></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112002144.png" alt></p>
<p>但是 逻辑回归的 输入特征值 是通过隐藏层计算的 神经网络所做的 就像逻辑回归 但是它 不是使用 x1 x2 x3作为输入特征 而是用a1 a2 a3作为新的输入特征 同样 我们需要把<br>上标加上来和之前的记号保持一致</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112002632.png" alt></p>
<p>有趣的是 特征项a1 a2 a3它们是作为 输入的函数来学习的 具体来说 就是从第一层 映射到第二层的函数 这个函数由其他 一组参数θ(1)决定 所以 在神经网络中 它没有用 输入特征x1 x2 x3 来训练逻辑回归 而是自己 训练逻辑回归 的输入 a1 a2 a3 可以想象 如果 在θ1中选择不同的参数 有时可以学习到一些 很有趣和复杂的特征 就可以 得到一个 更好的假设 比使用原始输入 x1 x2或x3时得到的假设更好 你也可以 选择多项式项 x1 x2 x3等作为输入项 但这个算法可以 <strong>灵活地 快速学习任意的特征项</strong></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112003647.png" alt></p>
<p>我觉得现在描述的这个例子 有点高端 所以 我不知道 你是否能理解 这个具有更复杂特征项的 神经网络 但是 如果你没理解 在接下来的两个视频里 我会讲解一个具体的例子 它描述了怎样用神经网络 如何利用这个隐藏层 计算更复杂的特征 并输入到最后的输出层 以及为什么这样就可以学习更复杂的假设 所以 如果我 现在讲的 你没理解 请继续 观看接下来的两个视频 希望它们 提供的例子能够 让你更加理解神经网络 但有一点 你还可以用其他类型的图来 表示神经网络 神经网络中神经元 相连接的方式 称为<code>神经网络的架构</code> 所以说 <code>架构</code>是指 <strong>不同的神经元是如何相互连接的</strong> 这里有一个不同的 神经网络架构的例子</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112004927.png" alt></p>
<p>你可以 意识到这个第二层 是如何工作的 在这里 我们有三个隐藏单元 它们根据输入层 计算一个复杂的函数 然后第三层 可以将第二层 训练出的特征项作为输入 并在第三层计算一些更复杂的函数 这样 在你到达 输出层之前 即第四层 就可以利用第三层 训练出的更复杂的 特征项作为输入 以此得到非常有趣的非线性假设</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112005012.png" alt></p>
<p>顺便说一下 在这样的 网络里 第一层 被称为输入层 第四层 仍然是我们的输出层 这个网络有两个隐藏层 所以 任何一个不是 输入层或输出层的 都被称为隐藏层</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112005052.png" alt></p>
<p>我希望从这个视频中 你已经大致理解 <strong><code>前向传播</code>在神经网络里的工作原理</strong>： 从输入层的激励 开始 向前 传播到 第一隐藏层 然后传播到第二 隐藏层 最终到达输出层 并且你也知道了如何 向量化这些计算</p>
<p>我发现 这个视频里我讲了 某些层是如何 计算前面层的复杂特征项 我意识到这可能 仍然有点抽象 显得比较高端 所以 我将 在接下来的两个视频中 讨论具体的例子 它描述了怎样用神经网络 来计算 输入的非线性函数 希望能使你 更好的理解 从神经网络中得到的复杂非线性假设</p>
<h3 id="小小的总结–模型表示2"><a href="#小小的总结–模型表示2" class="headerlink" title="小小的总结–模型表示2"></a>小小的总结–模型表示2</h3><p>( <strong>FORWARD PROPAGATION</strong> )<br>相对于使用循环来编码，利用向量化的方法会使得计算更为简便。以上面的神经网络为例，试着计算第二层的值：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110758.png" alt></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110810.png" alt></p>
<p>我们令 ${{z}^{\left( 2 \right)}}={{\theta }^{\left( 1 \right)}}x$，则 ${{a}^{\left( 2 \right)}}=g({{z}^{\left( 2 \right)}})$ ，计算后添加 $a_{0}^{\left( 2 \right)}=1$。 计算输出的值为：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110836.png" alt></p>
<p>我们令 ${{z}^{\left( 3 \right)}}={{\theta }^{\left( 2 \right)}}{{a}^{\left( 2 \right)}}$，则 $h_\theta(x)={{a}^{\left( 3 \right)}}=g({{z}^{\left( 3 \right)}})$。<br>这只是针对训练集中一个训练实例所进行的计算。如果我们要对整个训练集进行计算，我们需要将训练集特征矩阵进行转置，使得同一个实例的特征都在同一列里。即：</p>
${{z}^{\left( 2 \right)}}={{\Theta }^{\left( 1 \right)}}\times {{X}^{T}} $

 ${{a}^{\left( 2 \right)}}=g({{z}^{\left( 2 \right)}})$


<p>为了更好了了解<strong>Neuron Networks</strong>的工作原理，我们先把左半部分遮住：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110857.png" alt></p>
<p>右半部分其实就是以$a_0, a_1, a_2, a_3$, 按照<strong>Logistic Regression</strong>的方式输出$h_\theta(x)$：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213110906.png" alt></p>
<p>其实神经网络就像是<strong>logistic regression</strong>，只不过我们把<strong>logistic regression</strong>中的输入向量$\left[ x_1\sim {x_3} \right]$ 变成了中间层的$\left[ a_1^{(2)}\sim a_3^{(2)} \right]$, 即:  $h_\theta(x)=g\left( \Theta_0^{\left( 2 \right)}a_0^{\left( 2 \right)}+\Theta_1^{\left( 2 \right)}a_1^{\left( 2 \right)}+\Theta_{2}^{\left( 2 \right)}a_{2}^{\left( 2 \right)}+\Theta_{3}^{\left( 2 \right)}a_{3}^{\left( 2 \right)} \right)$<br>我们可以把$a_0, a_1, a_2, a_3$看成更为高级的特征值，也就是$x_0, x_1, x_2, x_3$的进化体，并且它们是由 $x$与$\theta$决定的，因为是梯度下降的，所以$a$是变化的，并且变得越来越厉害，所以这些更高级的特征值远比仅仅将 $x$次方厉害，也能更好的预测新数据。<br>这就是神经网络相比于逻辑回归和线性回归的优势。</p>
<h2 id="8-5-特征和直观理解1-Examples-and-Intuitions-I"><a href="#8-5-特征和直观理解1-Examples-and-Intuitions-I" class="headerlink" title="8.5 特征和直观理解1(Examples and Intuitions I)"></a>8.5 特征和直观理解1(Examples and Intuitions I)</h2><p>在接下来两节视频中 我要通过讲解 一个具体的例子来解释 神经网络是如何计算 关于输入的复杂的<code>非线性函数</code> 希望这个例子可以 让你了解为什么 神经网络可以用来学习复杂的非线性假设</p>
<p>考虑下面的问题 我们有二进制的 输入特征 x1 x2 要么取0 要么取1 所以x1和x2只能 有两种取值</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112145858.png" alt></p>
<p>在这个例子中 我只画出了 两个正样本和 两个负样本 但你可以认为这是一个 更复杂的学习问题的 简化版本 在这个复杂问题中 我们可能 在右上角有一堆<strong>正样本（红色叉叉）</strong> 在左下方有 一堆用<strong>圆圈表示的负样本</strong></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150052.png" alt></p>
<p>我们想要学习一种非线性的 决策边界来 区分正负样本 那么 神经网络是 如何做到的呢？</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150138.png" alt></p>
<p>为了描述方便我不用右边这个例子 我用左边这个例子 这样更容易说明 具体来讲 这里需要计算的是 <code>目标函数y</code> 等于<strong>x1异或x2</strong> 或者 y也可以等于 x1<strong>异或非</strong>x2 其中异或非表示 <strong>x1异或x2后取反</strong> X1异或X2 为真当且仅当 这两个值 X1或者X2中有且仅有一个为1 如果我 用XNOR作为例子 比用NOT作为例子 结果会好一些 但这两个其实是相同的 这就意味着在x1 异或x2后再取反 即 <strong>当它们同时为真 或者同时为假的时候 我们将获得 y等于1的结果</strong></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150441.png" alt></p>
<p>如果它们中<strong>仅有一个 为真 y则为0</strong></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150535.png" alt></p>
<p>我们想要知道是否能 找到一个神经网络模型来拟合这种训练集</p>
<p>为了建立 能拟合<code>XNOR运算</code> 的神经网络 我们先 讲解一个稍微简单 的神经网络 它拟合了<code>“且运算”</code></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150741.png" alt></p>
<p>假设我们 有输入x1和 x2 并且都是二进制 即要么为0要么为1 我们的<code>目标函数y</code>正如你所知道的 等于<code>x1且x2</code> 这是一个<code>逻辑与</code></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150855.png" alt></p>
<p>那么 我们怎样得到一个 具有单个神经元的神经网络来计算 这个逻辑与呢 为了做到这一点 我也需要画出<code>偏置单元</code> 即这个里面有个<code>+1的单元</code></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150954.png" alt></p>
<p>现在 让我给这个网络 分配一些权重 或参数 我在图上写出这些参数 这里是-30 正20 正20 即我给 x0前面的 系数赋值 为-30. 这个正1会 作为这个单元的值 关于20的参数值 且x1乘以+20 以及x2乘以+20 都是这个单元的输入</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151059.png" alt></p>
<p>所以 我的假设ħ(x) 等于 g(-30 + 20x1 + 20x2) 在图上画出 这些参数和 权重是很方便很直观的 其实 在这幅神经网络图中 这个-30 其实是θ(1)10 这个是 θ(1)11 这是 θ(1)12 但把它想成 这些边的 权重会更容易理解</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151204.png" alt></p>
<p>让我们来看看这个小神经元是怎样计算的 回忆一下 s型 激励函数g(z)看起来是这样的 它从0开始 光滑 上升 穿过0.5 渐进到1.</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151258.png" alt></p>
<p>我们给出一些坐标 如果横轴值 z等于4.6 则 S形函数等于0.99 这是非常接近 1的 并且由于对称性 如果z为-4.6 S形函数 等于0.01 非常接近0</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151412.png" alt></p>
<p>让我们来看看四种可能的输入值 x1和x2的四种可能输入 看看我们的假设 在各种情况下的输出 如果X1和X2均为 0 那么 你看看这个 如果 x1和x2都等于 为0 则假设会输出g(-30) g(-30)在图的 很左边的地方 非常接近于0</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151716.png" alt></p>
<p>如果x1等于0且 x2等于1 那么 此公式等于 g关于 -10取值 也在很左边的位置 所以 也是非常接近0 这个也是g(-10) 也就是说 如果x1 等于1并且 x2等于0 这就是-30加20等于-10 最后 如​​果 x1等于1 x2等于 1 那么这等于 -30 +20 +20 所以这是 取+10时 非常接近1</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151844.png" alt></p>
<p>如果你看看 在这一列 这就是 逻辑“与”的计算结果 所以 这里得到的h h关于x取值 近似等于x1和x2的与运算的值 换句话说 假设输出 1 当且仅当 x1 x2 都等于1 所以 通过写出 这张真值表 我们就弄清楚了 神经网络 计算出的逻辑函数</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152000.png" alt></p>
<p>这里的神经网络 实现了或函数的功能 接下来我告诉你是怎么看出来的 如果你把 假设写出来 会发现它等于 g关于-10 +20x1 +20x2的取值 如果把这些值都填上 会发现 这是g(-10) 约等于0 这是g(10) 约等于1 这个也约等于1</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152137.png" alt></p>
<p>这些数字 本质上就是逻辑或 运算得到的值</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152206.png" alt></p>
<p>所以 我希望 通过这个例子 你现在明白了 神经网络里单个的 神经元在计算 如AND和OR逻辑运算时是怎样发挥作用的 在接下来的视频中 我们将继续 讲解一个更复杂的例子 我们将告诉你 一个多层的神经网络 怎样被用于 计算更复杂的函数  如 XOR 函数或 XNOR 函数</p>
<h3 id="小小的总结–特征和直观理解I"><a href="#小小的总结–特征和直观理解I" class="headerlink" title="小小的总结–特征和直观理解I"></a>小小的总结–特征和直观理解I</h3><p>从本质上讲，神经网络能够通过学习得出其自身的一系列特征。在普通的逻辑回归中，我们被限制为使用数据中的原始特征$x_1,x_2,...,{{x}_{n}}$，我们虽然可以使用一些二项式项来组合这些特征，但是我们仍然受到这些原始特征的限制。在神经网络中，原始特征只是输入层，在我们上面三层的神经网络例子中，第三层也就是输出层做出的预测利用的是第二层的特征，而非输入层中的原始特征，我们可以认为第二层中的特征是神经网络通过学习后自己得出的一系列用于预测输出变量的新特征。</p>
<p>神经网络中，单层神经元（无中间层）的计算可用来表示逻辑运算，比如逻辑与(<strong>AND</strong>)、逻辑或(<strong>OR</strong>)。</p>
<p>举例说明：逻辑与(<strong>AND</strong>)；下图中左半部分是神经网络的设计与<strong>output</strong>层表达式，右边上部分是<strong>sigmod</strong>函数，下半部分是真值表。</p>
<p>我们可以用这样的一个神经网络表示<strong>AND</strong> 函数：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111107.png" alt></p>
<p>其中$\theta_0 = -30, \theta_1 = 20, \theta_2 = 20$<br>我们的输出函数$h_\theta(x)$即为：$h_\Theta(x)=g\left( -30+20x_1+20x_2 \right)$</p>
<p>我们知道$g(x)$的图像是：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111113.png" alt></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111120.png" alt></p>
<p>所以我们有：$h_\Theta(x) \approx \text{x}_1 \text{AND} \, \text{x}_2$</p>
<p>所以我们的：$h_\Theta(x) $</p>
<p>这就是<strong>AND</strong>函数。</p>
<p>接下来再介绍一个<strong>OR</strong>函数：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111126.png" alt></p>
<p><strong>OR</strong>与<strong>AND</strong>整体一样，区别只在于的取值不同。</p>
<h2 id="8-6-样本和直观理解II-Examples-and-Intuitions-II"><a href="#8-6-样本和直观理解II-Examples-and-Intuitions-II" class="headerlink" title="8.6 样本和直观理解II(Examples and Intuitions II)"></a>8.6 样本和直观理解II(Examples and Intuitions II)</h2><p>在这段视频中 我想通过例子来向大家展示 一个神经网络 是怎样计算<code>非线性的假设函数</code></p>
<p>在上一段视频中 我们学习了 怎样运用神经网络 来计算x1和x2的<code>与运算</code> 以及x1和x2的<code>或运算</code> 其中x1和x2都是二进制数 也就是说 它们的值只能为0或1 同时 我们也学习了 怎样进行<code>逻辑非</code>运算 也就是计算 “非x1” 我先写出这个神经网络中 相连接的各权值 这里我们只有一个输入量x1 在这里我们也加上了 表示<code>偏差的单位元</code> +1 如果我将输入单元和两个权数相连 也就是+10和-20 则可用以下假设方程来计算 <code>h(x)=g(10-20x1)</code> 其中<code>g</code>是一个<code>S型函数</code></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152619.png" alt></p>
<p>那么 当x1等于0时 计算出假设函数 g(10-20*0) 也就是g(10) 这个值近似的等于1 而当x等于1时 计算出的假设函数则变成 g(-10) 也就是约等于0 如果你观察这两个值 你会发现这实际上计算的 就是“非x1”函数</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152711.png" alt></p>
<p>所以要计算<code>逻辑非运算</code> 总体思路是 在你希望<strong>取非运算的变量前面 放上一个绝对值大的负数作为权值</strong> 因此 如果放一个-20 那么和x1相乘 很显然 最终的结果 就得到了对x1进行非运算的效果</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152935.png" alt></p>
<p>另外 我再给出一个例子 计算这样一个函数 <code>(非x1)与(非x2)</code> 我希望大家思考一下 自己动手算一算 你大概应该知道 至少应该<strong>在x1和x2前面 放一个绝对值比较大的负数作为权值</strong> 不过 还有一种可行的方法 是<strong>建立一个神经网络来计算 用只有一个输出单元的神经网络</strong> 没问题吧？ 因此 这个看起来很长的逻辑函数 “(非x1)与(非x2)”的值 将等于1 当且仅当 x1等于x2等于0 所以 这是个逻辑函数 这里是非x1 也就是说x1必为0 然后是非x2 这表示x2也必为0 因此这个逻辑函数等于1 当且仅当 x1和x2的值都为0时成立</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153132.png" alt></p>
<p>现在你应该也清楚了 怎样建立一个小规模的神经网络 来计算 这个逻辑函数的值</p>
<p>把以上我们介绍的 这三个部分内容放在一起 “x1与x2”与运算的网络 以及计算 “(非x1)与(非x2)”的网络 还有最后一个是 “x1或x2”的或运算网络 把这三个网络放在一起 我们就应该能计算 “x1 XNOR x2” 也就是<code>同或门运算</code></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153229.png" alt></p>
<p>提醒一下 如果这是x1 x2 那么我们想要计算的这个函数 在这里和这里是负样本 而在这里和这里 函数有正样本值 那么很显然 为了分隔开正样本和负样本 我们需要一个<code>非线性的判别边界</code></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153334.png" alt></p>
<p>这里我们用以下这个网络来解决 取输入单元 +1 x1和x2 建立第一个隐藏层单元 我们称其为a(2)1 因为它是第一个隐藏单元 接下来我要从红色的网络 也就是”x1与x2”这个网络 复制出权值 也就是-30 20 20 接下来 我再建立第二个隐藏单元 我们称之为a(2)2 它是第二层的第二个隐藏单元 然后再从中间的青色网络中 复制出权值 这样我们就有了 10 -20 -20 这样三个权值</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153443.png" alt></p>
<p>因此 我们来看一下真值表中的值 对于红色的这个网络 我们知道是x1和x2的与运算 所以 这里的值大概等于0 0 0 1 这取决于x1和x2的具体取值</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153548.png" alt></p>
<p>对于a (2)2 也就是青色的网络 我们知道这是“(非x1)与(非x2)”的运算 那么对于x1和x2的四种取值 其结果将为 1 0 0 0</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153638.png" alt></p>
<p>最后 建立输出节点 也就是输出单元 a(3)1 这也是等于输出值h(x) 然后 复制一个或运算网络 同时 我需要一个+1作为偏差单元 将其添加进来 然后从绿色的网络中复制出所有的权值 也就是-10 20 20</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153733.png" alt></p>
<p>我们之前已经知道这是一个<code>或运算</code>函数 那么我们继续看真值表的值 第一行的值是0和1的或运算 其结果为1 然后是0和0的或运算 其结果为0 0和0的或运算 结果还是0 1和0的或运算 其结果为1</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153836.png" alt></p>
<p>因此 h(x)的值等于1 当x1和x2都为0 或者x1和x2都为1的时候成立 具体来说 在这两种情况时 h(x)输出1 在另两种情况时 h(x)输出0 那么对于这样一个神经网络 有一个输入层 一个隐藏层 和一个输出层 我们最终得到了 计算<code>XNOR函数</code>的<code>非线性判别边界</code></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153940.png" alt></p>
<p>更一般的理解是 在输入层中 我们只有原始输入值 然后我们建立了一个隐藏层 用来计算稍微复杂一些的 输入量的函数 如图所示 这些都是稍微复杂一些的函数 然后 通过添加另一个层 我们得到了一个更复杂一点的函数 这就是关于 神经网络可以计算较复杂函数 的某种直观解释</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112154036.png" alt></p>
<p>我们知道 当层数很多的时候 你有一个相对简单的输入量的函数 作为第二层 而第三层可以建立在此基础上 来计算更加复杂一些的函数 然后再下一层 又可以计算再复杂一些的函数</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112154119.png" alt></p>
<p>在这段视频的最后 我想给大家展示一个有趣的例子 这是一个神经网络 通过运用更深的层数 来计算更加复杂函数的例子 我将要展示的这段视频 来源于我的一个好朋友 阳乐昆(Yann LeCun) Yann是一名教授 供职于纽约大学 他也是神经网络研究 早期的奠基者之一 也是这一领域的大牛 他的很多理论和想法 现在都已经被应用于 各种各样的产品和应用中 遍布于全世界 所以我想向大家展示一段 他早期工作中的视频 这段视频中 他使用神经网络的算法 进行<code>手写数字的辨识</code></p>
<p>你也许记得 在这门课刚开始的时候 我说过 关于神经网络的一个早期成就 就是应用神经网络 读取邮政编码 以帮助我们进行邮递 那么这便是其中一种尝试 这就是为了解决这个问题 而尝试采用的一种算法</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112154302.png" alt></p>
<p>在视频中 这个区域 是输入区域 表示的是手写字符 它们将被传递给神经网络 这一列数字表示 通过该网络第一个隐藏层运算后 特征量的可视化结果 因此通过第一个隐藏层 可视化结果显示的是 探测出的不同特征 不同边缘和边线</p>
<p>这是下一个隐藏层的可视化结果 似乎很难看出 怎样理解更深的隐藏层 以及下一个隐藏层 计算的可视化结果 可能你如果要想看出到底在进行怎样的运算 还是比较困难的 最终远远超出了第一个隐藏层的效果 但不管怎样 最终这些学习后的特征量 将被送到最后一层 也就是输出层 并且在最后作为结果 显示出来 最终预测到的结果 就是这个神经网络辨识出的手写数字的值 下面我们来观看这段视频</p>
<p>我希望你 喜欢这段视频 也希望这段视频能给你一些直观的感受 关于神经网络可以学习的 较为复杂一些的函数 在这个过程中 它使用的输入是不同的图像 或者说 就是一些原始的像素点 第一层计算出一些特征 然后下一层再计算出 一些稍复杂的特征 然后是更复杂的特征 然后这些特征 实际上被最终传递给 最后一层<code>逻辑回归分类器</code>上 使其准确地预测出 神经网络“看”到的数字</p>
<h3 id="小小的总结–特征和直观理解II"><a href="#小小的总结–特征和直观理解II" class="headerlink" title="小小的总结–特征和直观理解II"></a>小小的总结–特征和直观理解II</h3><p>二元逻辑运算符（<strong>BINARY LOGICAL OPERATORS</strong>）当输入特征为布尔值（0或1）时，我们可以用一个单一的激活层可以作为二元逻辑运算符，为了表示不同的运算符，我们只需要选择不同的权重即可。</p>
<p>下图的神经元（三个权重分别为-30，20，20）可以被视为作用同于逻辑与（<strong>AND</strong>）：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111210.png" alt></p>
<p>下图的神经元（三个权重分别为-10，20，20）可以被视为作用等同于逻辑或（<strong>OR</strong>）：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111223.png" alt></p>
<p>下图的神经元（两个权重分别为 10，-20）可以被视为作用等同于逻辑非（<strong>NOT</strong>）：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111229.png" alt></p>
<p>我们可以利用神经元来组合成更为复杂的神经网络以实现更复杂的运算。例如我们要实现<strong>XNOR</strong> 功能（输入的两个值必须一样，均为1或均为0），即 $\text{XNOR}=( \text{x}_1\, \text{AND}\, \text{x}_2 )\, \text{OR} \left( \left( \text{NOT}\, \text{x}_1 \right) \text{AND} \left( \text{NOT}\, \text{x}_2 \right) \right)$<br>首先构造一个能表达$\left( \text{NOT}\, \text{x}_1 \right) \text{AND} \left( \text{NOT}\, \text{x}_2 \right)$部分的神经元：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111241.png" alt></p>
<p>然后将表示 <strong>AND</strong> 的神经元和表示$\left( \text{NOT}\, \text{x}_1 \right) \text{AND} \left( \text{NOT}\, \text{x}_2 \right)$的神经元以及表示 OR 的神经元进行组合：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111254.png" alt></p>
<p>我们就得到了一个能实现 $\text{XNOR}$ 运算符功能的神经网络。</p>
<p>按这种方法我们可以逐渐构造出越来越复杂的函数，也能得到更加厉害的特征值。</p>
<p>这就是神经网络的厉害之处。</p>
<h2 id="8-7-多类分类-Multiclass-Classification"><a href="#8-7-多类分类-Multiclass-Classification" class="headerlink" title="8.7 多类分类(Multiclass Classification)"></a>8.7 多类分类(Multiclass Classification)</h2><p>在这段视频中 我想和大家谈谈 如何用神经网络做<code>多类别分类</code> 在多类别分类中 通常有不止一个类别 需要我们去区分 在上一段视频最后 我们提到了有关 手写数字辨识的问题 这实际上正是一个 多类别分类的问题 因为辨识数字 从0到9 正好是10个类别 因此你也许已经想问 究竟应该怎样处理这个问题</p>
<p>我们处理<code>多类别分类</code>的方法 实际上是基于<code>一对多神经网络算法</code> 而延伸出来的</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155020.png" alt></p>
<p>让我们来看这样一个例子 还是有关计算机视觉的例子 就像我之前介绍过的 识别汽车的例子 但与之不同的是 现在我们希望处理的 是四个类别的分类问题 给出一幅图片 我们需要确定图上是什么 是一个行人 一辆汽车 还是一辆摩托车 亦或是一辆卡车 对于这样一个问题 我们的做法是 建立一个具有四个输出单元的神经网络 也就是说 此时神经网络的输出 是一个<code>四维向量</code></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155134.png" alt></p>
<p>因此 现在的输出 需要用一个向量来表示 这个向量中有四个元素 而我们要做的 是对第一个输出元素 进行分辨 图上是不是一个行人 然后对第二个元素 分辨它是不是一辆汽车 同样 第三个元素 是不是摩托车 第四个元素 是不是一辆卡车 因此 当图片上是一个行人时 我们希望这个神经网络 输出1 0 0 0 当图片是一辆轿车时 我们希望输出是 0 1 0 0 当图片是一辆摩托车时 我们希望结果是0 0 1 0 以此类推</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155231.png" alt></p>
<p>所以 这和我们介绍逻辑回归时 讨论过的一对多方法 其实是一样的 只不过现在我们有 四个逻辑回归的分类器 而我们需要对 四个分类器中每一个 都分别进行识别分类 因此 重新整理一下这页讲义 这是我们的神经网络结构 有四个输出单元</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155343.png" alt></p>
<p>这是针对不同的图片 我们h(x)的表达式 此时 我们需要用如下的方法 来表示训练集 在这个例子中 当我们要表征一个 具有行人 汽车 摩托车和卡车 这样四个不同图片作为元素的训练集时 我们应该怎么做呢 之前 我们把<code>标签</code>写作一个整数 用y来表示 1 2 3 4 现在我们不这样表示y 而是用以下的方法来代表y 那就是 y(i) 表示1 0 0 0 或者0 1 0 0 或者0 0 1 0 或者0 0 0 1 根据相对于的图片x(i)来决定 这样 我们的训练样本 将成为 x(i) y(i) 这一对数 其中 x(i)表示我们已知的 四种物体图像中的一个 而y(i)是这四个向量中的某一个</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155552.png" alt></p>
<p>我们希望 能够找到某种方法 让我们的神经网络输出某个值 因此 h(x) 近似约等于y 在我们的例子中 h(x) 和 y(i) 它们都应该是四维向量 因为我们有四个类别</p>
<p>这样我们就讨论了 怎样基于我们的假设表达式 来表征神经网络 在接下来几节课中 我们会开始讨论 怎样得到<code>训练集</code> 以及怎样<strong>自动学习神经网络的参数</strong></p>
<h3 id="小小的总结–多类分类"><a href="#小小的总结–多类分类" class="headerlink" title="小小的总结–多类分类"></a>小小的总结–多类分类</h3><p>当我们有不止两种分类时（也就是$y=1,2,3….$），比如以下这种情况，该怎么办？如果我们要训练一个神经网络算法来识别路人、汽车、摩托车和卡车，在输出层我们应该有4个值。例如，第一个值为1或0用于预测是否是行人，第二个值用于判断是否为汽车。</p>
<p>输入向量$x$有三个维度，两个中间层，输出层4个神经元分别用来表示4类，也就是每一个数据在输出层都会出现${{\left[ a\text{ }b\text{ }c\text{ }d \right]}^{T}}$，且$a,b,c,d$中仅有一个为1，表示当前类。下面是该神经网络的可能结构示例：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111455.png" alt></p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111508.png" alt></p>
<p>神经网络算法的输出结果为四种可能情形之一：</p>
<p><img src="https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20190213111522.png" alt></p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.fengwenhua.top" rel="external nofollow noreferrer">冯文华</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.fengwenhua.top/2019/02/13/di-ba-zhang-shen-jing-wang-luo-biao-shu-neural-networks-representation/">https://www.fengwenhua.top/2019/02/13/di-ba-zhang-shen-jing-wang-luo-biao-shu-neural-networks-representation/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://www.fengwenhua.top" target="_blank">冯文华</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/神经网络表述/">
                                    <span class="chip bg-color">神经网络表述</span>
                                </a>
                            
                                <a href="/tags/Neural-Networks-Representation/">
                                    <span class="chip bg-color">Neural-Networks-Representation</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechatpay.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    
        <link rel="stylesheet" href="/libs/gitment/gitment-default.css">
<link rel="stylesheet" href="/css/gitment.css">

<div class="gitment-card card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitment-content" class="card-content"></div>
</div>

<script src="/libs/gitment/gitment.js"></script>
<script>
var gitment = new Gitment({
    id: 'Tue Feb 12 2019 21:59:18 GMT+0000',
    owner: 'fengwenhua',
    repo: 'fengwenhua.github.io',
    oauth: {
        client_id: '487b675438c149b5818b',
        client_secret: '501477eec1e2ed9f27751d02281b5834021d6c7b'
    }
});

gitment.render('gitment-content');
</script>
    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/02/14/dell-7559-10-14-3-hei-ping-guo/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="dell-7559-10.14.3-黑苹果">
                        
                        <span class="card-title">dell-7559-10.14.3-黑苹果</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            [toc]
7559黑苹果
参考链接: Dell 7559 安装10.14GM教程（i5+UEFI）这位大佬的教程已经很完善了,只不过本人是小白,所以对这位大佬的教程进行了一些补充,如果你已经按照他的教程安装完成了,现在是10.14或者10
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-02-13
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux/" class="post-category">
                                    Linux
                                </a>
                            
                            <a href="/categories/Linux/黑苹果/" class="post-category">
                                    黑苹果
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/黑苹果/">
                        <span class="chip bg-color">黑苹果</span>
                    </a>
                    
                    <a href="/tags/hackintosh/">
                        <span class="chip bg-color">hackintosh</span>
                    </a>
                    
                    <a href="/tags/dell-7559/">
                        <span class="chip bg-color">dell-7559</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/02/13/di-qi-zhang-zheng-ze-hua-regularization/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="第七章-正则化-Regularization">
                        
                        <span class="card-title">第七章-正则化-Regularization</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            第七章 正则化(Regularization)7.1 过拟合的问题
到现在为止 你已经见识了 几种不同的学习算法 包括线性回归和逻辑回归 它们能够有效地解决许多问题 但是当将它们应用到 某些特定的机器学习应用时 会遇到过度拟合(over-f
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-02-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/机器学习/" class="post-category">
                                    机器学习
                                </a>
                            
                            <a href="/categories/机器学习/机器学习入门/" class="post-category">
                                    机器学习入门
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/正则化/">
                        <span class="chip bg-color">正则化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>


    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2018</span>
            <a href="https://www.fengwenhua.top" target="_blank">冯文华</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">141.3k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/fengwenhua" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:807296772@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=807296772" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 807296772" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-140817753-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'UA-140817753-1');
</script>


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
